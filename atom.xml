<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨水的天空落了雨</title>
  
  <subtitle>rainSkyの乌托邦</subtitle>
  <link href="https://rain-sky.github.io/atom.xml" rel="self"/>
  
  <link href="https://rain-sky.github.io/"/>
  <updated>2021-05-16T08:31:31.391Z</updated>
  <id>https://rain-sky.github.io/</id>
  
  <author>
    <name>rain-Sky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析==,equals,hashcode</title>
    <link href="https://rain-sky.github.io/2021/04/27/%E6%B5%85%E6%9E%90-equals-hashcode/"/>
    <id>https://rain-sky.github.io/2021/04/27/%E6%B5%85%E6%9E%90-equals-hashcode/</id>
    <published>2021-04-27T00:52:45.000Z</published>
    <updated>2021-05-16T08:31:31.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅析-equals-hashcode"><a href="#浅析-equals-hashcode" class="headerlink" title="浅析==,equals,hashcode"></a>浅析==,equals,hashcode</h1><h2 id="情景回顾"><a href="#情景回顾" class="headerlink" title="情景回顾"></a>情景回顾</h2><p>有一问曰：两个obj，如果equals相等，hashCode()一定相等(符合代码规范的情况下)</p><p>首先：</p><ol><li>== 比较的是两个对象在java虚拟机中的地址</li><li>equals 默认比较的也是两个对象在java虚拟机中的地址，但是我们可以对一个对象的equals方法进行重写，而“==”我们无法重写</li><li>hashcode 返回一个对象在java虚拟机中的地址</li></ol><h2 id="JDK-8中Object类中对于equals与hashcode方法的描述"><a href="#JDK-8中Object类中对于equals与hashcode方法的描述" class="headerlink" title="JDK 8中Object类中对于equals与hashcode方法的描述"></a>JDK 8中Object类中对于equals与hashcode方法的描述</h2><blockquote><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></tbody></table></figure><p>指示一些其他对象是否等于此。</p><p><code>equals</code>方法在非空对象引用上实现等价关系： </p><ul><li><em>自反性</em> ：对于任何非空的参考值<code>x</code> ，  <code>x.equals(x)</code>应该返回<code>true</code> 。 </li><li>它是<em>对称的</em> ：对于任何非空引用值<code>x</code>和<code>y</code> ，  <code>x.equals(y)</code>应该返回<code>true</code>当且仅当<code>y.equals(x)</code>回报<code>true</code>  。 </li><li><em>传递性</em> ：对于任何非空引用值<code>x</code> ， <code>y</code>和<code>z</code>  ，如果<code>x.equals(y)</code>回报<code>true</code>个<code>y.equals(z)</code>回报<code>true</code>  ，然后<code>x.equals(z)</code>应该返回<code>true</code> 。 </li><li>它是<em>一致的</em> ：对于任何非空引用值<code>x</code>和<code>y</code>  ，多次调用<code>x.equals(y)</code>始终返回<code>true</code>或始终返回<code>false</code>  ，没有设置中使用的信息<code>equals</code>比较上的对象被修改。 </li><li>对于任何非空的参考值<code>x</code> ，  <code>x.equals(null)</code>应该返回<code>false</code> 。 </li></ul><p>该<code>equals</code>类方法<code>Object</code>实现对象上差别可能性最大的相等关系;  也就是说，对于任何非空的参考值<code>x</code>和<code>y</code>  ，当且仅当<code>x</code>和<code>y</code>引用相同的对象（ <code>x ==  y</code>具有值<code>true</code> ）时，该方法返回<code>true</code> 。 </p><p>请注意，无论何时覆盖该方法，通常需要覆盖<code>hashCode</code>方法，以便维护<code>hashCode</code>方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。 </p><ul><li><p>参数 </p><p><code>obj</code> - 与之比较的参考对象。 </p></li><li><p>结果 </p><p><code>true</code>如果此对象与obj参数相同;  <code>false</code>否则。 </p></li></ul></blockquote><blockquote><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br></pre></td></tr></tbody></table></figure><p>返回对象的哈希码值。支持这种方法是为了散列表，如<a href="../../java/util/HashMap.html"><code>HashMap</code></a>提供的那样 。</p><p><code>hashCode</code>的总合同是： </p><ul><li>只要在执行Java应用程序时多次在同一个对象上调用该方法，  <code>hashCode</code>方法必须始终返回相同的整数，前提是修改了对象中<code>equals</code>比较中的信息。  该整数不需要从一个应用程序的执行到相同应用程序的另一个执行保持一致。 </li><li>如果根据<code>equals(Object)</code>方法两个对象相等，则在两个对象中的每个对象上调用<code>hashCode</code>方法必须产生相同的整数结果。 </li><li><em>不</em>要求如果两个对象根据equals(java.lang.Object)方法不相等，那么在两个对象中的每个对象上调用hashCode方法必须产生不同的整数结果。  但是，程序员应该意识到，为不等对象生成不同的整数结果可能会提高哈希表的性能。 </li></ul><p>尽可能多的合理实用，由类别Object定义的hashCode方法确实为不同对象返回不同的整数。  （这通常通过将对象的内部地址转换为整数来实现，但Java的编程语言不需要此实现技术。） </p><ul><li><p>结果 </p><p>该对象的哈希码值。 </p></li></ul></blockquote><hr><p><strong>由以上描述可知：</strong></p><blockquote><p><strong>hashCode是所有java对象的固有方法，如果不重载的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同</strong>了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</p><p>两个对象equals（）相同，那么hashcode肯定也相同，但equals()不同，hashcode不一定不同。</p><p>而且，还需要注意一下两点：</p><p>1）hashCode和equals两个方法是有语义关联的，它们需要满足：</p><p>A.equals(B)==true –&gt; A.hashCode()==B.hashCode()</p><p>因此重载其中一个方法时也需要将另一个也重载。</p></blockquote><p>附上String类equals源码实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浅析-equals-hashcode&quot;&gt;&lt;a href=&quot;#浅析-equals-hashcode&quot; class=&quot;headerlink&quot; title=&quot;浅析==,equals,hashcode&quot;&gt;&lt;/a&gt;浅析==,equals,hashcode&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="Java" scheme="https://rain-sky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ssm整合</title>
    <link href="https://rain-sky.github.io/2021/04/24/ssm%E6%95%B4%E5%90%88/"/>
    <id>https://rain-sky.github.io/2021/04/24/ssm%E6%95%B4%E5%90%88/</id>
    <published>2021-04-24T01:49:32.000Z</published>
    <updated>2021-05-08T01:40:48.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssm整合流程"><a href="#ssm整合流程" class="headerlink" title="ssm整合流程"></a>ssm整合流程</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><h3 id="1-1-数据库建立"><a href="#1-1-数据库建立" class="headerlink" title="1.1 数据库建立"></a>1.1 数据库建立</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> ssmbuild;</span><br><span class="line"><span class="keyword">USE</span> ssmbuild;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`books`</span>(</span><br><span class="line"><span class="string">`bookID`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">"书id"</span>,</span><br><span class="line"><span class="string">`bookName`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">"书名"</span>,</span><br><span class="line"><span class="string">`bookCounts`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">"数量"</span>,</span><br><span class="line"><span class="string">`detail`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">"描述"</span>,</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`bookID`</span>(<span class="string">`bookID`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`books`</span> <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">'Spring'</span>,<span class="number">1</span>,<span class="string">'从入门到放弃'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'MySQL'</span>,<span class="number">10</span>,<span class="string">'从删库到跑路'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'Linux'</span>,<span class="number">5</span>,<span class="string">'从进门到进牢'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-在IDEA中连接数据库-测试连接成功"><a href="#1-2-在IDEA中连接数据库-测试连接成功" class="headerlink" title="1.2 在IDEA中连接数据库(测试连接成功)"></a>1.2 在IDEA中连接数据库(测试连接成功)</h3><p><img src="https://gitee.com/rain-sky/images/raw/master/20210428140125.png"></p><h3 id="1-3-编写数据库实体映射类"><a href="#1-3-编写数据库实体映射类" class="headerlink" title="1.3 编写数据库实体映射类"></a>1.3 编写数据库实体映射类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> boolID;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookCounts;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> boolID, String bookName, <span class="keyword">int</span> bookCounts, String detail)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.boolID = boolID;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.bookCounts = bookCounts;</span><br><span class="line">        <span class="keyword">this</span>.detail = detail;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBoolID</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> boolID;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoolID</span><span class="params">(<span class="keyword">int</span> boolID)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.boolID = boolID;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBookCounts</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookCounts;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookCounts</span><span class="params">(<span class="keyword">int</span> bookCounts)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.bookCounts = bookCounts;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDetail</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> detail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDetail</span><span class="params">(String detail)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.detail = detail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The book: "</span>+<span class="keyword">this</span>.bookName+<span class="string">", "</span>+<span class="keyword">this</span>.boolID+<span class="string">", "</span>+<span class="keyword">this</span>.bookCounts+<span class="string">", "</span>+<span class="keyword">this</span>.detail;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-maven配置，依赖导入以及资源过滤"><a href="#2-maven配置，依赖导入以及资源过滤" class="headerlink" title="2 maven配置，依赖导入以及资源过滤"></a>2 maven配置，依赖导入以及资源过滤</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.chen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>BookManage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-配置DAO层"><a href="#3-配置DAO层" class="headerlink" title="3. 配置DAO层"></a>3. 配置DAO层</h2><h3 id="3-1-编写外部数据源配置database-properties"><a href="#3-1-编写外部数据源配置database-properties" class="headerlink" title="3.1 编写外部数据源配置database.properties"></a>3.1 编写外部数据源配置database.properties</h3><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123123</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-编写mybatis-config-xml"><a href="#3-2-编写mybatis-config-xml" class="headerlink" title="3.2 编写mybatis-config.xml"></a>3.2 编写mybatis-config.xml</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.chen.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一般我们会在mybatis-config.xml做set的配置，如配置日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-编写spring-dao-xml"><a href="#3-3-编写spring-dao-xml" class="headerlink" title="3.3 编写spring-dao.xml"></a>3.3 编写spring-dao.xml</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 引入本地数据库配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"databases.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用C3P0连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"${jdbc.user}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 托管sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/chen/dao/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 托管sqlSessionTemplate(即sqlSession) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--     动态注入Dao层的Mapper实现的代理类   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.chen.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-4-编写DAO层接口"><a href="#3-4-编写DAO层接口" class="headerlink" title="3.4 编写DAO层接口"></a>3.4 编写DAO层接口</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chen.pojo.Book;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookMapper</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">( <span class="meta">@Param("bookId")</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">queryBookById</span><span class="params">(<span class="meta">@Param("bookId")</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-5-编写接口对应的mapper"><a href="#3-5-编写接口对应的mapper" class="headerlink" title="3.5 编写接口对应的mapper"></a>3.5 编写接口对应的mapper</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.chen.dao.BookMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertBook"</span> <span class="attr">parameterType</span>=<span class="string">"com.chen.pojo.Book"</span>&gt;</span></span><br><span class="line">        insert into ssmbuild.books values (#{bookId},#{bookName},#{bookCounts},#{detail});</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteBookById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete * from ssmbuild.books where bookID = #{bookId};</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBook"</span> <span class="attr">parameterType</span>=<span class="string">"com.chen.pojo.Book"</span>&gt;</span></span><br><span class="line">        update ssmbuild.books set bookID = #{bookId},bookCounts = #{bookCounts},bookName = #{bookName},detail = #{detail};</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBookById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.chen.pojo.Book"</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books where bookID = #{bookId};</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllBook"</span> <span class="attr">resultType</span>=<span class="string">"com.chen.pojo.Book"</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4-配置service层"><a href="#4-配置service层" class="headerlink" title="4 配置service层"></a>4 配置service层</h2><h3 id="4-1-配置spring-service-xml"><a href="#4-1-配置spring-service-xml" class="headerlink" title="4.1 配置spring-service.xml"></a>4.1 配置spring-service.xml</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描所有service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.chen.servises"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">value</span>=<span class="string">"datasouce"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-编写service层接口"><a href="#4-2-编写service层接口" class="headerlink" title="4.2 编写service层接口"></a>4.2 编写service层接口</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.servises;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chen.pojo.Book;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">( <span class="meta">@Param("bookId")</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">queryBookById</span><span class="params">(<span class="meta">@Param("bookId")</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-编写接口实现类"><a href="#4-3-编写接口实现类" class="headerlink" title="4.3 编写接口实现类"></a>4.3 编写接口实现类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chen.servises;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chen.dao.BookMapper;</span><br><span class="line"><span class="keyword">import</span> com.chen.pojo.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookMapper</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBook</span><span class="params">(Book book)</span> </span>{</span><br><span class="line">        bookMapper.insertBook(book);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        bookMapper.deleteBookById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>{</span><br><span class="line">        bookMapper.updateBook(book);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryAllBook</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryAllBook();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-配置springMvc"><a href="#5-配置springMvc" class="headerlink" title="5 配置springMvc"></a>5 配置springMvc</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ssm整合流程&quot;&gt;&lt;a href=&quot;#ssm整合流程&quot; class=&quot;headerlink&quot; title=&quot;ssm整合流程&quot;&gt;&lt;/a&gt;ssm整合流程&lt;/h1&gt;&lt;h2 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="spring" scheme="https://rain-sky.github.io/tags/spring/"/>
    
    <category term="mybatis" scheme="https://rain-sky.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>问题集锦</title>
    <link href="https://rain-sky.github.io/2021/04/24/%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://rain-sky.github.io/2021/04/24/%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</id>
    <published>2021-04-24T00:48:41.000Z</published>
    <updated>2021-04-24T00:50:12.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字节跳动技术一面"><a href="#字节跳动技术一面" class="headerlink" title="字节跳动技术一面"></a><strong>字节跳动技术一面</strong></h2><ul><li>讲一下线程参数的含义</li><li>Innodb的索引实现</li><li>为什么是B+树？</li><li>Redis的使用，分布式锁的实现</li><li>操作系统虚拟内存换页的过程</li><li>TCP三次握手</li><li>volatile关键字的作用</li><li>乐观锁、悲观锁</li><li>之前用过哪些设计模式？</li><li>算法题：滑动窗口</li></ul><h2 id="字节跳动技术二面"><a href="#字节跳动技术二面" class="headerlink" title="字节跳动技术二面"></a><strong>字节跳动技术二面</strong></h2><ul><li>说一下B树和B+树的区别</li><li>说一下HashMap的实现，扩容机制，扩容时如何保证可操作？</li><li>Redis扩容机制（渐进式单线程扩容）</li><li>Spring IoC的原理，如何实现，如何解决循环依赖？</li><li>两线程对变量i进行加1操作，结果如何？为什么？怎么解决？</li><li>CAS概念、原子类实现原理</li><li>synchronize底层实现，如何实现Lock？</li><li>AQS有什么特点？</li><li>手写项目中某个模块代码。</li><li>介绍各种网络协议。</li><li>DNS在网络层用哪个协议，为什么。</li><li>介绍HTTPS协议，详述SSL建立连接过程。</li><li>代码题：反转单链表。</li><li>代码题：复杂链表复制。</li></ul><h2 id="字节跳动技术三面"><a href="#字节跳动技术三面" class="headerlink" title="字节跳动技术三面"></a><strong>字节跳动技术三面</strong></h2><ul><li>算法题多到爆炸，感觉是算法专场，宇宙条果真名不虚传</li><li>说一下Java垃圾回收机制</li><li>64匹马，8个赛道，找最快的4匹马</li><li>给出两个升序数组A、B和长度m、n，求第k个大的</li><li>给出数组A，长度为n，数组中元素的值位于[0, n - 1]之间，求是否有重复元素</li><li>讲一下多线程与多进程区别</li><li>JVM中什么时候会进行垃圾回收？什么样的对象是可以回收的？</li><li>Spring主要思想是什么？</li></ul><h2 id="字节跳动技术四面"><a href="#字节跳动技术四面" class="headerlink" title="字节跳动技术四面"></a><strong>字节跳动技术四面</strong></h2><ul><li>场景题目：设计一个短域名服务：短信存不了太长网站，需要弄成短域名，你该如何设计一个服务，可以为全国的网址服务。</li><li>TCP为什么是三次握手四次挥手？</li><li>数据库的隔离级别</li><li>sql题，写了个连表查询外加模糊查询</li><li>算法：镜像二叉树 ……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字节跳动技术一面&quot;&gt;&lt;a href=&quot;#字节跳动技术一面&quot; class=&quot;headerlink&quot; title=&quot;字节跳动技术一面&quot;&gt;&lt;/a&gt;&lt;strong&gt;字节跳动技术一面&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;讲一下线程参数的含义&lt;/li&gt;
&lt;li&gt;Inn</summary>
      
    
    
    
    
    <category term="面试" scheme="https://rain-sky.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>springMvc执行流程</title>
    <link href="https://rain-sky.github.io/2021/04/12/springMvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://rain-sky.github.io/2021/04/12/springMvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-04-12T02:21:46.000Z</published>
    <updated>2021-05-16T05:57:37.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springMvc执行流程"><a href="#springMvc执行流程" class="headerlink" title="springMvc执行流程"></a>springMvc执行流程</h1><h2 id="spring4-2-4原文档图"><a href="#spring4-2-4原文档图" class="headerlink" title="spring4.2.4原文档图"></a>spring4.2.4原文档图</h2><p><img src="https://gitee.com/rain-sky/images/raw/master/20210414220342.png"></p><p><code>前置控制器，springMvc核心</code></p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210419100723.png"></p><p>参照：</p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210419102208.png"></p><h2 id="springMvc执行流程-1"><a href="#springMvc执行流程-1" class="headerlink" title="springMvc执行流程"></a>springMvc执行流程</h2><h3 id="准备概要："><a href="#准备概要：" class="headerlink" title="准备概要："></a>准备概要：</h3><h4 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.chen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>SpringMVC-01-servlet<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>springMVC-02-hellomvc<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="配置web-xml，注册DispatcherServlet"><a href="#配置web-xml，注册DispatcherServlet" class="headerlink" title="配置web.xml，注册DispatcherServlet"></a>配置web.xml，注册DispatcherServlet</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>编写springMvc-servlet.xml，此处使用注解方式实现</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描指定包下的所有controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.chen.controller"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让springMvc不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理映射器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理适配器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加视图解析器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="编写自己的controller"><a href="#编写自己的controller" class="headerlink" title="编写自己的controller"></a>编写自己的controller</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServlertContorller</span></span>{</span><br><span class="line">    <span class="meta">@RequestMapping("/hello")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPageHello</span><span class="params">(Model model)</span></span>{</span><br><span class="line">        model.addAttribute(<span class="string">"msg"</span>,<span class="string">"hello world!"</span>);</span><br><span class="line">        <span class="comment">//返回需要拼接的视图名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h2><ol><li>用户发起请求，此处以localhost:8080\hello 为例</li><li>前端控制器DispatcherServlet拦截请求\hello**(配置所有\ 请求均被前端控制器拦截)**</li><li>DispatcherServlet调用处理映射器HandlerMapping，处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。<code>此处具体的处理器即为 &lt;bean id="/hello" class="com.chen.controller.ServlertContorller"/&gt;</code></li><li>DispatcherServlet调用处理适配器HandlerAdapter，请求执行对应handler(即此处自己编写的controller)</li><li>HandlerAdapter调用对应controller执行对应的处理，处理结果返回ModelAndView回传HandlerAdapter</li><li>HandlerAdapter将ModelAndView中继到前端控制器DispatcherServlet</li><li>DispatcherServlet将ModelAndView传送给ViewResolve</li><li>视图解析器对ModelAndView进行视图解析，拼接具体视图路径，解析返回具体视图Viewhui前端控制器</li><li>前端控制器调用具体视图(渲染装填model中的数据)</li><li>将视图返回给用户</li></ol><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><ul><li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li><li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li><li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li><li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li><li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li><li>View: 是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springMvc执行流程&quot;&gt;&lt;a href=&quot;#springMvc执行流程&quot; class=&quot;headerlink&quot; title=&quot;springMvc执行流程&quot;&gt;&lt;/a&gt;springMvc执行流程&lt;/h1&gt;&lt;h2 id=&quot;spring4-2-4原文档图&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="sprigMvc" scheme="https://rain-sky.github.io/tags/sprigMvc/"/>
    
  </entry>
  
  <entry>
    <title>springMvc项目打包后未打包依赖导致404问题</title>
    <link href="https://rain-sky.github.io/2021/04/11/springMvc%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E6%9C%AA%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4404%E9%97%AE%E9%A2%98/"/>
    <id>https://rain-sky.github.io/2021/04/11/springMvc%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E6%9C%AA%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4404%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-11T02:52:47.000Z</published>
    <updated>2021-05-08T01:41:42.642Z</updated>
    
    <content type="html"><![CDATA[<p>controller</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServlertContorller</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"the first springMvc program"</span>);</span><br><span class="line">        mv.setViewName(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>springmvc-servlet.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理映射器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加处理适配器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加视图解析器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 将自己编写的controller交由ioc容器管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello"</span> <span class="attr">class</span>=<span class="string">"com.chen.controller.ServlertContorller"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>目录结构</p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210414220343.png"></p><p>404错误原因，E:\javaweb\springMVC\out\artifacts\springMVC_02_hellomvc_war_exploded中没有打包相关依赖jar包</p><p>解决方案：</p><p>手动添加lib目录并导入相关依赖</p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210414220344.png"></p><p>添加完成，如图所示：</p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210414220345.png"></p><p>再次测试访问localhost:8080/hello 成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;controller&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
    <category term="springMvc" scheme="https://rain-sky.github.io/tags/springMvc/"/>
    
    <category term="maven" scheme="https://rain-sky.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>spring整合mybatis</title>
    <link href="https://rain-sky.github.io/2021/04/10/spring%E6%95%B4%E5%90%88mybatis/"/>
    <id>https://rain-sky.github.io/2021/04/10/spring%E6%95%B4%E5%90%88mybatis/</id>
    <published>2021-04-10T08:44:20.000Z</published>
    <updated>2021-04-10T12:04:30.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-整合mybatis"><a href="#spring-整合mybatis" class="headerlink" title="spring 整合mybatis"></a>spring 整合mybatis</h1><h2 id="回顾mybatis步骤"><a href="#回顾mybatis步骤" class="headerlink" title="回顾mybatis步骤"></a>回顾mybatis步骤</h2><ol><li>导入mybatis与mysqsl相关包</li><li>编写mybatis核心配置文件</li><li>编写业务接口</li><li>编写接口对应的***mapper.xml</li><li>在mybatise核心配置文件中注册mapper</li><li>获取核心配置文件的输入流,通过输入流build(**)获得sqlsessionFactory,通过sqlsessionFactory获得sqlsession</li><li>通过sqlsession.getMapper(***.class)动态代理获得业务接口实现类</li><li>调用业务对应方法</li></ol><h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><blockquote><p>步骤</p></blockquote><p>1、导入相关jar包</p><p>junit</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mybatis</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mysql-connector-java</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>spring相关</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>aspectJ AOP 织入器</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mybatis-spring整合包 【重点】</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>配置Maven静态资源过滤问题！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="spring核心配置"><a href="#spring核心配置" class="headerlink" title="spring核心配置"></a>spring核心配置</h2><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory </code>和至少一个<code>数据映射器类</code>。</p><p>在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>SqlSessionFactory需要一个 DataSource（数据源）</strong>。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><p>在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。</p><p>在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p><p>SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p><p>一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。</p><p>需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（<environments>），数据源（<datasource>）和 MyBatis 的事务管理器（<transactionmanager>）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。</transactionmanager></datasource></environments></p><p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。</p><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p><p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置详细"><a href="#配置详细" class="headerlink" title="配置详细"></a>配置详细</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line">       &lt;!-- 开启注解支持 --&gt;</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">   <span class="comment">&lt;!-- 开启面向切面aop支持 --&gt;</span></span><br><span class="line">       xmlns:aop="http://www.springframework.org/schema/aop"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</span><br><span class="line">    <span class="comment">&lt;!--开启注解支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置datasource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将sqlSessionFactory置入spring容器托管 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关联mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath: mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册该包下所有***Mapper.xml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/chen/dao/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建sqlSession  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><code>由于已经创建sqlSessionFactory与sqlSession 故在应用中可直接使用</code></p><p>mybatis-config.xml配置</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.chen.pojo"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>通常mybatis-config.xml会用于typeAliases与settings的配置</p><p>编写接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>{</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写UserMapper.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.chen.dao.UserDao"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>原mybatis获取代理类并执行业务</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">//获取mybatis核心配置文件输入流</span></span><br><span class="line">           InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">           <span class="comment">//建造者模式，解析配置文件获取sqlSessionFactory</span></span><br><span class="line">           sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">       } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//此处以上代码一般编写为一个工具类，用于获取sqlSession</span></span><br><span class="line"><span class="comment">//通过反射得到***Mapper.xml的代理类</span></span><br><span class="line">StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; allStudent = mapper.getAllStudent();</span><br><span class="line">   <span class="keyword">for</span> (Student student: allStudent) {</span><br><span class="line">        System.out.println(student);</span><br><span class="line">       }</span><br><span class="line">   sqlSession.close();</span><br></pre></td></tr></tbody></table></figure><p><strong>整合获取代理类执行业务</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectUser</span><span class="params">()</span></span>{</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       SqlSessionTemplate sqlSession = (SqlSessionTemplate) context.getBean(<span class="string">"sqlSession"</span>);</span><br><span class="line">       UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">       <span class="keyword">for</span> (User user : mapper.getAllUser()) {</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><strong>在spring中对象都交由IOC容器，为此，sqlSessionFactory与sqlSession均从IOC容器中获得，对比原mybatis步骤中，我们一般会在spring整合mybatis多增加一个实现类交由IOC容器管理</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">getSqlSession</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>{</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.getAllUser();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectUsers</span><span class="params">()</span></span>{</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        UserMapperImpl userMapper = (UserMapperImpl) context.getBean(<span class="string">"userMapperImpl"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//userMapper.setSqlSession(sqlSessionTemplate);</span></span><br><span class="line">        <span class="keyword">for</span> (User user : userMapper.getAllUser()) {</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring-整合mybatis&quot;&gt;&lt;a href=&quot;#spring-整合mybatis&quot; class=&quot;headerlink&quot; title=&quot;spring 整合mybatis&quot;&gt;&lt;/a&gt;spring 整合mybatis&lt;/h1&gt;&lt;h2 id=&quot;回顾mybatis</summary>
      
    
    
    
    
    <category term="spring" scheme="https://rain-sky.github.io/tags/spring/"/>
    
    <category term="mybatis" scheme="https://rain-sky.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>select 子句后的列取别名不能应用与where子句的问题</title>
    <link href="https://rain-sky.github.io/2021/04/04/select-%E5%AD%90%E5%8F%A5%E5%90%8E%E7%9A%84%E5%88%97%E5%8F%96%E5%88%AB%E5%90%8D%E4%B8%8D%E8%83%BD%E5%BA%94%E7%94%A8%E4%B8%8Ewhere%E5%AD%90%E5%8F%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://rain-sky.github.io/2021/04/04/select-%E5%AD%90%E5%8F%A5%E5%90%8E%E7%9A%84%E5%88%97%E5%8F%96%E5%88%AB%E5%90%8D%E4%B8%8D%E8%83%BD%E5%BA%94%E7%94%A8%E4%B8%8Ewhere%E5%AD%90%E5%8F%A5%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-04T05:54:34.000Z</published>
    <updated>2021-04-04T06:16:37.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select子句中列别名无法应用于where子句问题"><a href="#select子句中列别名无法应用于where子句问题" class="headerlink" title="select子句中列别名无法应用于where子句问题"></a>select子句中列别名无法应用于where子句问题</h2><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><ol><li><p>sailors</p><p> CREATE TABLE Sailors</p><pre><code>(Sid CHAR(10)PRIMARY KEY,sname CHAR(20),rating INT ,age INT);</code></pre></li><li><p>boats</p><p>CREATE TABLE Boats</p><pre><code>(bid CHAR(10)PRIMARY KEY,bname CHAR(20) NOT NULL,color CHAR(10));</code></pre></li><li><p>reserves</p><p>CREATE TABLE Reserves(Sid CHAR(10) ,</p><pre><code>bid CHAR(10), rdate DATE,PRIMARY KEY(Sid,bid,rdate),FOREIGN KEY(Sid)REFERENCES Sailors(Sid),FOREIGN KEY(bid)REFERENCES Boats(bid));</code></pre></li></ol><p>求解问题：</p><blockquote><p>统计水手表中人数最少的级别组及人数</p></blockquote><p>解法:</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rating ,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> ttp <span class="keyword">FROM</span> sailors </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating <span class="keyword">HAVING</span> ttp =(<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(ttps) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> rating,<span class="keyword">COUNT</span>(*) ttps <span class="keyword">FROM</span> sailors <span class="keyword">GROUP</span> <span class="keyword">BY</span> rating) <span class="keyword">AS</span> res);</span><br></pre></td></tr></tbody></table></figure><p>错误写法：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rating ,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> ttp <span class="keyword">FROM</span> sailors <span class="keyword">where</span> ttp = (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(ttps) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> rating,<span class="keyword">COUNT</span>(*) ttps <span class="keyword">FROM</span> sailors <span class="keyword">GROUP</span> <span class="keyword">BY</span> rating) <span class="keyword">AS</span> res)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating;</span><br></pre></td></tr></tbody></table></figure><p>解惑：</p><hr><p><code>执行顺序,先执行FROM 子句,然后执行WHERE 子句,最后执行SELECT 所以Select 子句后的别名,在where条件中不能使用。</code></p><p><strong>一、sql执行顺序</strong><br>(1) FROM:对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积，产生虚拟表VT1;<br>(2) ON: 对虚拟表VT1进行ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2;<br>(3) JOIN: 如果指定了OUTER JOIN(如LEFT OUTER JOIN、RIGHT OUTER JOIN)，那么保留表中未匹配的行作为外部行添加到虚拟表VT2，产生虚拟表VT3。如果FROM子句包含两个以上的表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1~步骤3，直到处理完所有的表;<br>(4) WHERE: 对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才会被插入虚拟表VT4;<br>(5) GROUP By: 根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5;如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。<br>(6) CUBE|ROllUP: 对VT5进行CUBE或ROLLUP操作，产生表VT6;<br>(7) HAVING: 对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才会被插入到VT7;<br>(8) SELECT: 第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中;<br>(9) DISTINCT: 去除重复，产生虚拟表VT9;<br>(10) ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10;<br>(11) LIMIT: 取出指定街行的记录，产生虚拟表VT11，并返回给查询用户</order_by_list></having_condition></where_condition></join_condition></right_table></left_table></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;select子句中列别名无法应用于where子句问题&quot;&gt;&lt;a href=&quot;#select子句中列别名无法应用于where子句问题&quot; class=&quot;headerlink&quot; title=&quot;select子句中列别名无法应用于where子句问题&quot;&gt;&lt;/a&gt;select子句</summary>
      
    
    
    
    
    <category term="sql" scheme="https://rain-sky.github.io/tags/sql/"/>
    
    <category term="数据库" scheme="https://rain-sky.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="https://rain-sky.github.io/2021/03/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://rain-sky.github.io/2021/03/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-03-20T07:25:53.000Z</published>
    <updated>2021-05-08T01:43:23.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>与编译时需要进行连接的语言不同，Java语言类的加载，连接和初始化，都是在程序运行期间进行的。</p><p><strong>类的生命周期</strong></p><p><img src="https://gitee.com/rain-sky/images/raw/master/20210427085136.webp"></p><blockquote><p>加载，验证，准备，初始化与卸载阶段顺序确定，类加载过程必须按照这种顺序按部就班开始，解析阶段则不一定，某些情况下它可以在初始化阶段之后开始，这是为了支持Java运行时绑定的特性(动态绑定或晚期绑定)。此处是值按部就班的“开始”，而不是按部就班的“进行”，强调这一点因为这些阶段通常都是交叉混合进行的。</p><p>​                                                                                                                                                            ——《深入理解Java虚拟机》</p></blockquote><h2 id="2-类加载时机"><a href="#2-类加载时机" class="headerlink" title="2.类加载时机"></a>2.类加载时机</h2><p>在《Java虚拟机规范》中有且只有六种情况必须立即对类进行初始化(之前阶段必然已在初始化阶段前开始)。</p><ol><li><p>遇到new、getstatic、putstatic和invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。<br>生成这4条指令的最常见Java场景：</p><p><em>使用new关键字实例化对象的时候；</em><br><em>读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候；</em><br><em>调用一个类的静态方法的时候。</em></p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当一个接口中定义了JDK 8 新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。如：<em>default void sort(Comparator&lt;? super E&gt; c) {      …      …    }</em></p></li></ol><hr><p>以上六种场景中的行为称为对一个类型进行主动引用，除此之外，所有引用类型的方式都不会触发初始化，成为被动引用。</p><p>举例说明何为被动引用：</p><ol><li>通过子类引用父类的静态字段，不会导致子类的初始化</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">static</span>{</span><br><span class="line">        System.out.println(<span class="string">"SuperClass is init!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>{</span><br><span class="line"><span class="keyword">static</span>{</span><br><span class="line">        System.out.println(<span class="string">"SubClass is init!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInit</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>通过数组定义来引用类，不触发此类初始化</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sp = <span class="keyword">new</span> SuperClass[<span class="number">100</span>];</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>常量会在编译阶段存入调用类的常量池中，本质上没有直接引用到定义常类的类，因此不会触发定义常量的类的初始化</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">static</span>{</span><br><span class="line">        System.out.println(<span class="string">"SuperClass is init!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInit</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        <span class="comment">//常量调用</span></span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PS：接口加载与类加载过程稍有不同，触发类加载的第三种情况对于接口而言，当一个接口在初始化时，并不要求父接口全部完成初始化，只有在引用到了父类的时候才触发符类的初始化，如使用到了父接口中的常量。</p><h2 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3.类加载的过程"></a>3.类加载的过程</h2><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>加载阶段虚拟机主要完成一下三件事</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流（所以说，先编译得到Class文件才有类加载对吧）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的Java.lang.Class对象,作为方法区这个类的各种数据访问入口</li></ol><p><code>通过一个类的全限定名来获取定义此类的二进制字节流并未指明从哪获取，如何获取。</code></p><p>​        类加载阶段结束后，Java虚拟机外部的数据二进制字节流就按照虚拟机所定义的格式存储的方法区之中了,存储格式完全由虚拟机自定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个Java.lang.Class对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p><p>​        加载阶段与连接极端的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，即加载阶段未结束，连接已开始，但二者开始先后顺序依然严格按照定义进行。</p><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>验证是连接阶段的第一步，从代码量何耗费的执行性能的角度上讲，验证阶段的工作量在Java虚拟机的类加载过程中占据相当大的比重。</p><p>验证阶段大致完成以下四个阶段的检验动作</p><ol><li>文件格式验证<ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在虚拟机接受范围内</li><li>……</li></ul></li><li>元数据验证<ul><li>这个类是否有父类</li><li>这个类的父类是否继承了不被允许继承的类（final修饰）</li><li>……</li></ul></li><li>字节码验证(最复杂的一个阶段，通过数据流分析何控制流分析，确定程序语义合法，符合逻辑)<ul><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证方法体钟的类型转换总是有效的（保证转型安全）</li><li>……</li></ul></li><li>符号引用验证（发生在虚拟机将符号引用转化为直接用于的时候，该动作将在连接第三阶段——解析阶段发生，该验证主要为了保证解析行为能正常进行）<ul><li>符号引用中通过字符穿描述的全限定名是否能找到对应类</li><li>符号引用中的类，字段，方法的可访问性，是否可被当前类访问</li><li>……</li></ul></li></ol><hr><p><code>验证阶段对于虚拟机类加载机制来说，是一个非常重要却不是必须执行的阶段，如程序运行的代码都已经被反复使用何验证过，就可以考虑使用-Xverify:none参数关闭大部分类验证措施。</code></p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p>准备阶段是正式为类中定义的变量（静态变量）分配内存设置初始值阶段， <strong>注意，不包括实例变量</strong> ，从概念上将这些变量所使用的内存都应在方法区中进行分配，但方法区本身就是一个逻辑上的区域，在JDK 7之前，HotSpot使用永久代来实现方法区，而在JDK 8 之后，类变量则会随着Class对象一起存放在Java堆中，此时“类变量在方法区”就是一种逻辑表述了。</p><p>其次，此处表述的初始值“通常情况”下是数据类型的零值，如一个变量定义为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></tbody></table></figure><p>那么 value在准备阶段结束后初始值不为123，而是int 型的零值0。因为此时还未执行任何Java方法，而vlaue = 123的赋值动作将在执行类构造器<clinit>()完成。</clinit></p><p>非“通常情况”</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></tbody></table></figure><p>编译时，Javac会为value生成ConstantValue属性，准备阶段value直接被初始化为ConstantValue所指定的初始值。</p><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>解析阶段是Java虚拟机将符号引用替换为直接引用的过程。</p><p>符号引用：</p><p>符号引用是一个字符串，它给出了被引用的内容的名字并且可能会包含一些其他关于这个被引用项的信息——这些信息必须足以唯一的识别一个类、字段、方法。这样，对于其他类的符号引用必须给出类的全名。对于其他类的字段，必须给出类名、字段名以及字段描述符。对于其他类的方法的引用必须给出类名、方法名以及方法的描述符。在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</p><p>2.直接引用：</p><p>直接引用可以是<br> （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br> （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br> （3）一个能间接定位到目标的句柄<br> 直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><hr><p>关于符号引用与直接引用的更详细解析，可参考知乎大佬文章<a href="https://www.zhihu.com/question/30300585">https://www.zhihu.com/question/30300585</a></p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>初始化阶段就是执行类构造器<clinit>（）方法的过程，它是Javac编译后生成的产物，它是由编译器自动收集类中所有类变量的赋值动作和静态语句块合并产生的，收集顺序是源代码中语句出现的先后顺序。所以静态语句块中只能访问的定义在此之前的变量，在它之后的变量可以赋值，但不能访问。</clinit></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="keyword">static</span>{</span><br><span class="line">        i = <span class="number">0</span>;<span class="comment">//编译通过</span></span><br><span class="line">        System.out.println(i);<span class="comment">//非法向前引用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>java虚拟机必须保证一个类的&lt;clinit&gt;（）方法在多线程环境中被正确加锁同步,若活动线程在一个类的&lt;clinit&gt;（）方法耗时过长，或造成多个线程阻塞。</code></p><p>rundll32.exe keymgr.dll,KRShowKeyMgr</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;与编译时需要进行连接的语言不同，Java语言类的加载，连接和初始化，都是在程序运行期间进行的。&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    
    <category term="Java" scheme="https://rain-sky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="https://rain-sky.github.io/2021/03/20/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://rain-sky.github.io/2021/03/20/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-03-20T02:38:14.000Z</published>
    <updated>2021-03-20T02:38:14.547Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="https://rain-sky.github.io/2021/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://rain-sky.github.io/2021/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-17T01:48:45.000Z</published>
    <updated>2021-04-05T01:38:08.424Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，线程通常有五种状态：创建，就绪，运行，阻塞和死亡。</p><p>创建状态：在生成线程对象，并没有调用该对象的star方法，这时线程处于创建状态。</p><p>就绪状态：当调用了线程对象的start方法之后，该线程就进入就绪状态。但是此时线程调度程序还没有把该线程设置</p><pre><code>            为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</code></pre><p>运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数中的代码。</p><p>阻塞状态：线程正在运行的时候，被暂停 ，通常是为了等待某个事件的发生之后再运行。sleep，suspend，wait等方法</p><pre><code>             都可以导致线程阻塞。</code></pre><p>死亡状态：如果一个线程的run方法执行结束或者被调用stop方法后，该线程就会死亡。对于死亡的线程，无法再使用start方法</p><pre><code>           令其进入就绪。</code></pre><p>实现线程的方法</p><pre><code>Java中实现并启动线程有两种方法：1.写一个类继承Thread类，重写run方法，用start方法启动线程。2.写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动。</code></pre><p>start()方法   </p><pre><code>用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</code></pre><p>run()方法</p><pre><code>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。Thread的子类要重写这个方法，通过Thread调用run()方法，执行线程的线程体。</code></pre><p>调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Java中，线程通常有五种状态：创建，就绪，运行，阻塞和死亡。&lt;/p&gt;
&lt;p&gt;创建状态：在生成线程对象，并没有调用该对象的star方法，这时线程处于创建状态。&lt;/p&gt;
&lt;p&gt;就绪状态：当调用了线程对象的start方法之后，该线程就进入就绪状态。但是此时线程调度程序还没有把</summary>
      
    
    
    
    
    <category term="Java" scheme="https://rain-sky.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://rain-sky.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>值传递与引用传递</title>
    <link href="https://rain-sky.github.io/2021/01/31/%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://rain-sky.github.io/2021/01/31/%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2021-01-31T03:12:08.000Z</published>
    <updated>2021-03-07T11:58:50.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h1><h2 id="一：什么是基本数据类型，什么是引用数据类型。"><a href="#一：什么是基本数据类型，什么是引用数据类型。" class="headerlink" title="一：什么是基本数据类型，什么是引用数据类型。"></a>一：什么是基本数据类型，什么是引用数据类型。</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic3.zhimg.com/80/166032bc90958c21604110441ad03f45_720w.jpg?source=1940ef5c"></p><p>如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p><h2 id="二：搞清楚赋值运算符（-）的作用"><a href="#二：搞清楚赋值运算符（-）的作用" class="headerlink" title="二：搞清楚赋值运算符（=）的作用"></a>二：搞清楚赋值运算符（=）的作用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_720w.jpg?source=1940ef5c"></p><p>对于基本数据类型，内存中的内容直接覆盖。</p><p>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong><br>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p><p>eg:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StringBuilder;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putStr</span><span class="params">(StringBuilder stringBuilder,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">        System.out.println(<span class="string">"a = "</span>+a+<span class="string">"  "</span>+<span class="string">"b = "</span>+b );<span class="comment">//a依然不变</span></span><br><span class="line"></span><br><span class="line">        System.out.println(stringBuilder.hashCode());</span><br><span class="line">        stringBuilder.append(<span class="string">" world!"</span>);<span class="comment">//sb指向内容改变</span></span><br><span class="line">        System.out.println(stringBuilder.hashCode());</span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"see you~"</span>);<span class="comment">//sb指向内容不变</span></span><br><span class="line">        System.out.println(stringBuilder.hashCode());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        StringBuilder sb =  <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(sb.hashCode());</span><br><span class="line">        putStr(sb,a);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">_________________________________________________________________________________________________________</span><br><span class="line"><span class="number">460141958</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a = <span class="number">1</span>  b = <span class="number">4</span></span><br><span class="line"><span class="number">460141958</span></span><br><span class="line"><span class="number">460141958</span></span><br><span class="line"><span class="number">1163157884</span></span><br></pre></td></tr></tbody></table></figure><h2 id="C-中的一些相似问题"><a href="#C-中的一些相似问题" class="headerlink" title="C++中的一些相似问题"></a>C++中的一些相似问题</h2><p>举例如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">n = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span>{</span><br><span class="line">n =<span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>上示两个函数，掉用前者并不导致实参改变，掉用后者导致实参改变。</p><p>在 C++中  i<strong>nt a = 5; int &amp;b = a;</strong> 该种写法称b 为 a的别名，b与a指向同一片内存；</p><p>PS：</p><ol><li>引用在定义时必须初始话，如 int &amp;b;错误。</li><li>引用初始化只能榜顶佐治，不能榜顶常量值，如int &amp;b = 10; 错误。</li><li>引用一旦初始化其值便不能修改，即不能做其他变量的引用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;值传递与引用传递&quot;&gt;&lt;a href=&quot;#值传递与引用传递&quot; class=&quot;headerlink&quot; title=&quot;值传递与引用传递&quot;&gt;&lt;/a&gt;值传递与引用传递&lt;/h1&gt;&lt;h2 id=&quot;一：什么是基本数据类型，什么是引用数据类型。&quot;&gt;&lt;a href=&quot;#一：什么是基本</summary>
      
    
    
    
    
    <category term="Java" scheme="https://rain-sky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://rain-sky.github.io/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://rain-sky.github.io/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-01-12T09:41:37.000Z</published>
    <updated>2021-03-20T07:26:53.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-网络层次划分"><a href="#1-网络层次划分" class="headerlink" title="1. 网络层次划分"></a>1. 网络层次划分</h3><p>　　为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。 其中第四层完成数据传送服务，上面三层面向用户。</p><p>　　除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="https://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg" alt="img"></p><h3 id="2-OSI七层网络模型"><a href="#2-OSI七层网络模型" class="headerlink" title="2. OSI七层网络模型"></a>2. OSI七层网络模型</h3><p>　　TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</p><p><img src="https://images2015.cnblogs.com/blog/764050/201509/764050-20150904095142060-1017190812.gif" alt="img"></p><p>　　1）物理层（Physical Layer）</p><p>　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p><p>　　2）数据链路层（Data Link Layer）</p><p>　　数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>　　有关数据链路层的重要知识点：</p><p>　　1&gt; 数据链路层为网络层提供可靠的数据传输；</p><p>　　2&gt; 基本数据单位为帧；</p><p>　　3&gt; 主要的协议：以太网协议；</p><p>　　4&gt; 两个重要设备名称：网桥和交换机。</p><p>　　3）网络层（Network Layer）</p><p>　　网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p><p>　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p><p>　　1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</p><p>　　2&gt; 基本数据单位为IP数据报；</p><p>　　3&gt; 包含的主要协议：</p><p>　　IP协议（Internet Protocol，因特网互联协议）;</p><p>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</p><p>　　ARP协议（Address Resolution Protocol，地址解析协议）;</p><p>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</p><p>　　4&gt; 重要的设备：路由器。</p><p>　　4）传输层（Transport Layer）</p><p>　　第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p><p>　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p><p>　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p><p>　　有关网络层的重点：</p><p>　　1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</p><p>　　2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</p><p>　　3&gt; 重要设备：网关。</p><p>　　5）会话层</p><p>　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><p>　　6）表示层</p><p>　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><p>　　7）应用层</p><p>　　为操作系统或网络应用程序提供访问网络服务的接口。</p><p>　　会话层、表示层和应用层重点：</p><p>　　1&gt; 数据传输基本单位为报文；</p><p>　　2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3. IP地址"></a>3. IP地址</h3><p>　　1）网络地址</p><p>　　IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p>　　2）广播地址</p><p>　　广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>　　广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p>　　3）组播地址</p><p>　　D类地址就是组播地址。</p><p>　　先回忆下A，B，C，D类地址吧：</p><p>　　A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)</p><p>　　B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>　　C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>　　D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>　　E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>　　注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p>　　4）255.255.255.255</p><p>　　该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>　　注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p>　　5）0.0.0.0</p><p>　　常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>　　6）回环地址</p><p>　　127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p>　　7）A、B、C类私有地址</p><p>　　私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>　　A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>　　B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>　　C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h3 id="4-子网掩码及网络划分"><a href="#4-子网掩码及网络划分" class="headerlink" title="4. 子网掩码及网络划分"></a>4. 子网掩码及网络划分</h3><p>　　随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>　　这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>　　什么是子网掩码？</p><p>　　子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p><p>　　在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</p><p>　　子网掩码的计算：</p><p>　　对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p><p>　　下面总结一下有关子网掩码和网络划分常见的面试考题：</p><p>　　1）利用子网数来计算</p><p>　　在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><p>　　(1) 将子网数目转化为二进制来表示;</p><p>　　如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><p>　　(2) 取得该二进制的位数，为N；</p><p>　　该二进制为五位数，N = 5</p><p>　　(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p><p>　　将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><p>　　2）利用主机数来计算</p><p>　　如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>　　(1) 将主机数目转化为二进制来表示；</p><p>　　700=1010111100；</p><p>　　(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</p><p>　　该二进制为十位数，N=10；</p><p>　　(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>　　将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><p>　　3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。</p><p>　　比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><p>　　10＋1＋1＋1＝13</p><p>　　注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。</p><p>　　因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p><p>　　如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h3 id="5-ARP-RARP协议"><a href="#5-ARP-RARP协议" class="headerlink" title="5. ARP/RARP协议"></a>5. ARP/RARP协议</h3><p>　　地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p>　　ARP工作流程举例：</p><p>　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>　　当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><p>　　（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p><p>　　（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p><p>　　（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>　　（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p><p>　　（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><p>　　逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>　　RARP协议工作流程：</p><p>　　（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p><p>　　（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p><p>　　（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p><p>　　（4）如果不存在，RARP服务器对此不做任何的响应；</p><p>　　（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p><h3 id="6-路由选择协议"><a href="#6-路由选择协议" class="headerlink" title="6. 路由选择协议"></a>6. 路由选择协议</h3><p>　　常见的路由选择协议有：RIP协议、OSPF协议。</p><p>　　RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p>　　OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="7-TCP-IP协议"><a href="#7-TCP-IP协议" class="headerlink" title="7. TCP/IP协议"></a>7. TCP/IP协议</h3><p>　　TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</p><p>　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p> 　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p>　　TCP报文首部格式：</p><p><img src="https://images2015.cnblogs.com/blog/764050/201509/764050-20150904110054856-961661137.png" alt="img"></p><p>　　TCP协议的三次握手和四次挥手：</p><p><img src="https://images2015.cnblogs.com/blog/764050/201509/764050-20150904110008388-1768388886.gif" alt="img"></p><p>　　注：seq:”sequance”序列号；ack:”acknowledge”确认号；SYN:”synchronize”请求同步标志；；ACK:”acknowledge”确认标志”；FIN：”Finally”结束标志。</p><p>　　TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><p>　　TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>　　为什么要三次挥手？</p><p>　　在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！</p><p>　　为什么要四次挥手？</p><p>　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>　　使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="8-UDP协议"><a href="#8-UDP协议" class="headerlink" title="8. UDP协议"></a>8. UDP协议</h3><p>　　UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>　　 UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>　　每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：<br>　　（1）源端口号；</p><p>　　（2）目标端口号；</p><p>　　（3）数据报长度；</p><p>　　（4）校验值。</p><p>　　使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议） 、 NFS、 BOOTP。</p><p>　　 TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h3 id="9-DNS协议"><a href="#9-DNS协议" class="headerlink" title="9. DNS协议"></a>9. DNS协议</h3><p>　　DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p><h3 id="10-NAT协议"><a href="#10-NAT协议" class="headerlink" title="10. NAT协议"></a>10. NAT协议</h3><p>　　NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h3 id="11-DHCP协议"><a href="#11-DHCP协议" class="headerlink" title="11. DHCP协议"></a>11. DHCP协议</h3><p>　　DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="12-HTTP协议"><a href="#12-HTTP协议" class="headerlink" title="12. HTTP协议"></a>12. HTTP协议</h3><p>　　超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><p>　　HTTP 协议包括哪些请求？</p><p>　　GET：请求读取由URL所标志的信息。</p><p>　　POST：给服务器添加信息（如注释）。</p><p>　　PUT：在给定的URL下存储一个文档。</p><p>　　DELETE：删除给定的URL所标志的资源。</p><p>　　HTTP 中， POST 与 GET 的区别</p><p>　　1）Get是从服务器上获取数据，Post是向服务器传送数据。</p><p>　　2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p><p>　　3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p><p>　　4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>　　I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>　　II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-网络层次划分&quot;&gt;&lt;a href=&quot;#1-网络层次划分&quot; class=&quot;headerlink&quot; title=&quot;1. 网络层次划分&quot;&gt;&lt;/a&gt;1. 网络层次划分&lt;/h3&gt;&lt;p&gt;　　为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://rain-sky.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计网" scheme="https://rain-sky.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://rain-sky.github.io/2021/01/12/%E7%AE%97%E6%B3%95/"/>
    <id>https://rain-sky.github.io/2021/01/12/%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-12T09:40:09.000Z</published>
    <updated>2021-01-22T13:09:47.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>广度优先搜索算法（Breadth-First Search，BFS）是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。</p><p>广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以：</p><ol><li>编写国际跳棋AI，计算最少走多少步就可获胜；</li><li>编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；</li><li>根据你的人际关系网络找到关系最近的医生。</li></ol><h1 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h1><p>假设你居住在旧金山，要从双子峰前往金门大桥。你想乘公交车前往，并希望换乘最少。可乘坐的公交车如下。</p><p><img src="https://img-blog.csdnimg.cn/2019042512582052.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>为找出换乘最少的乘车路线，你将使用什么样的算法？<br>一步就能到达金门大桥吗？下面突出了所有一步就能到达的地方。</p><p><img src="https://img-blog.csdnimg.cn/20190425125909925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>金门大桥未突出，因此一步无法到达那里。两步能吗？</p><p><img src="https://img-blog.csdnimg.cn/20190425125941127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>金门大桥也未突出，因此两步也到不了。三步呢？</p><p><img src="https://img-blog.csdnimg.cn/20190425130010971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>金门大桥突出了！因此从双子峰出发，可沿下面的路线三步到达金门大桥。</p><p><img src="https://img-blog.csdnimg.cn/20190425130033978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p> 还有其他前往金门大桥的路线，但它们更远（需要四步）。这个算法发现，前往金门大桥的最短路径需要三步。这种问题被称为最短路径问题（shorterst-path problem）。你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为广度优先搜索。要确定如何从双子峰前往金门大桥，需要两个步骤。<br>(1) 使用图来建立问题模型。<br>(2) 使用广度优先搜索解决问题。<br>下面介绍什么是图，然后再详细探讨广度优先搜索。</p><h1 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h1><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通过表示为G(V,E)，其中，G标示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>无边图：若顶点Vi到Vj之间的边没有方向，则称这条边为无项边（Edge），用序偶对(Vi,Vj)标示。</p><p>对于下图无向图G1来说，G1=(V1, {E1})，其中顶点集合V1={A,B,C,D}；边集合E1={(A,B),(B,C),(C,D),(D,A),(A,C)}:</p><p><img src="https://img-blog.csdnimg.cn/20190425130245486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>有向图：若从顶点Vi到Vj的边是有方向的，则成这条边为有向边，也称为弧（Arc）。用有序对（Vi，Vj）标示，Vi称为弧尾，Vj称为弧头。如果任意两条边之间都是有向的，则称该图为有向图。</p><p>有向图G2中，G2=（V2,{E2}），顶点集合（A,B,C,D）,弧集合E2={&lt;A,D&gt;,{B,A},&lt;C,A&gt;,&lt;B,C&gt;}.</p><p>权：有些图的边和弧有相关的数，这个数叫做权。这些带权的图通常称为网。</p><h1 id="四、广度优先搜索算法"><a href="#四、广度优先搜索算法" class="headerlink" title="四、广度优先搜索算法"></a>四、广度优先搜索算法</h1><p>假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与芒果销售商有联系吗？为此，你可在朋友中查找。</p><p><img src="https://img-blog.csdnimg.cn/20190425130541285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>这种查找很简单。首先，创建一个朋友名单。</p><p><img src="https://img-blog.csdnimg.cn/20190425130557936.png" alt="img"></p><p> 然后，依次检查名单中的每个人，看看他是否是芒果销售商。</p><p><img src="https://img-blog.csdnimg.cn/20190425130627134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p> 假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。</p><p><img src="https://img-blog.csdnimg.cn/20190425130708732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p> 检查名单中的每个人时，你都将其朋友加入名单。</p><p><img src="https://img-blog.csdnimg.cn/20190425130746766.png" alt="img"></p><p> 这样一来，你不仅在朋友中查找，还在朋友的朋友中查找。别忘了，你的目标是在你的人际关系网中找到一位芒果销售商。因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。</p><h1 id="五、查找最短路径"><a href="#五、查找最短路径" class="headerlink" title="五、查找最短路径"></a>五、查找最短路径</h1><p>再说一次，广度优先搜索可回答两类问题。<br>第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）<br>第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）<br>刚才你看到了如何回答第一类问题，下面来尝试回答第二类问题——谁是关系最近的芒果销售商。例如，朋友是一度关系，朋友的朋友是二度关系。</p><p><img src="https://img-blog.csdnimg.cn/20190425130919177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p> 在你看来，一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。顺便问一句：将先检查Claire还是Anuj呢？Claire是一度关系，而Anuj是二度关系，因<br>此将先检查Claire，后检查Anuj。</p><p>你也可以这样看，一度关系在二度关系之前加入查找名单。</p><p>你按顺序依次检查名单中的每个人，看看他是否是芒果销售商。这将先在一度关系中查找，再在二度关系中查找，因此找到的是关系最近的芒果销售商。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。</p><p><img src="https://img-blog.csdnimg.cn/20190425131016430.png" alt="img"></p><p> 注意，只有按添加顺序查找时，才能实现这样的目的。换句话说，如果Claire先于Anuj加入名单，就需要先检查Claire，再检查Anuj。如果Claire和Anuj都是芒果销售商，而你先检查Anuj再检查Claire，结果将如何呢？找到的芒果销售商并非是与你关系最近的，因为Anuj是你朋友的朋友，而Claire是你的朋友。因此，你需要按添加顺序进行检查。有一个可实现这种目的的数据<br>结构，那就是队列（queue）。</p><h1 id="六、队列"><a href="#六、队列" class="headerlink" title="六、队列"></a>六、队列</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p><p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置，如图所示</p><p><a href="https://baike.baidu.com/pic/%E9%98%9F%E5%88%97/14580481/0/cdbf6c81800a19d8116a4d8030fa828ba71e46ce?fr=lemma&amp;ct=single"><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2044fd5c3a01213fcb3349de64e636f8/cdbf6c81800a19d8116a4d8030fa828ba71e46ce.jpg" alt="img"></a></p><p>每次在队尾插入一个元素是，rear增1；每次在队头删除一个元素时，front增1。随着插入和删除操作的进行，队列元素的个数不断变化，队列所占的存储空间也在为队列结构所分配的连续空间中移动。当front=rear时，队列中没有任何元素，称为空队列。当rear增加到指向分配的连续空间之外时，队列无法再插入新元素，但这时往往还有大量可用空间未被占用，这些空间是已经出队的队列元素曾经占用过得存储单元。</p><p>顺序队列中的溢出现象：</p><p>（1） “下溢”现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。</p><p>（2）”真上溢”现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。</p><p>（3）”假上溢”现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为”假上溢”现象。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：无论插入或删除，一旦rear指针增1或front指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置。自己真从MaxSize-1增1变到0，可用取余运算rear%MaxSize和front%MaxSize来实现。这实际上是把队列空间想象成一个环形空间，环形空间中的存储单元循环使用，用这种方法管理的队列也就称为循环队列。除了一些简单应用之外，真正实用的队列是循环队列。 [2] </p><p>在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件时front=rear，而队列判满的条件时front=（rear+1）%MaxSize。队空和队满的情况如图：</p><p><img src="https://img-blog.csdnimg.cn/20190425131408367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="七、广度优先搜索算法实现"><a href="#七、广度优先搜索算法实现" class="headerlink" title="七、广度优先搜索算法实现"></a>七、广度优先搜索算法实现</h1><p>我们要从“你”出发找到“ANUJ”，关系表示为下图，使用广度优先搜索算法</p><p><img src="https://img-blog.csdnimg.cn/20190425131729132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p> 先概述一下这种算法的工作原理。</p><p><img src="https://img-blog.csdnimg.cn/20190425131859171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDgyMjAy,size_16,color_FFFFFF,t_70" alt="img"></p><p>但这样可能会出现一些问题，Peggy既是Alice的朋友又是Bob的朋友，因此她将被加入队列两次：一次是在添加Alice的朋友时，另一次是在添加Bob的朋友时。因此，搜索队列将包含两个Peggy。</p><p><img src="https://img-blog.csdnimg.cn/20190425132141757.png" alt="img"></p><p>但你只需检查Peggy一次，看她是不是芒果销售商。如果你检查两次，就做了无用功。因此，检查完一个人后，应将其标记为已检查，且不再检查他。<br>如果不这样做，就可能会导致无限循环。假设你的人际关系网类似于下面这样。</p><p><img src="https://img-blog.csdnimg.cn/20190425132220829.png" alt="img"></p><p>一开始，搜索队列包含你的所有邻居。</p><p><img src="https://img-blog.csdnimg.cn/2019042513224723.png" alt="img"></p><p>现在你检查Peggy。她不是芒果销售商，因此你将其所有邻居都加入搜索队列。</p><p><img src="https://img-blog.csdnimg.cn/20190425132306499.png" alt="img"></p><p>接下来，你检查自己。你不是芒果销售商，因此你将你的所有邻居都加入搜索队列。</p><p><img src="https://img-blog.csdnimg.cn/20190425132328874.png" alt="img"></p><p>以此类推。这将形成无限循环，因为搜索队列将在包含你和包含Peggy之间反复切换。</p><p><img src="https://img-blog.csdnimg.cn/2019042513235043.png" alt="img"></p><p>检查一个人之前，要确认之前没检查过他，这很重要。为此，你可使用一个列表来记录检查过的人。</p><p>首先，需要使用代码来实现图。图由多个节点组成。<br>每个节点都与邻近节点相连，如果表示类似于“你→Bob”这样的关系呢？好在你知道的一种结构让你能够表示这种关系，它就是散列表！<br>记住，散列表让你能够将键映射到值。在这里，你要将节点映射到其所有邻居。</p><p>图不过是一系列的节点和边，因此在JAVA中，你可以使用HashMap来表示一个图。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        HashMap&lt;String,String[]&gt; hashMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"YOU"</span>,<span class="keyword">new</span> String[]{<span class="string">"CLAIRE"</span>,<span class="string">"ALICE"</span>,<span class="string">"BOB"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"CLAIRE"</span>,<span class="keyword">new</span> String[]{<span class="string">"YOU"</span>,<span class="string">"JONNY"</span>,<span class="string">"THON"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"JONNY"</span>,<span class="keyword">new</span> String[]{<span class="string">"CLAIRE"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"THOH"</span>,<span class="keyword">new</span> String[]{<span class="string">"CLAIRE"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"ALICE"</span>,<span class="keyword">new</span> String[]{<span class="string">"YOU"</span>,<span class="string">"PEGGY"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"BOB"</span>,<span class="keyword">new</span> String[]{<span class="string">"YOU"</span>,<span class="string">"PEGGY"</span>,<span class="string">"ANUJ"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"PEGGY"</span>,<span class="keyword">new</span> String[]{<span class="string">"BOB"</span>,<span class="string">"ALICE"</span>});</span><br><span class="line">        hashMap.put(<span class="string">"ANUJ"</span>,<span class="keyword">new</span> String[]{<span class="string">"BOB"</span>});</span><br><span class="line">        Node target = findTarget(<span class="string">"YOU"</span>,<span class="string">"ANUJ"</span>,hashMap);</span><br><span class="line">        <span class="comment">//打印出最短路径的各个节点信息</span></span><br><span class="line">        printSearPath(target);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印出到达节点target所经过的各个节点信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSearPath</span><span class="params">(Node target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.print(<span class="string">"找到了目标节点:"</span> + target.id + <span class="string">"\n"</span>);</span><br><span class="line">            List&lt;Node&gt; searchPath = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">            searchPath.add(target);</span><br><span class="line">            Node node = target.parent;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>) {</span><br><span class="line">                searchPath.add(node);</span><br><span class="line">                node = node.parent;</span><br><span class="line">            }</span><br><span class="line">            String path = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=searchPath.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) {</span><br><span class="line">                path += searchPath.get(i).id;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>) {</span><br><span class="line">                    path += <span class="string">"--&gt;"</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.print(<span class="string">"步数最短："</span>+path);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.print(<span class="string">"未找到了目标节点"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">findTarget</span><span class="params">(String startId,String targetId,HashMap&lt;String,String[]&gt; map)</span> </span>{</span><br><span class="line">        List&lt;String&gt; hasSearchList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        LinkedBlockingQueue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(startId,<span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) {</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(hasSearchList.contains(node.id)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.print(<span class="string">"判断节点:"</span> + node.id +<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> (targetId.equals(node.id)) {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            hasSearchList.add(node.id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.get(node.id) != <span class="keyword">null</span> &amp;&amp; map.get(node.id).length &gt; <span class="number">0</span>) {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String childId : map.get(node.id)) {</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Node(childId,node));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> String id;</span><br><span class="line">        <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String id,Node parent)</span> </span>{</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;广度优先搜索&quot;&gt;&lt;a href=&quot;#广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;广度优先搜索&quot;&gt;&lt;/a&gt;广</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://rain-sky.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://rain-sky.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库原理</title>
    <link href="https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    <id>https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-12T09:39:46.000Z</published>
    <updated>2021-01-22T13:09:25.758Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库概念</strong></p><p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p><ol><li>数据库系统的特点</li></ol><ul><li>数据结构化</li><li>数据的共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由DBMS统一管理和控制</li></ul><ol><li>两大类数据模型</li></ol><ul><li>概念模型也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</li><li>逻辑模型和物理模型，逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul><ol><li>关系数据库</li></ol><ul><li>关系数据库系统采用关系模型作为数据的组织方式，在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。</li></ul><ol><li>数据库系统的三级模式结构</li></ol><ul><li>模式（Schema）</li><li>外模式（External Schema）</li><li>内模式（Internal Schema）</li></ul><ol><li>关系模式</li></ol><ul><li><p>关系模式可以形式化地表示为：</p><p><strong>R（U，D，DOM，F）</strong></p><p><strong>R 关系名</strong></p><p><strong>U 组成该关系的属性名集合</strong></p><p><strong>D 属性组U中属性所来自的域</strong></p><p><strong>DOM 属性向域的映象集合</strong></p><p><strong>F 属性间的数据依赖关系集合</strong></p></li></ul><ol><li>实体完整性规则（Entity Integrity）</li></ol><ul><li>若属性A是基本关系R的主属性，则属性A不能取空值;关系模型中以主码作为唯一性标识。</li></ul><ol><li>参照完整性规则</li></ol><ul><li>若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：<ul><li>或者取空值（F的每个属性值均为空值）</li><li>或者等于S中某个元组的主码值</li></ul></li></ul><ol><li>关系代数运算符</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230252369.png" alt="img"><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302525419.png" alt="img"></p><p><strong>关系数据库标准语言SQL</strong></p><p>SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言。集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。可以独立完成数据库生命周期中的全部活动：</p><ul><li>定义关系模式，插入数据，建立数据库；</li><li>对数据库中的数据进行查询和更新；</li><li>数据库重构和维护</li><li>数据库安全性、完整性控制等</li></ul><ol><li>能完成核心功能9个动词</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302534580.png" alt="img"></p><ol><li>SQL的基本概念</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230253185.png" alt="img"></p><ol><li>数据定义</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302531614.png" alt="img"></p><ul><li><p>定义模式</p><ul><li><p>定义模式实际上定义了一个命名空间</p></li><li><p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p></li><li><p>在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。</p><p><strong>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</strong></p></li></ul></li><li><p>删除模式</p><p>**DROP SCHEMA &lt;模式名&gt; **</p><ul><li>CASCADE(级联)</li></ul><p>删除模式的同时把该模式中所有的数据库对象全部删除</p><ul><li>RESTRICT(限制)</li></ul><p>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。当该模式中没有任何下属的对象时 才能执行。</p></li><li><p>定义基本表</p><p><strong>CREATE TABLE &lt;表名&gt;</strong></p><p><strong>（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</strong></p><p><strong>[，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …</strong></p><p><strong>[，&lt;表级完整性约束条件&gt; ] ）；</strong></p><p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p></li><li><p>数据类型</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302541124.png" alt="img"></p></li><li><p>模式与表</p><ul><li><p>每一个基本表都属于某一个模式</p></li><li><p>一个模式包含多个基本表</p></li><li><p>定义基本表所属模式</p></li><li><p>方法一：在表名中明显地给出模式名</p><p><strong>Create table “S-T”.Student（……）; /*模式名为 S-T*/</strong></p><p><strong>Create table “S-T”.Cource（……）;</strong></p><p><strong>Create table “S-T”.SC（……）;</strong></p></li><li><p>方法二：在创建模式语句中同时创建表</p></li><li><p>方法三：设置所属的模式</p></li></ul></li><li><p>修改基本表</p><p><strong>ALTER TABLE &lt;表名&gt;</strong></p><p><strong>[ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</strong></p><p><strong>[ DROP &lt;完整性约束名&gt; ]</strong></p><p><strong>[ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]；</strong></p></li><li><p>删除基本表</p><p><strong>DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］；</strong></p><ul><li>RESTRICT：删除表是有限制的。<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE：删除该表没有限制。<ul><li>在删除基本表的同时，相关的依赖对象一起删除</li></ul></li></ul></li><li><p>索 引</p><ul><li>RDBMS中索引一般采用B+树、HASH索引来实现<ul><li>B+树索引具有动态平衡的优点</li><li>HASH索引具有查找速度快的特点</li></ul></li><li>采用B+树，还是HASH索引 则由具体的RDBMS来决定</li><li>索引是关系数据库的内部实现技术，属于内模式的范畴</li><li>CREATE INDEX语句定义索引时，可以定义索引是唯一索引、非唯一索引或聚簇索引</li></ul></li><li><p>建立索引</p><ul><li><p>语句格式</p><p><strong>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</strong></p><p><strong>ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…)；</strong></p><ul><li>在最经常查询的列上建立聚簇索引以提高查询效率</li><li>一个基本表上最多只能建立一个聚簇索引</li><li>经常更新的列不宜建立聚簇索引</li></ul></li></ul></li><li><p>删除索引</p><p><strong>DROP INDEX &lt;索引名&gt;；</strong></p></li></ul><ol><li>数据查询</li></ol><ul><li><p>语句格式</p><p><strong>SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[，&lt;目标列表达式&gt;] …</strong></p><p><strong>FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] …</strong></p><p><strong>[ WHERE &lt;条件表达式&gt; ]</strong></p><p><strong>[ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]</strong></p><p><strong>[ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]；</strong></p></li><li><p>单表查询</p><ul><li>选择表中的若干列</li><li>选择表中的若干元组</li><li>ORDER BY子句<ul><li>可以按一个或多个属性列排序</li><li>升序：ASC；降序：DESC；缺省值为升序</li><li>当排序列含空值时</li><li>ASC：排序列为空值的元组最后显示</li><li>DESC：排序列为空值的元组最先显示</li></ul></li><li>聚集函数<ul><li>计数</li><li>COUNT（[DISTINCT|ALL] *）</li><li>COUNT（[DISTINCT|ALL] &lt;列名&gt;）</li><li>计算总和</li><li>SUM（[DISTINCT|ALL] &lt;列名&gt;）  </li><li>计算平均值</li><li>AVG（[DISTINCT|ALL] &lt;列名&gt;）</li><li>最大最小值</li><li>MAX（[DISTINCT|ALL] &lt;列名&gt;）</li><li>MIN（[DISTINCT|ALL] &lt;列名&gt;）</li></ul></li><li>GROUP BY子句</li></ul></li><li><p>查询的一般规律：先依据条件查询得到结果集，再将分组后的结果集筛选并排序。</p></li><li><p>HAVING短语与WHERE子句的区别：</p><ul><li>作用对象不同</li><li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li><li>HAVING短语作用于组，从中选择满足条件的组。</li></ul></li><li><p>常用的查询条件</p></li></ul><p>查 询 条 件</p><p>谓 词</p><p>比 较</p><p>=，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；NOT+上述比较运算符</p><p>确定范围</p><p>BETWEEN AND，NOT BETWEEN AND</p><p>确定集合</p><p>IN，NOT IN</p><p>字符匹配</p><p>LIKE，NOT LIKE</p><p>空 值</p><p>IS NULL，IS NOT NULL</p><p>多重条件（逻辑运算）</p><p>AND，OR，NOT</p><ul><li><p>ESCAPE ‘＼’ 表示” ＼” 为换码字符</p></li><li><p>连接查询</p><ul><li>等值与非等值连接查询</li><li>自身连接<ul><li>一个表与其自己进行连接<ul><li>需要给表起别名以示区别</li><li>由于所有属性名都是同名属性，因此必须使用别名前缀</li></ul></li></ul></li><li>外连接<ul><li>外连接与普通连接的区别<ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li></ul></li><li>左外连接<ul><li>列出左边关系（如本例Student）中所有的元组</li></ul></li><li>右外连接<ul><li>列出右边关系中所有的元组</li></ul></li></ul></li><li>复合条件连接</li></ul></li><li><p>嵌套查询</p><p>一个SELECT-FROM-WHERE语句称为一个查询块</p><p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p><ul><li>子查询的限制<ul><li>不能使用ORDER BY子句<ul><li>层层嵌套方式反映了 SQL语言的结构化</li><li>有些嵌套查询可以用连接运算替代</li></ul></li></ul></li><li>嵌套查询求解方法<ul><li>子查询的查询条件不依赖于父查询<ul><li>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</li><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul></li><li>带有比较运算符的子查询<ul><li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</li><li>与ANY或ALL谓词配合使用</li></ul></li><li>带有ANY（SOME）或ALL谓词的子查询<ul><li>需要配合使用比较运算符<ul><li>&gt; ANY  大于子查询结果中的某个值</li><li>&gt; ALL  大于子查询结果中的所有值</li><li>&lt; ANY  小于子查询结果中的某个值</li><li>&lt; ALL  小于子查询结果中的所有值</li><li>&gt;= ANY  大于等于子查询结果中的某个值</li><li>&gt;= ALL  大于等于子查询结果中的所有值</li><li>&lt;= ANY  小于等于子查询结果中的某个值</li><li>&lt;= ALL  小于等于子查询结果中的所有值</li><li>= ANY  等于子查询结果中的某个值</li><li>=ALL  等于子查询结果中的所有值（通常没有实际意义）</li><li>!=（或&lt;&gt;）ANY  不等于子查询结果中的某个值</li><li>!=（或&lt;&gt;）ALL  不等于子查询结果中的任何一个值</li></ul></li></ul></li><li>带有EXISTS谓词的子查询<ul><li>\1. EXISTS谓词,存在量词$</li><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。<ul><li>若内层查询结果非空，则外层的WHERE子句返回真值</li><li>若内层查询结果为空，则外层的WHERE子句返回假值</li></ul></li><li>由EXISTS引出的子查询，其目标列表达式通常都用* ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义</li><li>\2. NOT EXISTS谓词<ul><li>若内层查询结果非空，则外层的WHERE子句返回假值</li><li>若内层查询结果为空，则外层的WHERE子句返回真值</li></ul></li></ul></li></ul></li><li><p>集合查询</p><ul><li>集合操作的种类<ul><li>并操作UNION</li><li>交操作INTERSECT</li><li>差操作EXCEPT</li></ul></li><li>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同</li></ul></li><li><p>SELECT语句的一般格式</p><p><strong>SELECT [ALL|DISTINCT]</strong></p><p><strong>&lt;目标列表达式&gt; [别名] [ ，&lt;目标列表达式&gt; [别名]] …</strong></p><p><strong>FROM &lt;表名或视图名&gt; [别名]</strong></p><p><strong>[ ，&lt;表名或视图名&gt; [别名]] …</strong></p><p><strong>[WHERE &lt;条件表达式&gt;]</strong></p><p><strong>[GROUP BY &lt;列名1&gt;</strong></p><p><strong>[HAVING &lt;条件表达式&gt;]]</strong></p><p><strong>[ORDER BY &lt;列名2&gt; [ASC|DESC]</strong></p></li></ul><ol><li>数据更新</li></ol><ul><li><p>插入数据</p><ul><li><p>插入元组</p><ul><li><p>语句格式</p><p><strong>INSERT</strong></p><p><strong>INTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)]</strong></p><p><strong>VALUES (&lt;常量1&gt; [，&lt;常量2&gt;] … )</strong></p></li></ul></li><li><p>插入子查询结果</p><ul><li>语句格式</li></ul><p><strong>INSERT</strong></p><p><strong>INTO &lt;表名&gt; [(&lt;属性列1&gt; [，&lt;属性列2&gt;… )]</strong></p><p><strong>子查询；</strong></p><ul><li>子查询</li></ul><p>SELECT子句目标列必须与INTO子句匹配</p><ul><li>值的个数</li><li>值的类型</li></ul></li></ul></li></ul><ol><li>修改数据</li></ol><ul><li><p>语句格式</p><p><strong>UPDATE &lt;表名&gt;</strong></p><p><strong>SET &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</strong></p><p><strong>[WHERE &lt;条件&gt;]；</strong></p></li></ul><ol><li>删除数据</li></ol><ul><li><p>语句格式</p><p><strong>DELETE</strong></p><p><strong>FROM &lt;表名&gt;</strong></p><p><strong>[WHERE &lt;条件&gt;]；</strong></p></li></ul><ol><li>视 图</li></ol><ul><li><p>虚表，是从一个或几个基本表（或视图）导出的表</p></li><li><p>只存放视图的定义，不存放视图对应的数据</p></li><li><p>基表中的数据发生变化，从视图中查询出的数据也随之改变</p></li><li><p>建立视图</p><ul><li>语句格式</li></ul><p><strong>CREATE VIEW</strong></p><p><strong>&lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]</strong></p><p><strong>AS &lt;子查询&gt;</strong></p><p><strong>[WITH CHECK OPTION]；</strong></p></li><li><p>删除视图</p><p><strong>DROP VIEW &lt;视图名&gt;；</strong></p></li><li><p>查询视图</p><ul><li>用户角度：查询视图与查询基本表相同</li></ul></li><li><p>视图的作用</p></li></ul><ol><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ol><p><strong>数据库安全性</strong></p><ol><li>数据库安全性控制的常用方法</li></ol><ul><li>用户标识和鉴定</li><li>存取控制</li><li>视图</li><li>审计</li><li>密码存储</li></ul><ol><li><p>关系数据库系统中存取控制对象</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302543665.png" alt="img"></p></li><li><p>授权与回收</p></li></ol><ul><li><p>GRANT</p><ul><li>GRANT语句的一般格式：</li></ul><p><strong>GRANT &lt;权限&gt;[,&lt;权限&gt;]…</strong></p><p><strong>[ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p><p><strong>TO &lt;用户&gt;[,&lt;用户&gt;]…</strong></p><p><strong>[WITH GRANT OPTION];</strong></p></li><li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p></li><li><p>WITH GRANT OPTION子句</p><ul><li>WITH GRANT OPTION子句:<ul><li>指定：可以再授予</li><li>没有指定：不能传播</li></ul></li><li>不允许循环授权</li></ul></li><li><p>REVOKE</p><ul><li>授予的权限可以由DBA或其他授权者用REVOKE语句收回</li><li>REVOKE语句的一般格式为：</li></ul><p><strong>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…</strong></p><p><strong>[ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p><p><strong>FROM &lt;用户&gt;[,&lt;用户&gt;]…;</strong></p></li><li><p>创建数据库模式的权限</p><ul><li>DBA在创建用户时实现</li><li>CREATE USER语句格式</li></ul><p>**CREATE USER **</p><p><strong>[WITH][DBA | RESOURCE | CONNECT]</strong></p></li></ul><ol><li>数据库角色</li></ol><ul><li><p>数据库角色：被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合</li><li>可以为一组具有相同权限的用户创建一个角色</li><li>简化授权的过程</li></ul></li><li><p>角色的创建</p><p><strong>CREATE ROLE &lt;角色名&gt;</strong></p></li><li><p>给角色授权</p><p><strong>GRANT &lt;权限&gt;［，&lt;权限&gt;］…</strong></p><p><strong>ON &lt;对象类型&gt;对象名</strong></p><p><strong>TO &lt;角色&gt;［，&lt;角色&gt;］…</strong></p></li><li><p>将一个角色授予其他的角色或用户</p><p><strong>GRANT &lt;角色1&gt;［，&lt;角色2&gt;］…</strong></p><p><strong>TO &lt;角色3&gt;［，&lt;用户1&gt;］…</strong></p><p><strong>［WITH ADMIN OPTION］</strong></p></li><li><p>角色权限的收回</p><p><strong>REVOKE &lt;权限&gt;［，&lt;权限&gt;］…</strong></p><p><strong>ON &lt;对象类型&gt; &lt;对象名&gt;</strong></p><p><strong>FROM &lt;角色&gt;［，&lt;角色&gt;］…</strong></p></li></ul><p><strong>数据库完整性</strong></p><ul><li>数据库的完整性<ul><li>数据的正确性和相容性</li></ul></li><li>数据的完整性和安全性是两个不同概念<ul><li>数据的完整性<ul><li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li><li>防范对象：不合语义的、不正确的数据</li></ul></li><li>数据的安全性<ul><li>保护数据库防止恶意的破坏和非法的存取</li><li>防范对象：非法用户和非法操作</li></ul></li></ul></li><li><strong>实体完整性</strong><ul><li>关系模型的实体完整性<ul><li>CREATE TABLE中用PRIMARY KEY定义</li></ul></li><li>单属性构成的码有两种说明方法<ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul></li><li>对多个属性构成的码只有一种说明方法<ul><li>定义为表级约束条件</li></ul></li><li>插入或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：</li></ul></li></ul><ol><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ol><ul><li><p>检查记录中主码值是否唯一的一种方法是进行全表扫描</p></li><li><p><strong>参照完整性</strong></p><ul><li><p>关系模型的参照完整性定义</p><ul><li><p>在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码</p></li><li><p>用REFERENCES短语指明这些外码参照哪些表的主码</p><p>例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno，Cno分别参照引用Student表的主码和Course表的主码</p><p>［例3］ 定义SC中的参照完整性</p><p>CREATE TABLE SC</p><p>(Sno CHAR(9) NOT NULL，</p><p>Cno CHAR(4) NOT NULL，</p><p>Grade SMALLINT，</p><p>PRIMARY KEY (Sno， Cno)， /<em>在表级定义实体完整性</em>/</p><p>FOREIGN KEY (Sno) REFERENCES Student(Sno)，</p><p>/<em>在表级定义参照完整性</em>/</p><p>FOREIGN KEY (Cno) REFERENCES Course(Cno)</p><p>/<em>在表级定义参照完整性</em>/</p><p>);</p></li></ul></li></ul></li><li><p><strong>用户定义的完整性</strong></p><ul><li>属性上的约束条件的定义<ul><li>CREATE TABLE时定义</li><li>列值非空（NOT NULL）</li><li>列值唯一（UNIQUE）</li><li>检查列值是否满足一个布尔表达式（CHECK）</li></ul></li><li>属性上的约束条件检查和违约处理<ul><li>插入元组或修改属性的值时，RDBMS检查属性上的约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li><li>元组上的约束条件的定义<ul><li>在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制</li><li>同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件</li></ul></li><li>元组上的约束条件检查和违约处理<ul><li>插入元组或修改属性的值时，RDBMS检查元组上的约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li></ul></li><li><p><strong>完整性约束命名子句</strong></p><ul><li><p>CONSTRAINT 约束</p><p><strong>CONSTRAINT &lt;完整性约束条件名&gt;</strong></p><p><strong>［PRIMARY KEY短语</strong></p><p><strong>|FOREIGN KEY短语</strong></p><p><strong>|CHECK短语］</strong></p></li><li><p>使用ALTER TABLE语句修改表中的完整性限制</p></li><li><p>SQL支持域的概念，并可以用CREATE DOMAIN语句建立一个域以及该域应该满足的完整性约束条件。</p></li></ul></li><li><p><strong>触发器</strong></p><ul><li><p>定义触发器</p><ul><li><p>CREATE TRIGGER语法格式</p><p><strong>CREATE TRIGGER &lt;触发器名&gt;</strong></p><p><strong>{BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;</strong></p><p><strong>FOR EACH {ROW | STATEMENT}</strong></p><p><strong>［WHEN &lt;触发条件&gt;］</strong></p><p><strong>&lt;触发动作体&gt;</strong></p></li></ul></li><li><p>定义触发器的语法说明:</p><ul><li>\1. 创建者：表的拥有者</li><li>\2. 触发器名</li><li>\3. 表名：触发器的目标表</li><li>\4. 触发事件：INSERT、DELETE、UPDATE</li><li>\5. 触发器类型<ul><li>行级触发器（FOR EACH ROW）</li><li>语句级触发器（FOR EACH STATEMENT）</li></ul></li><li>\6. 触发条件<ul><li>触发条件为真</li><li>省略WHEN触发条件</li></ul></li><li>\7. 触发动作体<ul><li>触发动作体可以是一个匿名PL/SQL过程块</li><li>也可以是对已创建存储过程的调用</li></ul></li></ul></li><li><p>激活触发器</p><ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器<ul><li>同一个表上的多个触发器激活时遵循如下的执行顺序：</li><li>（1） 执行该表上的BEFORE触发器；</li><li>（2） 激活触发器的SQL语句；</li><li>（3） 执行该表上的AFTER触发器。</li></ul></li></ul></li><li><p>删除触发器</p><ul><li><p>删除触发器的SQL语法：</p><p><strong>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</strong></p></li><li><p>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</p></li></ul></li></ul></li></ul><p><strong>关系数据理论</strong></p><ul><li><p><strong>数据依赖</strong></p><ul><li><p>数据依赖的类型</p><ul><li>函数依赖（Functional Dependency，简记为FD）</li><li>多值依赖（Multivalued Dependency，简记为MVD）</li><li>其他</li></ul></li><li><p>数据依赖对关系模式的影响</p><ul><li>“好”的模式：<ul><li>不会发生插入异常、删除异常、更新异常，</li><li>数据冗余应尽可能少</li><li>原因：由存在于模式中的某些数据依赖引起的</li><li>解决方法：通过分解关系模式来消除其中不合适的数据依赖</li></ul></li></ul></li><li><p>函数依赖</p><ul><li><p><strong>定义6.1</strong> 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。</p></li><li><p>在关系模式R(U)中，对于U的子集X和Y，</p><ul><li>如果X→Y，但Y Í X，则称X→Y是非平凡的函数依赖</li><li>若X→Y，但Y Í X, 则称X→Y是平凡的函数依赖</li><li>若X→Y，则X称为这个函数依赖的决定属性组，也称为决定因素（Determinant）。</li><li>若X→Y，Y→X，则记作X←→Y。</li><li>若Y不函数依赖于X，则记作X→Y。</li></ul></li></ul></li><li><p>完全函数依赖与部分函数依赖</p><ul><li><strong>定义6.2</strong> 在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有X’ Y, 则称Y对X完全函数依赖，记作X→F Y 。 若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X→P Y。</li></ul></li><li><p>传递函数依赖</p><ul><li><p><strong>定义6.3</strong> 在R(U)中，如果X→Y，(Y ÍX) ,Y→X Y→Z， 则称Z对X传递函数依赖。记为：X →传递 Z</p></li><li><p>注: 如果Y→X， 即X←→Y，则Z直接依赖于X。</p></li></ul></li><li><p>码</p><ul><li><p><strong>定义6.4</strong> 设K为R&lt;U,F&gt;中的属性或属性组合。若K U， 则K称为R的侯选码（Candidate Key）。若候选码多于一个，则选定其中的一个做为主码（Primary Key）。</p></li><li><p>主属性与非主属性</p><ul><li>包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）</li><li>不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</li></ul></li><li><p>全码</p><ul><li>整个属性组是码，称为全码（All-key）</li></ul></li></ul></li><li><p>外部码</p><ul><li>定义6.5 关系模式 R 中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码</li></ul></li></ul></li><li><p><strong>范式</strong></p><ul><li>范式是符合某一种级别的关系模式的集合</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式</li><li>范式的种类：  <ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)</li></ul></li><li>各种范式之间存在联系：</li><li>某一关系模式R为第n范式，可简记为R∈nNF。</li><li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化</li><li>1NF<ul><li>1NF的定义<ul><li>如果一个关系模式R的<strong>所有属性都是不可分的基本数据项</strong>，则R∈1NF</li></ul></li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库</li><li>但是满足第一范式的关系模式并不一定是一个好的关系模式</li></ul></li><li>2NF<ul><li>2NF的定义<ul><li>  定义6.6 若<strong>R∈1NF，且每一个非主属性完全函数依赖于码</strong>，则R∈2NF。</li></ul></li></ul></li><li>3NF<ul><li>3NF的定义<ul><li>定义6.7 关系模式R&lt;U，F&gt; 中若不存在这样的码X、属性组Y及非主属性Z（Z Í Y）, 使得X→Y，Y→Z成立， Y → X，则称R&lt;U，F&gt; ∈ 3NF。</li><li>若R∈3NF，则<strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong>。</li></ul></li></ul></li><li>BC范式（BCNF）<ul><li>定义6.8 关系模式R&lt;U，F&gt;∈1NF，若X→Y且Y Í X时，X必含有码，则R&lt;U，F&gt; ∈BCNF。</li><li>等价于：每一个决定属性因素都包含码</li><li>若R∈BCNF<ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有的主属性对每一个不包含它的码，也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li><li>R ∈BCNF <img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302542269.png" alt="img"><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302559238.png" alt="img"> R ∈3NF</li></ul></li></ul></li><li><p><strong>多值依赖</strong></p><ul><li>定义6.9<ul><li>设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y。关系模式R(U)中多值依赖 X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对（x，z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关</li></ul></li><li>多值依赖的另一个等价的形式化的定义：<ul><li>在R（U）的任一关系r中，如果存在元组t，s 使得t[X]=s[X]，那么就必然存在元组 w，vÎ r，（w，v可以与s，t相同），使得w[X]=v[X]=t[X]，而w[Y]=t[Y]，w[Z]=s[Z]，v[Y]=s[Y]，v[Z]=t[Z]（即交换s，t元组的Y值所得的两个新元组必在r中），则Y多值依赖于X，记为X→→Y。 这里，X，Y是U的子集，Z=U-X-Y。</li></ul></li><li>平凡多值依赖和非平凡的多值依赖<ul><li>若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖</li><li>否则称X→→Y为非平凡的多值依赖</li></ul></li><li>多值依赖的性质<ul><li>（1）多值依赖具有对称性。若X→→Y，则X→→Z，其中Z＝U－X－Y</li><li>（2）多值依赖具有传递性。若X→→Y，Y→→Z， 则X→→Z –Y</li><li>（3）函数依赖是多值依赖的特殊情况。若X→Y，则X→→Y。</li><li>（4）若X→→Y，X→→Z，则X→→YÈ Z。</li><li>（5）若X→→Y，X→→Z，则X→→Y∩Z。</li><li>（6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。</li></ul></li><li>多值依赖与函数依赖的区别<ul><li>(1) 多值依赖的有效性与属性集的范围有关</li><li>(2)<ul><li>若函数依赖X→Y在R（U）上成立，则对于任何Y’ Ì Y均有X→Y’ 成立</li><li>多值依赖X→→Y若在R(U)上成立，不能断言对于任何Y’ Ì Y有X→→Y’ 成立</li></ul></li></ul></li><li>4NF<ul><li>定义6.10 关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y Í X），X都含有码，则R∈4NF。</li><li>如果R ∈ 4NF， 则R ∈ BCNF<ul><li>不允许有非平凡且非函数依赖的多值依赖</li><li>允许的非平凡多值依赖是函数依赖</li></ul></li></ul></li></ul></li><li><p><strong>数据依赖的公理系统</strong></p><ul><li><p>逻辑蕴含</p><ul><li>定义6.11 对于满足一组函数依赖 F 的关系模式R &lt;U，F&gt;，其任何一个关系r，若函数依赖X→Y都成立, （即r中任意两元组t，s，若tX］=sX］，则tY］=sY］），则称F逻辑蕴含X →Y</li></ul></li><li><p>关系模式R &lt;U，F &gt;来说有以下的推理规则：</p><ul><li><p>A1.自反律（Reflexivity）：若Y Í X Í U，则X →Y为F所蕴含。</p></li><li><p>A2.增广律（Augmentation）：若X→Y为F所蕴含，且Z Í U，则XZ→YZ为F所蕴含。</p></li><li><p>A3.传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。</p><ul><li><p>自反律: 若Y Í X Í U，则X →Y为F所蕴含</p><p>证: 设Y Í X Í U</p><p>对R &lt;U，F&gt; 的任一关系r中的任意两个元组t，s：</p><p>若t[X]=s[X]，由于Y Í X，有t[y]=s[y]，</p><p>所以X→Y成立，自反律得证</p></li><li><p>增广律: 若X→Y为F所蕴含，且Z Í U，则XZ→YZ 为F所蕴含。</p><p>证：设X→Y为F所蕴含，且Z Í U。</p><p>设R&lt;U，F&gt; 的任一关系r中任意的两个元组t，s：</p><p>若t[XZ]=s[XZ]，则有t[X]=s[X]和t[Z]=s[Z]；</p><p>由X→Y，于是有t[Y]=s[Y]，所以t[YZ]=s[YZ]，所以</p><p>XZ→YZ为F所蕴含，增广律得证。</p></li><li><p>传递律：若X→Y及Y→Z为F所蕴含，则X→Z为 F所蕴含。</p><p>证：设X→Y及Y→Z为F所蕴含。</p><p>对R&lt;U，F&gt; 的任一关系 r中的任意两个元组 t，s：</p><p>若t[X]=s[X]，由于X→Y，有 t[Y]=s[Y]；</p><p>再由Y→Z，有t[Z]=s[Z]，所以X→Z为F所蕴含，传递律得证。</p></li></ul></li></ul></li><li><p>导出规则</p><ul><li><p>1.根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：</p><ul><li><p>合并规则：由X→Y，X→Z，有X→YZ。</p><p>（A2， A3）</p></li><li><p>伪传递规则：由X→Y，WY→Z，有XW→Z。</p><p>（A2， A3）</p></li><li><p>分解规则：由X→Y及 ZÍY，有X→Z。</p><p>（A1， A3）</p></li></ul></li><li><p>2.根据合并规则和分解规则，可得引理6.1</p><ul><li>引理6.l X→A1 A2…Ak成立的充分必要条件是X→Ai成立（i=l，2，…，k）</li></ul></li></ul></li><li><p>函数依赖闭包</p><ul><li>定义6.l2 在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依赖的全体叫作 F的闭包，记为F+。</li><li>定义6.13 设F为属性集U上的一组函数依赖，X ÍU， XF+ ={ A|X→A能由F 根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F 的闭包</li></ul></li><li><p>函数依赖集等价</p><ul><li><p>定义6.14 如果G+=F+，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。</p></li><li><p>引理6.3 F+ = G+ 的充分必要条件是F Í G+ ，和G Í F+</p><p>证: 必要性显然，只证充分性。</p><p>（1）若FÍG+ ，则XF+ Í XG++ 。</p><p>（2）任取X→YÎF+ 则有 Y Í XF+ Í XG++ 。</p><p>​     所以X→Y Î (G+）+= G+。即F+ Í G+。</p><p>（3）同理可证G+ Í F+ ，所以F+ = G+。</p></li></ul></li><li><p>最小依赖集</p><ul><li>定义6.15 如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集。亦称为最小依赖集或最小覆盖。<ul><li>(1) F中任一函数依赖的右部仅含有一个属性。</li><li>(2) F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</li><li>(3) F中不存在这样的函数依赖X→A， X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</li></ul></li></ul></li><li><p>极小化过程</p><ul><li><p>定理6.3 每一个函数依赖集F均等价于一个极小函数依赖集Fm。此Fm称为F的最小依赖集。</p><p>证明: 构造性证明，找出F的一个最小依赖集。</p><p>(1)逐一检查F中各函数依赖FDi：X→Y，若Y=A1A2 …Ak，k &gt; 2，</p><p>则用 { X→Aj |j=1，2，…， k} 来取代X→Y。</p><p>(2)逐一检查F中各函数依赖FDi：X→A，令G=F-{X→A}，</p><p>若AÎXG+， 则从F中去掉此函数依赖。</p><p>(3)逐一取出F中各函数依赖FDi：X→A，设X=B1B2…Bm，</p><p>逐一考查Bi （i=l，2，…，m），若A Î（X-Bi ）F+ ，</p><p>则以X-Bi 取代X。</p></li></ul></li><li><p>模式的分解</p><ul><li>三种模式分解等价的定义：<ul><li>⒈ 分解具有无损连接性</li><li>⒉ 分解要保持函数依赖</li><li>⒊ 分解既要保持函数依赖，又要具有无损连接性</li></ul></li><li>定义6.16 关系模式R&lt;U,F&gt;的一个分解：<em>ρ</em>={ R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;，…，Rn&lt;Un,Fn&gt;}，U= ∪U<em>i</em>，且不存在 Ui Í Uj，Fi 为 F在 Ui 上的投影</li><li>定义6.17 函数依赖集合{X→Y | X→Y Î F+∧XY ÍUi} 的一个覆盖 Fi 叫作 F 在属性 Ui 上的投影</li></ul></li><li><p>具有无损连接性的模式分解</p><ul><li>关系模式R&lt;U,F&gt;的一个分解 ρ={ R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;， …，Rn&lt;Un,Fn&gt;}，若R与R1、R2、…、Rn自然连接的结果相等，则称关系模式R的这个分解ρ具有无损连接性（Lossless join）</li><li>具有无损连接性的分解保证不丢失信息</li><li>无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题</li></ul></li><li><p>保持函数依赖的模式分解</p><ul><li>设关系模式R&lt;U,F&gt;被分解为若干个关系模式，R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;，…，Rn&lt;Un,Fn&gt; ，（其中U=U1∪U2∪…∪Un，且不存在Ui Í Uj，Fi为F在Ui上的投影），若F所逻辑蕴含的函数依赖一定也由分解得到的某个关系模式中的函数依赖Fi所逻辑蕴含，则称关系模式R的这个分解是保持函数依赖的（Preserve dependency）</li></ul></li><li><p>关系模式的规范化，其基本思想：</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230255351.png" alt="img"></p></li><li><p>小结</p><ul><li>若要求分解具有无损连接性，那么模式分解一定能够达到4NF</li><li>若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF</li><li>若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF，但不一定能够达到BCNF</li></ul></li></ul></li></ul><p><strong>数据库设计</strong></p><ol><li><p>数据库设计的特点</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302558747.png" alt="img"></p></li><li><p>数据库设计方法</p></li></ol><ul><li>基本思想：过程迭代和逐步求精<ul><li>新奥尔良（New Orleans）方法<ul><li>将数据库设计分为若干阶段和步骤</li></ul></li><li>基于E-R模型的数据库设计方法<ul><li>概念设计阶段广泛采用</li></ul></li><li>3NF（第三范式）的设计方法<ul><li>逻辑阶段可采用的有效方法</li></ul></li><li>ODL（Object Definition Language）方法<ul><li>面向对象的数据库设计方法</li></ul></li><li>计算机辅助设计<ul><li>ORACLE Designer 2000</li><li>SYBASE PowerDesigner</li></ul></li></ul></li><li>数据库设计的基本步骤<ul><li>数据库设计分6个阶段<ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul></li><li>需求分析和概念设计独立于任何数据库管理系统</li><li>逻辑设计和物理设计与选用的DBMS密切相关</li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302576437.png" alt="img"></p><ol><li>数据库设计过程中的各级模式</li></ol><ul><li><p>数据库设计不同阶段形成的数据库各级模式</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302577583.png" alt="img"></p></li></ul><ol><li>结构化分析方法（Structured Analysis，简称SA方法）</li></ol><ul><li><p>从最上层的系统组织机构入手</p></li><li><p>自顶向下、逐层分解分析系统</p><ul><li>1．首先把任何一个系统都抽象为：</li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230258648.png" alt="img"></p><ul><li><p>2．分解处理功能和数据</p><ul><li>(1)分解处理功能<ul><li>将处理功能的具体内容分解为若干子功能</li></ul></li><li>(2)分解数据<ul><li>处理功能逐步分解同时，逐级分解所用数据，形成若干层次的数据流图</li></ul></li><li>(3)表达方法<ul><li>处理逻辑：用判定表或判定树来描述</li><li>数据：用数据字典来描述</li></ul></li></ul></li><li><p>3．将分析结果再次提交给用户，征得用户的认可</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302588239.png" alt="img"></p></li></ul></li></ul><ol><li>数据字典</li></ol><ul><li><p>数据字典的用途</p><ul><li>进行详细的数据收集和数据分析所获得的主要结果</li></ul></li><li><p>数据字典的内容</p><ul><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>处理过程</li></ul></li><li><p>⒈ 数据项</p><ul><li><p>数据项是不可再分的数据单位</p></li><li><p>对数据项的描述</p><p>数据项描述＝｛数据项名，数据项含义说明，别名，</p><p>数据类型，长度，取值范围，取值含义，</p><p>​      与其他数据项的逻辑关系，数据项之间的联系 ｝</p></li></ul></li><li><p>⒉ 数据结构</p><ul><li><p>数据结构反映了数据之间的组合关系。</p></li><li><p>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</p></li><li><p>对数据结构的描述</p><p>数据结构描述＝｛数据结构名，含义说明，</p><p>组成:｛数据项或数据结构｝｝</p></li></ul></li><li><p>⒊ 数据流</p><ul><li><p>数据流是数据结构在系统内传输的路径。</p></li><li><p>对数据流的描述</p><p>数据流描述＝｛ 数据流名，说明，数据流来源，</p><p>数据流去向，组成:｛数据结构｝，</p><p>平均流量，高峰期流量｝</p></li></ul></li><li><p>⒋ 数据存储</p><ul><li><p>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。</p></li><li><p>对数据存储的描述</p><p>数据存储描述＝｛数据存储名，说明，编号，</p><p>​       输入的数据流 ，输出的数据流 ，</p><p>​       组成:｛数据结构｝，数据量，存取频度，存取方式｝</p></li></ul></li><li><p>⒌ 处理过程</p><ul><li><p>具体处理逻辑一般用判定表或判定树来描述</p></li><li><p>处理过程说明性信息的描述</p><p>处理过程描述＝｛处理过程名，说明，输入:｛数据流｝，</p><p>输出:｛数据流｝，处理:｛简要说明｝｝</p></li></ul></li></ul><ol><li>概念结构设计</li></ol><ul><li>设计概念结构的四类方法<ul><li>自顶向下</li></ul></li></ul><ol><li>首先定义全局概念结构的框架，然后逐步细化</li></ol><ul><li>自底向上</li></ul><ol><li>首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构</li></ol><ul><li>逐步扩张</li></ul><ol><li>首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构</li></ol><ul><li>混合策略</li></ul><ol><li>将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。</li></ol><ul><li><p>常用策略</p><ul><li><p>自顶向下地进行需求分析</p></li><li><p>自底向上地设计概念结构</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302594127.png" alt="img"></p></li></ul></li><li><p>自底向上设计概念结构的步骤</p><ul><li><p>  第1步：抽象数据并设计局部视图</p></li><li><p>第2步：集成局部视图，得到全局概念结构</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230259780.png" alt="img"></p></li></ul></li><li><p>数据抽象与局部视图设计</p><ul><li><p>数据抽象</p><ul><li>三种常用抽象<ul><li>\1. 分类（Classification）<ul><li>定义某一类概念作为现实世界中一组对象的类型</li><li>抽象了对象值和型之间的”is member of”的语义</li></ul></li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302596668.png" alt="img"></p><ul><li>\2. 聚集（Aggregation）<ul><li>定义某一类型的组成成分</li><li>抽象了对象内部类型和成分之间”is part of”的语义</li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302596145.png" alt="img"></p><ul><li>复杂的聚集，某一类型的成分仍是一个聚集</li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303001195.png" alt="img"></p><ul><li>\3. 概括（Generalization）<ul><li>定义类型之间的一种子集联系</li><li>抽象了类型之间的”is subset of”的语义</li><li>继承性</li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303002307.png" alt="img"></p></li><li><p>局部视图设计</p><ul><li>设计分E-R图的步骤:<ul><li>⒈选择局部应用<ul><li>在多层的数据流图中选择一个适当层次的数据流图，作为设计分E-R图的出发点</li><li>通常以中层数据流图作为设计分E-R图的依据</li></ul></li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303015438.png" alt="img"></p><ul><li>⒉逐一设计分E-R图<ul><li>任务<ul><li>将各局部应用涉及的数据分别从数据字典中抽取出来</li><li>参照数据流图，标定各局部应用中的实体、实体的属性、标识实体的码</li><li>确定实体之间的联系及其类型（1:1，1:n，m:n）</li></ul></li><li>两条准则：<ul><li>（1）属性不能再具有需要描述的性质。即属性必须是不可分的数据项，不能再由另一些属性组成</li><li>（2）属性不能与其他实体具有联系。联系只发生在实体之间</li></ul></li><li>举例</li></ul></li></ul><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303024981.png" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303025570.png" alt="img"></p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303028983.png" alt="img"></p></li></ul></li></ul><ol><li>逻辑结构设计</li></ol><ul><li>E-R图向关系模型的转换</li><li>数据模型的优化<ul><li>优化数据模型的方法<ul><li>1确定数据依赖<ul><li>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖</li></ul></li><li>2消除 冗余的联系<ul><li>对于各个关系模式之间的数据依赖进行极小化处理，消除 冗余的联系。</li></ul></li><li>3确定所属范式<ul><li>按照数据依赖的理论对关系模式逐一进行分析</li><li>考查是否存在部分函数依赖、传递函数依赖、多值依赖等</li><li>确定各关系模式分别属于第几范式</li></ul></li><li>4按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</li><li>注意：并不是规范化程度越高的关系就越优，一般说来，第三范式就足够了</li><li>5按照需求分析阶段得到的各种应用对数据处理的要求，对关系模式进行必要的分解，以提高数据操作的效率和存储空间的利用率</li></ul></li></ul></li><li>设计用户子模式<ul><li>定义用户外模式时应该注重的问题<ul><li>包括三个方面：<ul><li>(1) 使用更符合用户习惯的别名</li><li>(2) 针对不同级别的用户定义不同的View ，以满足系统对安全性的要求。</li><li>(3) 简化用户对系统的使用</li></ul></li></ul></li></ul></li></ul><ol><li>数据库的物理设计</li></ol><ul><li>数据库物理设计的内容和方法</li><li>关系模式存取方法选择<ul><li>DBMS常用存取方法<ul><li>索引方法<ul><li>目前主要是B+树索引方法</li><li>经典存取方法，使用最普遍</li></ul></li><li>聚簇（Cluster）方法<ul><li>HASH方法</li></ul></li></ul></li><li>选择索引存取方法的一般规则<ul><li>如果一个(或一组)属性经常在查询条件中出现，则考虑在这个(或这组)属性上建立索引(或组合索引)</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个(或一组)属性经常在连接操作的连接条件中出现，则考虑在这个(或这组)属性上建立索引</li></ul></li><li>聚簇<ul><li>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块称为聚簇</li></ul></li><li>聚簇的用途<ul><li>\1. 大大提高按聚簇码进行查询的效率</li><li>\2. 节省存储空间<ul><li>聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了</li></ul></li></ul></li><li>聚簇的局限性<ul><li>\1. 聚簇只能提高某些特定应用的性能</li><li>\2. 建立与维护聚簇的开销相当大<ul><li>对已有关系建立聚簇，将导致关系中元组移动其物理存储位置，并使此关系上原有的索引无效，必须重建</li><li>当一个元组的聚簇码改变时，该元组的存储位置也要做相应移动</li></ul></li></ul></li></ul></li><li>确定数据的存放位置<ul><li>根据应用情况将<ul><li>易变部分与稳定部分分开存放</li><li>存取频率较高部分与存取频率较低部分，分开存放</li></ul></li></ul></li><li>评价物理结构</li></ul><ol><li>小结（续）</li></ol><ul><li>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模型，形成数据库逻辑模式。然后根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图（VIEW）形成数据的外模式</li><li>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库内模式</li></ul><p><strong>数据库编程</strong></p><ul><li>嵌入式SQL</li></ul><ol><li>嵌入式SQL的处理过程</li></ol><ul><li>数据库工作单元与源程序工作单元之间的通信：<ul><li>\1. SQL通信区<ul><li>向主语言传递SQL语句的执行状态信息</li><li>使主语言能够据此控制程序流程</li></ul></li><li>\2. 主变量<ul><li>主语言向SQL语句提供参数</li><li>将SQL语句查询数据库的结果交主语言进一步处理</li></ul></li><li>\3. 游标<ul><li>解决集合性操作语言与过程性操作语言的不匹配</li></ul></li></ul></li></ul><ol><li>嵌入式SQL与主语言的通信</li></ol><ul><li><p>在SQL语句中使用主变量和指示变量的方法</p><ul><li><ol><li>说明主变量和指示变量</li></ol><p><strong>BEGIN DECLARE SECTION</strong></p><p>  <strong>………</strong></p><p>  <strong>……… (说明主变量和指示变量)</strong></p><p>  <strong>………</strong></p><p><strong>END DECLARE SECTION</strong></p></li><li><ol start="2"><li>使用主变量</li></ol><ul><li>说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现</li><li>为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志</li></ul></li><li><ol start="3"><li>使用指示变量</li></ol><ul><li>指示变量前也必须加冒号标志</li><li>必须紧跟在所指主变量之后</li></ul></li></ul></li><li><p>在SQL语句之外(主语言语句中)使用主变量和指示变量的方法</p><ul><li>可以直接引用，不必加冒号</li></ul></li><li><p>游标（cursor）</p><ul><li>SQL语言与主语言具有不同数据处理方式</li><li>SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录</li><li>主语言是面向记录的，一组主变量一次只能存放一条记录</li><li>仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求</li><li>嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式</li><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</li><li>每个游标区都有一个名字</li><li>用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理</li></ul></li><li><p>建立和关闭数据库连接</p><ul><li><p>建立数据库连接</p><p><strong>EXEC SQL CONNECT TO target [AS connection-name] [USER user-name];</strong></p><ul><li>target是要连接的数据库服务器：<ul><li>常见的服务器标识串，如<dbname>@<hostname>:<port></port></hostname></dbname></li><li>包含服务器标识的SQL串常量</li><li>DEFAULT</li></ul></li><li>connect-name是可选的连接名，连接必须是一个有效的标识符 在整个程序内只有一个连接时可以不指定连接名</li></ul></li><li><p>关闭数据库连接</p><p><strong>EXEC SQL DISCONNECT [connection];</strong></p></li><li><p>程序运行过程中可以修改当前连接 ：</p><p><strong>EXEC SQL SET CONNECTION connection-name | DEFAULT;</strong></p></li></ul></li><li><p>不用游标的SQL语句的种类</p><ul><li>说明性语句</li><li>数据定义语句</li><li>数据控制语句</li><li>查询结果为单记录的SELECT语句</li><li>非CURRENT形式的增删改语句</li></ul></li><li><p>使用游标的SQL语句</p><ul><li><p>查询结果为多条记录的SELECT语句</p><ul><li><p>使用游标的步骤</p><ul><li><p>\1. 说明游标</p><ul><li><p>使用DECLARE语句</p></li><li><p>语句格式</p><p><strong>EXEC SQL DECLARE &lt;游标名&gt; CURSOR</strong></p><p><strong>FOR ;</strong></p></li><li><p>功能</p><p>是一条说明性语句，这时DBMS并不执行SELECT指定的查询操作。</p></li></ul></li><li><p>\2. 打开游标</p><ul><li><p>使用OPEN语句</p></li><li><p>语句格式</p><p><strong>EXEC SQL OPEN &lt;游标名&gt;;</strong></p></li><li><p>功能</p><p>打开游标实际上是执行相应的SELECT语句，把所有满足查询条件的记录从指定表取到缓冲区中这时游标处于活动状态，指针指向查询结果集中第一条记录</p></li></ul></li><li><p>3.推进游标指针并取当前记录</p><ul><li><p>使用FETCH语句</p></li><li><p>语句格式</p><p><strong>EXEC SQL FETCH [[NEXT|PRIOR|</strong></p><p><strong>FIRST|LAST] FROM] &lt;游标名&gt;</strong></p><p><strong>INTO &lt;主变量&gt;[&lt;指示变量&gt;][,&lt;主变量&gt;[&lt;指示变量&gt;]]…;</strong></p></li><li><p>功能</p><p>指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理</p><p>NEXT|PRIOR|FIRST|LAST：指定推动游标指针的方式</p><p>NEXT：向前推进一条记录</p><p>PRIOR：向回退一条记录</p><p>FIRST：推向第一条记录</p><p>LAST：推向最后一条记录</p><p>缺省值为NEXT</p></li></ul></li><li><p>\4. 关闭游标</p><ul><li><p>使用CLOSE语句</p></li><li><p>语句格式</p><p><strong>EXEC SQL CLOSE &lt;游标名&gt;;</strong></p></li><li><p>功能</p><p>关闭游标，释放结果集占用的缓冲区及其他资源</p></li><li><p>说明</p><p>游标被关闭后，就不再和原来的查询结果集相联系</p><p>被关闭的游标可以再次被打开，与新的查询结果相联系</p></li></ul></li></ul></li></ul></li><li><p>CURRENT形式的UPDATE语句</p><ul><li><p>CURRENT形式的UPDATE语句和DELETE语句的用途</p><ul><li>面向集合的操作</li><li>一次修改或删除所有满足条件的记录</li></ul></li><li><p>如果只想修改或删除其中某个记录</p><ul><li><p>用带游标的SELECT语句查出所有满足条件的记录</p></li><li><p>从中进一步找出要修改或删除的记录</p></li><li><p>用CURRENT形式的UPDATE语句和DELETE语句修改或删除之</p></li><li><p>UPDATE语句和DELETE语句中的子句：</p><p><strong>WHERE CURRENT OF &lt;游标名&gt;</strong></p><p>表示修改或删除的是最近一次取出的记录，即游标指针指向的记录</p></li></ul></li><li><p>不能使用CURRENT形式的UPDATE语句和DELETE语句 :</p><ul><li>当游标定义中的SELECT语句带有UNION或ORDER BY子句</li><li>该SELECT语句相当于定义了一个不可更新的视图</li></ul></li><li></li></ul></li></ul></li></ul><ol><li>动态SQL</li></ol><ul><li><p>静态嵌入式SQL</p><ul><li>静态嵌入式SQL语句能够满足一般要求</li><li>无法满足要到执行时才能够确定要提交的SQL语句</li></ul></li><li><p>动态嵌入式SQL</p><ul><li>允许在程序运行过程中临时”组装”SQL语句</li><li>支持动态组装SQL语句和动态参数两种形式</li></ul></li><li><p>SQL语句主变量：</p><ul><li>程序主变量包含的内容是SQL语句的内容，而不是原来保存数据的输入或输出变量</li><li>SQL语句主变量在程序执行期间可以设定不同的SQL语句，然后立即执行</li></ul></li><li><p>动态参数</p><ul><li>SQL语句中的可变元素</li><li>使用参数符号(?)表示该位置的数据在运行时设定</li></ul></li><li><p>和主变量的区别</p><ul><li>动态参数的输入不是编译时完成绑定</li><li>而是通过 (prepare)语句准备主变量和执行(execute)时绑定数据或主变量来完成</li></ul></li><li><p>使用动态参数的步骤：</p><ul><li><p>1.声明SQL语句主变量。</p></li><li><p>2.准备SQL语句(PREPARE)。</p><p><strong>EXEC SQL PREPARE &lt;语句名&gt; FROM ;</strong></p></li><li><p>3.执行准备好的语句(EXECUTE)</p><p><strong>EXEC SQL EXECUTE &lt;语句名&gt; [INTO &lt;主变量表&gt;] [USING &lt;  主变量或常量&gt;];</strong></p></li></ul></li><li><p>存储过程</p></li></ul><ol><li>PL/SQL的块结构</li></ol><ul><li><p>PL/SOL块的基本结构：</p><ul><li><p>1.定义部分</p><p><strong>DECLARE</strong>  </p><p><strong>——变量、常量、游标、异常等</strong></p><ul><li>定义的变量、常量等只能在该基本块中使用</li><li>当基本块执行结束时，定义就不再存在</li></ul></li><li><p>2.执行部分</p><p><strong>BEGIN</strong></p><p><strong>——SQL语句、PL/SQL的流程控制语句</strong></p><p><strong>EXCEPTION</strong></p><p><strong>——异常处理部分</strong>    </p><p><strong>END；</strong></p></li></ul></li><li><p>变量常量的定义</p><ul><li>\1. PL/SQL中定义变量的语法形式是:<ul><li>变量名 数据类型 ［ ［NOT NULL］:=初值表达式］或</li><li>变量名 数据类型 ［ ［NOT NULL］初值表达式］</li></ul></li><li>\2. 常量的定义类似于变量的定义:<ul><li>常量名 数据类型 CONSTANT :=常量表达式</li><li>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，PL/SQL将返回一个异常。</li></ul></li><li>\3. 赋值语句<ul><li>变量名称:=表达式</li></ul></li><li>控制结构</li></ul></li><li><p>一、条件控制语句</p><ul><li><p>IF-THEN， IF-THEN-ELSE和嵌套的IF语句</p><p>  <strong>1. IF condition THEN</strong></p><p>   <strong>Sequence_of_statements;</strong></p><p>   <strong>END IF</strong></p><p>  <strong>2. IF condition THEN</strong></p><p>   <strong>Sequence_of_statements1;</strong></p><p>   <strong>ELSE</strong></p><p>   <strong>Sequence_of_statements2;</strong></p><p>   <strong>END IF;</strong></p><p>  <strong>3. 在THEN和ELSE子句中还可以再包括IF语句，即IF语句可以嵌套</strong></p></li></ul></li><li><p>二、循环控制语句</p><ul><li><p>LOOP， WHILE-LOOP和FOR-LOOP</p><p><strong>1.最简单的循环语句LOOP</strong></p><p>   <strong>LOOP</strong></p><p>   <strong>Sequence_of_statements;</strong></p><p>   <strong>END LOOP;</strong></p><p>  <strong>多数数据库服务器的PL/SQL都提供EXIT、BREAK或LEAVE等循环结束语句，保证LOOP语句块能够结束。</strong></p><p><strong>2. WHILE-LOOP</strong></p><p><strong>WHILE condition LOOP</strong></p><p>   <strong>Sequence_of_statements;</strong></p><p>  <strong>END LOOP;</strong></p><p><strong>每次执行循环体语句之前，首先对条件进行求值</strong></p><p><strong>如果条件为真，则执行循环体内的语句序列。</strong></p><p><strong>如果条件为假，则跳过循环并把控制传递给下一个语句</strong></p><p><strong>3. FOR-LOOP</strong></p><p>  <strong>FOR count IN ［REVERSE］bound1 … bound2 LOOP</strong></p><p>   <strong>Sequence_of_statements;</strong></p><p>  <strong>END LOOP;</strong></p></li></ul></li></ul><ol><li>存储过程的用户接口</li></ol><ul><li><p>\1. 创建存储过程：</p><p>  <strong>CREATE Procedure 过程名（［参数1，参数2，…］） AS</strong></p><p>  <strong>；</strong></p><ul><li><p>过程名：数据库服务器合法的对象标识</p></li><li><p>参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数。默认为输入参数。</p></li><li><p>过程体：是一个&lt;PL/SQL块&gt;。包括声明部分和可执行语句部分</p></li><li><p>重命名存储过程</p><p><strong>ALTER Procedure 过程名1 RENAME TO 过程名2;</strong></p></li></ul></li><li><p>\2. 执行存储过程：</p><p><strong>CALL/PERFORM Procedure 过程名(［参数1，参数2，…］)；</strong></p><ul><li>使用CALL或者PERFORM等方式激活存储过程的执行。</li><li>在PL/SQL中，数据库服务器支持在过程体中调用其他存储过程</li></ul></li><li><p>\3. 删除存储过程</p><p><strong>DROP PROCEDURE 过程名（）；</strong></p></li></ul><ol><li>ODBC编程</li></ol><p><strong>对象关系数据库系统</strong></p><ul><li>对象关系数据库系统(Object Relational Database System，ORDBS)是面向对象数据模型(Object Oriented Data Model，简称OO模型)和关系数据模型相结合的产物</li><li>面向对象数据模型</li></ul><ol><li>OO模型的核心概念</li></ol><ul><li>1.对象<ul><li>定义：对象是由一组数据结构和在这组数据结构上的操作的程序代码封装起来的基本单位。</li><li>组成部分<ul><li>属性(Attribute)集合<ul><li>属性描述对象的状态、组成和特性</li></ul></li><li>方法(Method)集合<ul><li>描述了对象的行为特性</li></ul></li></ul></li></ul></li><li>\2. 对象标识OID(Object IDentifier)<ul><li>概念：面向对象数据库中的每个对象都有一个唯一的不变的标识称为对象标识(OID)</li><li>特点：<ul><li>永久持久性</li><li>独立于值的、系统全局唯一的</li></ul></li></ul></li><li>\3. 封装(Encapsulation)<ul><li>每一个对象是其状态与行为的封装</li><li>封装是对象的外部界面与内部实现之间实行清晰隔离的一种抽象，外部与对象的通信只能通过消息</li><li>对象封装之后查询属性值必须通过调用方法</li></ul></li><li>\4. 类(Class)<ul><li>对象类(简称类)：共享同样属性和方法集的所有对象构成了一个对象类</li><li>实例：一个对象是某一类的一个实例(instance)</li><li>在OODB中，类是”型”，对象是某一类的一个”值”</li></ul></li></ul><ol><li><p>类层次(结构)</p></li><li><p>继承</p></li><li><p>对象的嵌套</p></li><li><p>关系数据模型与OO模型的比较</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303037065.png" alt="img"></p></li></ol><ul><li>对象-关系数据库</li></ul><ol><li>对象关系数据库系统中扩展的关系数据类型</li></ol><ul><li><p>1.大对象LOB(Large OBject )类型</p><ul><li>LOB可存储多达十亿字节的串。</li><li>LOB分类<ul><li>二进制大对象BLOB(Binary Large OBject)</li><li>BLOB用于存储音频、图像数据</li><li>字符串大对象CLOB(Character Large OBject)。</li><li>CLOB用于存储长字符串数据</li></ul></li></ul></li><li><p>2.BOOLEAN类型</p><ul><li>布尔类型，支持3个真值：true、false和unknown</li><li>操作符：NOT、AND、OR、EVERY、ANY<ul><li>例如 WHERE EVERY(QTY&gt;200)</li><li>   或WHERE ANY(QTY&gt;200)</li><li>QTY列为空值：返回unknown；</li><li>QTY列为非空：</li><li>当该列的每一个值都使(QTY&gt;200)为true时，EVERY返回true，否则为false；</li><li>当该列的每一个值都使(QTY&gt;200)为false时，ANY返回false，否则为true。</li></ul></li></ul></li><li><p>3.集合类型(Collection Type)ARRAY</p><ul><li><p>相同类型元素的有序集合称为数组ARRAY</p><ul><li>SQL3新增的集合类型</li><li>允许在数据库的一列中存储数组</li></ul></li><li><p>SQL3的数组只能是一维的</p><ul><li><p>数组中的元素不能再是数组</p></li><li><p>［例2］</p><p><strong>CREATE</strong> <strong>TABLE</strong> SALES</p><p><strong>(</strong></p><p>ITEM_NO <strong>CHAR(**20</strong>)**， /<em>商品号</em>/</p><p>QTY <strong>INTEGER</strong> <strong>ARRAY</strong>［12］， /<em>整数数组，存放销售额</em>/</p><p><strong>PRIMARY</strong> <strong>KEY(**ITEM_NO</strong>)**</p><p>**)**；</p></li><li><p>向SALES表插入一个元组：</p></li></ul><p><strong>INSERT</strong> <strong>INTO</strong> SALES**(<strong>ITEM_NO，QTY</strong>)VALUES**</p><p><strong>(</strong>‘T**-<strong>shirt2000’，</strong>ARRAY**［200，150，200，100，50，70，</p><p>80，200，10，20，100，200］**)**；</p><ul><li><p>查找三月份销售额大于100的商品号：</p><p><strong>SELECT</strong> ITEM_NO</p><p><strong>FROM</strong> SALES</p><p><strong>WHERE</strong> QTY［3］**&gt;**100；</p></li></ul></li></ul></li><li><p>\4. DISTINCT类型</p><ul><li><p>SQL3新加了一种DISTINCT类型</p></li><li><p>定义DISTINCT数据类型语法</p><p>CREAT <strong>TYPE</strong> ** name**&gt;**</p><p><strong>AS</strong> <strong>&lt;**built **in** scalar **type** name**&gt;</strong> FINAL</p><p><strong>[</strong> ** <strong>option&gt;]</strong></p><p><strong>[</strong> <strong>&lt;**method specification commalist**&gt;];</strong></p></li><li><p>没有使用DISTINCT类型</p><ul><li>例如，职工的智商字段(IQ)和鞋号字段(SHOE_SIZE)定义成INTEGER类型</li><li>WHERE SHOE_SIZE &gt; IQ</li></ul></li><li><p>使用DISTINCT类型</p><ul><li><p>重新定义这两字段类型</p><p>CREAT <strong>TYPE</strong> SHOE_SIZE_TYPE <strong>AS</strong> <strong>INTEGER</strong> FINAL**;**</p><p>CREAT <strong>TYPE</strong> IQ_TYPE <strong>AS</strong> <strong>INTEGER</strong> FINAL**;**</p></li><li><p>SHOE_SIZE_TYPE和IQ _TYPE成为两种不同的数据类型</p></li><li><p>表达式：WHERE SHOE_SIZE &gt; IQ 是非法的</p></li><li><p>如果在定义类型时设置了选项<cast option="">，下面用法也是合法的：WHERE MY_SHOE_SIZE &gt; CAST (MY_IQ AS SHOE_SIZE)</cast></p></li></ul></li></ul></li></ul><ol><li>对象关系数据库系统中扩展的对象类型及其定义</li></ol><ul><li><p>在ORDBMS中，类型(TYPE)具有类(CLASS)的特征，可以看成类</p><ul><li><p>1.行对象与行类型</p><ul><li><p>定义行类型(ROW TYPE) ：</p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> <strong>&lt;**row_type_name**&gt;</strong></p><p>**(&lt;**component declarations**&gt;)**；</p></li><li><p>创建行类型</p><ul><li><p>［例3］</p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Person_type</p><p><strong>(**pno **NUMBER</strong>，</p><p>name <strong>VARCHAR2(**100</strong>)**，</p><p>address <strong>VARCHAR2(**100</strong>)** <strong>);</strong></p></li></ul></li><li><p>创建基于行类型的表</p><p><strong>CREATE</strong> <strong>TABLE</strong> <strong>&lt;**table_name**&gt;</strong> <strong>OF</strong> <strong>&lt;**row_type_name**&gt;;</strong></p><ul><li><p>［例4］</p><p><strong>CREATE</strong> <strong>TABLE</strong> person_extent <strong>OF</strong> Person_type</p><p><strong>(**pno **PRIMARY</strong> <strong>KEY</strong> <strong>);</strong></p></li></ul></li></ul></li><li><p>2.列对象与对象类型</p><ul><li><p>可以创建一个对象类型，表的属性可以是该对象类型。</p></li><li><p>创建列对象语句如下:</p><p><strong>CREATE</strong> <strong>TYPE</strong> <strong>&lt;**type_name**&gt;</strong> <strong>AS</strong> <strong>OBJECT</strong></p><p><strong>(&lt;**component declarations**&gt;);</strong></p></li><li><p>［例5］</p><p><strong>CREATE</strong> <strong>TYPE</strong> address_objtyp <strong>AS</strong> <strong>OBJECT</strong></p><p><strong>(**street **VARCHAR2(**50</strong>)**，</p><p>city <strong>VARCHAR2(**50</strong>)** <strong>);</strong></p><p></p><p><strong>CREATE</strong> <strong>TYPE</strong> name_objtyp <strong>AS</strong> <strong>OBJECT</strong></p><p><strong>(**first_name **VARCHAR2(**30</strong>)**，</p><p>last_name <strong>VARCHAR2(**30</strong>)** <strong>)</strong> <strong>;</strong></p></li><li><p>创建表，定义其中的属性是对象类型</p></li><li><p>［例6］</p><p><strong>CREATE</strong> <strong>TABLE</strong> people_reltab <strong>(</strong></p><p>Id <strong>NUMBER(**10</strong>)**，</p><p>name_obj name_objtyp，</p><p>address_obj address_objtyp**);**</p></li></ul></li><li><p>\3. 抽象数据类型(Abastract Data Type，ADT)</p><ul><li><p>概念：SQL3允许用户创建指定的带有自身行为说明和内部结构的用户定义类型称为抽象数据类型</p></li><li><p>定义ADT的一般形式为</p><p><strong>CREATE</strong> <strong>TYPE</strong> <strong>&lt;**type_name**&gt;</strong> <strong>(</strong></p><p>所有属性名及其类型说明，</p><p><strong>[**定义该类型的等于＝和小于</strong>&lt;<strong>函数，</strong>]**</p><p>定义该类型其他函数**(<strong>方法</strong>));**</p></li></ul></li></ul></li></ul><ol><li>参照类型(Reference Type)</li></ol><ul><li><p>REF类型（参照类型、引用类型）</p><ul><li><p>引入的原因：</p><ul><li>类型之间可能具有相互参照的联系</li></ul></li><li><p>形式</p><ul><li>REF &lt;类型名&gt;</li></ul></li><li><p>特点：</p><ul><li>REF类型总是和某个特定的类型相联系。</li><li>它的值是OID</li></ul></li><li><p>创建两个表：Employee和Company，两表之间存在相互参照关系，即某个职工在某个公司工作</p><ul><li><p>(1)创建行类型</p></li><li><p>［例7］</p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> employee_type**(**</p><p>name <strong>VARCHAR(**35</strong>)**，</p><p>age <strong>INTEGER</strong> <strong>);</strong></p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Comp_type**(**</p><p>compname <strong>VARCHAR(**20</strong>)**，</p><p>location <strong>VARCHAR(**20</strong>)** <strong>);</strong></p></li><li><p>(2)创建基于行类型的表：</p><p><strong>CREATE</strong> <strong>TABLE</strong> Employee <strong>OF</strong> employee_type**;**</p><p><strong>CREATE</strong> <strong>TABLE</strong> Company <strong>OF</strong> Comp_type</p></li><li><p>(3)描述参照关系</p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Employment_type <strong>(</strong></p><p>employee <strong>REF</strong> <strong>(**employee_type</strong>)**，</p><p>company <strong>REF</strong> <strong>(**Comp_type</strong>)** <strong>);</strong></p><p><strong>CREATE</strong> <strong>TABLE</strong> Employment <strong>OF</strong> Employment _type</p></li><li><p>表Employment中某一个元组的employee属性值是某个职工的OID</p></li><li><p>company属性值是该职工所在公司的OID</p></li><li><p>［例8］</p><p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> employee_type**(**</p><p>name <strong>VARCHAR(**35</strong>)**，</p><p>age <strong>INTEGER</strong>，</p><p>emp_id <strong>REF(**employee_type</strong>)** <strong>);</strong></p></li><li><p>［例9］</p><p><strong>CREATE</strong> <strong>TABLE</strong> Employee <strong>OF</strong> employee_type</p><p><strong>VALUES</strong> <strong>FOR</strong> emp_id <strong>ARE</strong> SYSTEM GENERATED**;**</p></li></ul></li><li><p>建立参照属性：</p><p><strong>&lt;参照属性名&gt;［REF(&lt;类型名&gt;)］SCOPE IS &lt;关系名&gt;</strong></p><ul><li>［例10］</li></ul><p><strong>CREATE</strong> <strong>TABLE</strong> address_objtab <strong>OF</strong> address_objtyp <strong>;</strong></p><ul><li><p>［例11］</p><p><strong>CREATE</strong> <strong>TABLE</strong> people_reltab2 <strong>(</strong></p><p>id <strong>NUMBER(**4</strong>)** <strong>PRIMARY</strong> <strong>KEY</strong>，</p><p>name_obj name_objtyp，</p><p>addresss_ref <strong>REF(**address_objtyp</strong>)** <strong>SCOPE</strong> <strong>IS</strong> address_objtab <strong>)</strong></p></li><li><p>［例12］</p></li></ul><p><strong>CREATE</strong> <strong>INDEX</strong> address_ref_idx <strong>ON</strong> people_reltab2**(<strong>address_ref</strong>)** <strong>;</strong></p><ul><li><p>［例13］</p><p><strong>SELECT</strong> id</p><p><strong>FROM</strong> people_reltab2 p</p><p><strong>WHERE</strong> p**.<strong>address_ref</strong>.<strong>city</strong>=<strong>‘北京’ **and</strong></p><p>p**.<strong>address_ref</strong>.<strong>street</strong>=<strong>‘牛街’</strong>;**</p></li></ul></li><li></li></ul></li></ul><ol><li>继承性</li></ol><ul><li><p>ORDBMS应该支持继承性</p><ul><li><p>一般是单继承性</p><ul><li><p>［例14］</p><p><strong>CREATE</strong> <strong>TYPE</strong> emp_type</p><p><strong>UNDER</strong> person_type <strong>AS(</strong></p><p>emp_id <strong>INTEGER</strong>，</p><p>salary <strong>REAL</strong> <strong>)</strong></p><p><strong>NOT</strong> FINAL**;**</p></li><li><p>NOT FINAL：表示不是类层次结构中最后的”叶结点”</p></li><li><p>FINAL：该类型是类层次结构的叶结点</p></li></ul></li><li></li></ul></li></ul><ol><li>子表和超表</li></ol><ul><li><p>［例15］ 对于下面的类型层次，先定义这些类型TYPE，然后创建基于这些类型的表</p><p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230303162.png" alt="img"></p><p><strong>CREATE</strong> <strong>TYPE</strong> person /<em>创建person 类型，根类型</em>/</p><p><strong>(**id **INTEGER</strong>，</p><p>name <strong>VARCHAR(**20</strong>)**，</p><p>birthyear <strong>INTEGER</strong>，</p><p>address <strong>VARCHAR(**40</strong>))**</p><p><strong>NOT</strong> FINAL； /<em>NOT FINAL表示可以有子类型</em>/</p><p><strong>CREATE</strong> <strong>TYPE</strong> employee /<em>创建person的子类型employee</em>/</p><p><strong>UNDER</strong> person /<em>类型employee继承person的属性</em>/</p><p><strong>(**salary **INTEGER)</strong> /* employee定义自己的属性*/</p><p><strong>NOT</strong> FINAL；</p><p><strong>CREATE</strong> <strong>TYPE</strong> executive /<em>创建employee的子类型executive</em>/</p><p><strong>UNDER</strong> employee</p><p><strong>(**bonus **INTEGER)</strong></p><p>FINAL；</p><p><strong>CREATE</strong> <strong>TYPE</strong> student /*创建person的子类型student */</p><p><strong>UNDER</strong> person</p><p><strong>(**major **VARCHAR(**10</strong>)<strong>，wage **DECIMAL)</strong></p><p>FINAL</p></li><li><p>例16］Department类型和employee具有相互参照的联系，使用REF来表示这种联系</p><p><strong>CREATE</strong> <strong>TYPE</strong> department</p><p><strong>(**ID **INTEGER</strong>，</p><p>manager <strong>REF(**employee</strong>)**，</p><p>Budget <strong>INTEGER);</strong></p><p><strong>ALTER</strong> <strong>TYPE</strong> employee</p><p><strong>ADD</strong> ATTRIBUTE dept <strong>REF(**department</strong>);**</p></li><li><p>定义基于这些类型的基本表和表层次：</p><p><strong>CREATE</strong> <strong>TABLE</strong> person_table <strong>OF</strong> person</p><p><strong>(**name **WITH</strong> OPTIONS <strong>NOT</strong> <strong>NULL);</strong></p><p><strong>CREATE</strong> <strong>TABLE</strong> employee_table <strong>OF</strong> employee</p><p><strong>UNDER</strong> person_table**;**</p><p><strong>CREATE</strong> <strong>TABLE</strong> exec_table <strong>of</strong> executive</p><p><strong>UNDER</strong> employee_table</p><p><strong>CREATE</strong> <strong>TABLE</strong> student_table <strong>OF</strong> student</p><p><strong>UNDER</strong> person_table；</p><p><strong>CREATE</strong> <strong>TABLE</strong> dept_table <strong>OF</strong> department</p><p><strong>(**manager **SCOPE</strong> <strong>IS</strong> employee_table**);**</p><p><strong>ALTER</strong> <strong>TABLE</strong> employee_table</p><p><strong>ALTER</strong> <strong>COLUMN</strong> dept <strong>ADD</strong> <strong>SCOPE</strong> <strong>IS</strong> dept_table**;**</p></li><li><p>查询[例16]所创建的表</p><ul><li><p>［例17］</p><p><strong>SELECT</strong> name，address</p><p><strong>FROM</strong> person_table</p><p><strong>WHERE</strong> birthyear <strong>&lt;=**1970</strong>;**</p></li></ul></li><li><p>关闭子表的检索</p><ul><li><p>［例18］</p><p><strong>SELECT</strong> name，address</p><p><strong>FROM</strong> <strong>ONLY</strong> person_table</p><p><strong>WHERE</strong> birthyear <strong>&lt;=**1970</strong>;**</p></li><li><p>INSERT、DELETE、UPDATE对子表和超表的操作规则</p><ul><li>INSERT：向子表插入一行时一般会在该子表的超表上也插入一行。</li><li>DELETE：从表删除一行时一般会在该表的超表和子表上也删除相应的一行</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库系统的特点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数据结构化&lt;/li&gt;
&lt;li&gt;数据的</summary>
      
    
    
    
    <category term="数据库" scheme="https://rain-sky.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库原理" scheme="https://rain-sky.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://rain-sky.github.io/2021/01/12/Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://rain-sky.github.io/2021/01/12/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-01-12T09:39:46.000Z</published>
    <updated>2021-01-22T13:09:09.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java语法基础"><a href="#java语法基础" class="headerlink" title="java语法基础"></a>java语法基础</h1><p><strong>1，关键字</strong>：其实就是某种语言赋予了特殊含义的单词。</p><p>　　保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 </p><p><strong>2，标示符</strong>：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0—9、a—z、$、_ ；</p><p>　　注意：</p><p>　　　　①：数字不可以开头。</p><p>　　　　②：不可以使用关键字。</p><p><strong>3，常量</strong>：是在程序中的不会变化的数据。</p><p><strong>4，变量</strong>：其实就是内存中的一个存储空间，用于存储常量数据。</p><p>　　作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。</p><p>　　特点：变量空间可以重复使用。 </p><p>　　<strong>什么时候定义变量？</strong>只要是数据不确定的时候，就定义变量。</p><p>　　<strong>变量空间的开辟需要什么要素呢？</strong></p><p>　　　　①：这个空间要存储什么数据？数据类型。</p><p>　　　　②：这个空间叫什么名字啊？变量名称。</p><p>　　　　③：这个空间的第一次的数据是什么？ 变量的初始化值。</p><p>　　<strong>变量的作用域和生存期:</strong></p><p>　　　　变量的作用域：</p><p>  　　　　作用域从变量定义的位置开始，到该变量所在的那对大括号结束；</p><p>　　　　生命周期：</p><p>  　　　　变量从定义的位置开始就在内存中活了；</p><p>  　　　　变量到达它所在的作用域的时候就在内存中消失了；</p><p>　　<strong>数据类型：</strong></p><p>　　　　①：基本数据类型：byte、short、int、long、float、double、char、boolean </p><p>　　　　②：引用数据类型: 数组、类、接口。</p><p>　　　　<strong>级别从低到高为</strong>：byte,char,short(这三个平级)——&gt;int——&gt;float——&gt;long——&gt;double</p><p>　　　　<strong>自动类型转换</strong>：从低级别到高级别，系统自动转的；</p><p>　　　　<strong>强制类型转换</strong>：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；</p><p>　　<strong>运算符号：</strong></p><p>　　　　①、算术运算符。</p><p>　　　　　　+ — * / %  </p><p>　　　　　　%:任何整数<strong>模2</strong>不是0就是1，所以只要改变被模数就可以实现开关运算。</p><p>　　　　　　+:连接符。</p><p>　　　　　　++,——</p><p>　　　　②、赋值运算符。</p><p>　　　　　　=  += —= *= /= %=</p><p>　　　　③、比较运算符。</p><p>　　　　　　特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 </p><p>　　　　④、逻辑运算符。</p><p>　　　　　　&amp;  |  ^  !   &amp;&amp;   ||</p><p>　　　　　　逻辑运算符除了 <strong>!</strong> 外都是用于连接两个boolean类型表达式。</p><p>　　　　　　&amp;: 只有两边都为true结果是true。否则就是false。</p><p>　　　　　　|:只要两边都为false结果是false，否则就是true</p><p>　　　　　　^:异或：和或有点不一样。</p><p> 　　　　　　　两边结果一样，就为false。</p><p> 　　　　　　　两边结果不一样，就为true.</p><p>　　　　　　<strong>&amp; 和 &amp;&amp;区别</strong>： &amp; ：无论左边结果是什么，右边都参与运算。</p><p> 　　　　　　　　　　　　　&amp;&amp;:短路与，如果左边为false，那么右边不参数与运算。</p><p>　　　　　　<strong>| 和|| 区别</strong>： |：两边都运算。</p><p>　　　　　　　　　　　　　||：短路或，如果左边为true，那么右边不参与运算。</p><p>　　　　⑤、位运算符:用于操作二进制位的运算符。</p><p>　　　　　　&amp; | ^ </p><p>　　　　　　&lt;&lt; &gt;&gt;  &gt;&gt;&gt;(无符号右移)</p><p>　　　　<strong>练习：对两个变量的数据进行互换。不需要第三方变量。</strong></p><p>　　　　int a = 3,b = 5;//——&gt;b = 3,a = 5;</p><p>　　　　a = a + b; a = 8;</p><p>　　　　b = a — b; b = 3;</p><p>　　　　a = a — b; a = 5;</p><p>　　　　a = a ^ b;//</p><p>　　　　b = a ^ b;//b = a ^ b ^ b = a</p><p>　　　　a = a ^ b;//a = a ^ b ^ a = b;</p><p>　　　　<strong>练习：高效的算出 2*8 = 2&lt;&lt;3;</strong></p><p><strong>5，语句。</strong></p><p>　　If  　 switch 　　do while 　 while 　 for </p><p>　　这些语句什么时候用？</p><p>　　1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。</p><p>　　　　但是建议使用switch，效率相对较高。</p><p>　　　　switch(变量){</p><p>　　　　　　case 值:要执行的语句;break;</p><p>　　　　　　…</p><p>　　　　　　default:要执行的语句;</p><p>　　　　}</p><p>　　　　工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了</p><p>　　　　　　　　　就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；</p><p>　　　　细节：①：break是可以省略的，如果省略了就一直执行到遇到break为止；</p><p>　　　　　　　②、switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；</p><p>　　　　　　　③、default可以写在switch结构中的任意位置；<strong>如果将default语句放在了第一行，</strong></p><p>　　　　　　　　<strong>则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。</strong></p><p>　　2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。</p><p>　　3）、当某些语句需要执行很多次时，就用循环结构。</p><p>　　while和for可以进行互换。</p><p>　　　　区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。</p><p>　　<strong>break</strong>:作用于switch ，和循环语句，用于跳出，或者称为结束。</p><p>　　break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。</p><p>　　<strong>continue</strong>:只作用于循环结构，继续循环用的。</p><p>　　作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。</p><p><strong>6，函 数</strong>：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。</p><p>　　<strong>java中的函数的定义格式：</strong></p><p>　　<strong>修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){</strong></p><p>　　　　<strong>执行语句；</strong></p><p>　　　　<strong>return 返回值；</strong></p><p>　　<strong>}</strong></p><p>　　当函数没有具体的返回值时，返回的返回值类型用void关键字表示。</p><p>　　如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。</p><p>　　<strong>return的作用</strong>：结束函数。结束功能。</p><p>　　<strong>如何定义一个函数？</strong></p><p>　　　　函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：</p><p>　　　　　　①、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。</p><p>　　　　　　②、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。</p><p>　　<strong>函数的作用：</strong></p><p>　　　　1）、用于定义功能。</p><p>　　　　2）、用于封装代码提高代码的复用性。</p><p>　　　　注意：函数中只能调用函数，不能定义函数。</p><p>　　<strong>主函数：</strong></p><p>　　　　1）、保证该类的独立运行。</p><p>　　　　2）、因为它是程序的入口。</p><p>　　　　3）、因为它在被jvm调用。</p><p>　　<strong>函数定义名称是为什么呢？</strong></p><p>　　　　答：1）、为了对该功能进行标示，方便于调用。</p><p>　　　　　　2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。</p><p>　　<strong>重载</strong>的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。</p><p>　　<strong>如何区分重载</strong>：当函数同名时，只看参数列表。和返回值类型没关系。</p><p><strong>7，数 组</strong>：用于存储同一类型数据的一个容器。</p><p>　　<strong>好处</strong>：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。</p><p>　　如何在java中表现一个数组呢？两种表现形式。</p><p>　　　　1）、元素类型[] 变量名 = new 元素类型[元素的个数]；</p><p>　　　　2）、元素类型[] 变量名 = {元素1，元素2…}；</p><p>　　　　　　元素类型[] 变量名 = new 元素类型[]{元素1，元素2…}；</p><p>——————————————————————————————————————————————————————</p><p>　　　　<strong>//二分查找法。必须有前提：数组中的元素要有序。</strong> </p><p>　　　　public static int halfSeach_2(int[] arr,int key){</p><p>　　　　　　int min,max,mid;</p><p>　　　　　　min = 0;</p><p>　　　　　　max = arr.length—1;</p><p>　　　　　　mid = (max+min)&gt;&gt;1; //(max+min)/2;</p><p>　　　　　　while(arr[mid]!=key){</p><p>　　　　　　if(key&gt;arr[mid]){</p><p>　　　　　　　　min = mid + 1;</p><p>　　　　　　}</p><p>　　　　　　else if(key&lt;arr[mid])</p><p>　　　　　　　　max = mid — 1;</p><p>　　　　　　　　if(max&lt;min)</p><p>　　　　　　　　return —1;</p><p>　　　　　　　　mid = (max+min)&gt;&gt;1;</p><p>　　　　　　}</p><p>　　　　　　return mid;</p><p>　　　　}</p><p>——————————————————————————————————————————————————————</p><p><strong>java分了5片内存。</strong></p><p>　　1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。</p><p>　　<strong>栈</strong>：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；</p><p>　　　　只要数据运算完成所在的区域结束，该数据就会被释放。</p><p>　　<strong>堆</strong>：用于存储数组和对象，也就是<strong>实体</strong>。啥是实体啊？就是用于封装多个数据的。</p><p>　　　　1：每一个实体都有内存首地址值。</p><p>　　　　2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 </p><p>　　　　3：垃圾回收机制。</p><p>——————————————————————————————————————————————————————</p><p><strong>三：面向对象：★★★★★</strong></p><p>　　<strong>特点：1：将复杂的事情简单化。</strong></p><p>　　　　　<strong>2：面向对象将以前的过程中的执行者，变成了指挥者。</strong></p><p>　　　　　<strong>3：面向对象这种思想是符合现在人们思考习惯的一种思想。</strong></p><p>　　过程和对象在我们的程序中是如何体现的呢？</p><p>　　　　<strong>过程</strong>其实就是函数；</p><p>　　　　<strong>对象</strong>是将函数等一些内容进行了封装。</p><p>　　<strong>匿名对象使用场景：</strong></p><p>　　　　1：当对方法只进行一次调用的时候，可以使用匿名对象。</p><p>　　　　2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。</p><p>　　在类中定义其实都称之为成员。成员有两种：</p><p>　　　　1：<strong>成员变量</strong>：其实对应的就是事物的属性。</p><p>　　　　2：<strong>成员函数</strong>：其实对应的就是事物的行为。</p><p>　　所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。</p><p>　　private int age;<strong>//私有的访问权限最低，只有在本类中的访问有效。</strong></p><p>　　注意：私有仅仅是封装的一种体现形式而已。</p><p>　　<strong>私有的成员</strong>：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，</p><p>　　　　　　　　 可以通过对外提供函数的形式对其进行访问。</p><p>　　<strong>好处</strong>：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。</p><p>　　总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。</p><p>这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。</p><p>　　类中怎么没有定义主函数呢？</p><p>　　　　<strong>注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。</strong></p><p>　　　　<strong>主函数的解释</strong>：保证所在类的独立运行，是程序的入口，被jvm调用。</p><p>　　<strong>成员变量和局部变量的区别：</strong></p><p>　　　　<strong>1：成员变量直接定义在类中。</strong></p><p>  　　　<strong>局部变量定义在方法中，参数上，语句中。</strong></p><p>　　　　<strong>2：成员变量在这个类中有效。</strong></p><p>　　　　　　<strong>局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。</strong></p><p>　　　　<strong>3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。</strong></p><p>　　　　　　<strong>局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。</strong></p><p>　　<strong>构造函数</strong>：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。</p><p>　　　　特点：</p><p>　　　　　　1：该函数的名称和所在类的名称相同。</p><p>　　　　　　2：不需要定义返回值类型。</p><p>　　　　　　3：该函数没有具体的返回值。</p><p>　　　　<strong>记住：所有对象创建时，都需要初始化才可以使用。</strong></p><p>　　　　<strong>注意事项</strong>：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，</p><p>　　　　　　　　为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。</p><p>　　　　一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。<strong>所以，</strong></p><p>　　　　<strong>一个类中如果出现多个构造函数。它们的存在是以重载体现的。</strong></p><p>　　<strong>构造函数和一般函数有什么区别呢？</strong></p><p>　　　　1：两个函数定义格式不同。</p><p>　　　　2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。</p><p>　　　　　　一般函数，是对象创建后，需要调用才执行，可以被调用多次。</p><p>　　<strong>什么时候使用构造函数呢？</strong></p><p>　　　　分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。</p><p>　　<strong>构造代码块和构造函数有什么区别？</strong></p><p>　　　　构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。</p><p>　　　　构造函数：是给与之对应的对象进行初始化。它具有针对性。</p><p>　　<strong>Person p = new Person();</strong></p><p>　　<strong>创建一个对象都在内存中做了什么事情？</strong></p><p>　　　　1：先将硬盘上指定位置的Person.class文件加载进内存。</p><p>　　　　2：执行main方法时，在栈内存中开辟了main方法的空间(压栈—进栈)，然后在main方法的栈区分配了一个变量p。</p><p>　　　　3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</p><p>　　　　4：在该实体空间中进行属性的空间分配，并进行了默认初始化。</p><p>　　　　5：对空间中的属性进行显示初始化。</p><p>　　　　6：进行实体的构造代码块初始化。</p><p>　　　　7：调用该实体对应的构造函数，进行构造函数初始化。（）</p><p>　　　　8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</p><p>——————————————————————————————————————————————————————</p><p><strong>封 装**</strong>（面向对象特征之一）**：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p><p>　　<strong>好处</strong>：将变化隔离；便于使用；提高重用性；安全性。</p><p>　　<strong>封装原则</strong>：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。</p><p>　　this:代表对象。就是所在函数所属对象的引用。</p><p>　　　　this到底代表什么呢？<strong>哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。</strong></p><p>　　　　开发时，什么时候使用this呢？</p><p>　　　　在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。</p><p>　　　　this 还可以用于构造函数间的调用。</p><p>　　　　<strong>调用格式：this(实际参数)；</strong></p><p>　　　　this对象后面跟上 <strong>.</strong> 调用的是成员属性和成员方法(一般方法)；</p><p>　　　　this对象后面跟上 <strong>()</strong> 调用的是本类中的对应参数的构造函数。</p><p>　　　　<strong>注意：用this调用构造函数，必须定义在构造函数的第一行。</strong></p><p>　　<strong>因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。</strong></p><p>　　<strong>static</strong>：★★★ 关键字，<strong>是一个修饰符，用于修饰成员(成员变量和成员函数)。</strong></p><p>　　特点：</p><p>　　　　<strong>1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。</strong></p><p>　　　　<strong>2，被静态修饰的成员，可以直接被类名所调用。</strong>也就是说，静态的成员多了一种调用方式。类名.静态方式。</p><p>　　　　<strong>3，静态随着类的加载而加载。而且优先于对象存在。</strong></p><p>　　<strong>弊端：</strong></p><p>　　　　1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。</p><p>　　　　2，<strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p><p>　　　　　　因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。</p><p>　　　　3，<strong>静态方法中不能使用this，super关键字</strong>。</p><p>　　　　　　因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p><p>　　　　4，主函数是静态的。</p><p>　　<strong>什么时候定义静态成员呢？</strong>或者说：定义成员时，到底需不需要被静态修饰呢？</p><p>　　成员分两种：</p><p>　　　　<strong>1，成员变量。（数据共享时静态化）</strong></p><p>　　　　　　<strong>该成员变量的数据是否是所有对象都一样：</strong></p><p>　　　　　　如果是，那么该变量需要被静态修饰，因为是共享的数据。 </p><p>　　　　　　如果不是，那么就说这是对象的特有数据，要存储到对象中。 </p><p>　　　　<strong>2，成员函数。（方法中没有调用特有数据时就定义成静态）</strong></p><p>　　　　　　如果判断成员函数是否需要被静态修饰呢？</p><p>　　　　　　只要参考，该函数内是否访问了对象中的特有数据：</p><p>　　　　　　如果有访问特有数据，那方法不能被静态修饰。</p><p>　　　　　　如果没有访问过特有数据，那么这个方法需要被静态修饰。</p><p>　　<strong>成员变量和静态变量的区别：</strong></p><p>　　　　1，成员变量所属于对象。所以也称为实例变量。</p><p>　　　　　　静态变量所属于类。所以也称为类变量。</p><p>　　　　2，成员变量存在于堆内存中。</p><p>　　　　　　静态变量存在于方法区中。</p><p>　　　　3，成员变量随着对象创建而存在。随着对象被回收而消失。</p><p>　　　　　　静态变量随着类的加载而存在。随着类的消失而消失。</p><p>　　　　4，成员变量只能被对象所调用 。</p><p>　　　　　　静态变量可以被对象调用，也可以被类名调用。</p><p>　　　　<strong>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</strong></p><p>　　<strong>静态的注意：静态的生命周期很长。</strong></p><p>　　<strong>静态代码块：</strong>就是一个有静态关键字标示的一个代码块区域。定义在类中。</p><p>　　<strong>作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。</strong></p><p>　　<strong>Public</strong>：访问权限最大。</p><p>　　<strong>static</strong>：不需要对象，直接类名即可。</p><p>　　<strong>void</strong>：主函数没有返回值。</p><p>　　<strong>Main</strong>：主函数特定的名称。</p><p>　　**(String[] args)**：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。</p><p>　　jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。</p><p>　　<strong>静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 ———&gt; 构造代码块 ———&gt; 构造函数；</strong></p><p>　　<strong>生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java</strong></p><p>　　 //格式</p><p>　　　　/**  </p><p>　　　　　*类描述</p><p>　　　　　*@author 作者名</p><p>　　　　　*@version 版本号</p><p>　　　　　*/</p><p>　　　　/**</p><p>　　　　　*方法描述</p><p>　　　　　*@param 参数描述</p><p>　　　　　*@return 返回值描述</p><p>　　　　　*/</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>设计模式</strong>：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><p>java中有23种设计模式：</p><p><strong>单例设计模式：★★★★★</strong></p><p>　　解决的问题：<strong>保证一个类在内存中的对象唯一性。</strong></p><p>　　比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。</p><p>　　<strong>Runtime()方法就是单例设计模式进行设计的。</strong></p><p>　　<strong>如何保证对象唯一性呢？</strong></p><p>　　思想：</p><p>　　　　1，不让其他程序创建该类对象。</p><p>　　　　2，在本类中创建一个本类对象。</p><p>　　　　3，对外提供方法，让其他程序获取这个对象。</p><p>　　<strong>步骤：</strong></p><p>　　　　<strong>1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；</strong></p><p>　　　　<strong>2，就在类中创建一个本类的对象；</strong></p><p>　　　　<strong>3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）</strong></p><p>　　<strong>代码体现：</strong></p><p>　　　　<strong>1，私有化构造函数；</strong></p><p>　　　　<strong>2，创建私有并静态的本类对象；</strong></p><p>　　　　<strong>3，定义公有并静态的方法，返回该对象。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>饿汉式</strong></p><p>　　class Single{</p><p>　　　　private Single(){}  //<strong>私有化构造函数。</strong></p><p>　　　　private static Single s = new Single(); //<strong>创建私有并静态的本类对象。</strong></p><p>　　　　public static Single getInstance(){  //<strong>定义公有并静态的方法，返回该对象。</strong></p><p>　　　　　　return s;</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>懒汉式</strong>:延迟加载方式。</p><p>　　class Single2{</p><p>　　　　private Single2(){}</p><p>　　　　private static Single2 s = null;</p><p>　　　　public static Single2 getInstance(){</p><p>　　　　　　if(s==null)</p><p>　　　　　　s = new Single2();</p><p>　　　　　　return s;</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p><strong>继 承（面向对象特征之一）</strong></p><p>　　<strong>好处：</strong></p><p>　　　　<strong>1：提高了代码的复用性。</strong></p><p>　　　　<strong>2：让类与类之间产生了关系，提供了另一个特征多态的前提。</strong></p><p>　　父类的由来：其实是由多个类不断向上抽取共性内容而来的。</p><p>　　java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。</p><p>　　单继承：一个类只能有一个父类。</p><p>　　多继承：一个类可以有多个父类。</p><p>　　<strong>为什么不支持多继承呢？</strong></p><p>　　因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。</p><p>　　但是java支持多重继承。A继承B B继承C C继承D。</p><p>　　多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。</p><p>　　所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。</p><p>　　<strong>简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。</strong> </p><p>　　<strong>子父类出现后，类中的成员都有了哪些特点：</strong></p><p>　　<strong>1：成员变量。</strong></p><p> 　　　当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。</p><p> 　　　如果想要调用父类中的属性值，需要使用一个关键字：<strong>super</strong> </p><p> 　　　<strong>This</strong>：<strong>代表是本类类型的对象引用。</strong></p><p> 　　　<strong>Super</strong>：<strong>代表是子类所属的父类中的内存空间引用。</strong></p><p> 　　　注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。</p><p>　　<strong>2：成员函数。</strong></p><p>　　　　当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：<strong>覆盖(复写，重写)</strong></p><p>　　　　<strong>什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。</strong></p><p>　　<strong>3：构造函数。</strong></p><p>　　　　发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?</p><p>　　　　原因：<strong>子类的所有构造函数中的第一行，其实都有一条隐身的语句super();</strong></p><p>　　　　<strong>super():</strong> 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。</p><p>　　　　为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)</p><p>　　　　　　因为子类继承父类，会继承到父类中的数据，必须要看父类是如何对自己的数据进行初始化的。</p><p>　　　　　　所以子类在进行对象初始化时，先调用父类的构造函数，这就是<strong>子类的实例化过程。</strong></p><p>　　<strong>注意：</strong></p><p>　　<strong>子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</strong> </p><p>　　<strong>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</strong></p><p>　　<strong>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</strong></p><p>　　<strong>问题：super()和this()是否可以同时出现的构造函数中。</strong></p><p>　　两个语句只能有一个定义在第一行，所以只能出现其中一个。</p><p>　　<strong>super()或者this():为什么一定要定义在第一行？</strong></p><p>　　因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。</p><p>　　<strong>继承的细节</strong>：</p><p>　　　　<strong>什么时候使用继承呢？</strong></p><p>　　　　当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。</p><p>　　　　英文书中，所属关系：” is a “</p><p>　　　　　　注意：不要仅仅为了获取其他类中的已有成员进行继承。</p><p>　　　　<strong>所以判断所属关系，可以简单看，</strong></p><p>　　　　<strong>如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。</strong></p><p>　　细节二：</p><p>　　　　<strong>在方法覆盖时，注意两点：</strong></p><p>　　　　　　1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。</p><p>　　　　　　2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)</p><p>　　继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p><p>　　这时如何解决问题呢？介绍一个关键字，final:最终。</p><p>　　<strong>final特点：</strong></p><p>　　　　1：这个关键字是一个修饰符，可以修饰类，方法，变量。</p><p>　　　　2：被final修饰的类是一个最终类，不可以被继承。</p><p>　　　　3：被final修饰的方法是一个最终方法，不可以被覆盖。</p><p>　　　　4：被final修饰的变量是一个常量，只能赋值一次。</p><p>　　其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。</p><p>　　不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p><p><strong>抽象类</strong>: abstract</p><p>　　抽象：不具体，看不明白。抽象类表象体现。</p><p>　　在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。</p><p>　　抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。</p><p>　　<strong>抽象类的特点：</strong></p><p>　　　　1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。</p><p>　　　　2：抽象方法只定义方法声明，并不定义方法实现。</p><p>　　　　3：抽象类不可以被创建对象(实例化)。</p><p>　　　　4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</p><p>　　<strong>抽象类的细节：</strong></p><p>　　　　<strong>1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。</strong></p><p>　　　　<strong>2：抽象类中是否可以定义非抽象方法？</strong></p><p>　　　　　　可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。</p><p>　　　　<strong>3：抽象关键字abstract和哪些不可以共存？final , private , static</strong> </p><p>　　　　<strong>4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</strong></p><p>——————————————————————————————————————————————————————</p><p><strong>模板方法设计模式：</strong></p><p>　　解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><p>　　abstract class GetTime{</p><p>　　　　public <strong>final</strong> void getTime(){ 　<strong>//此功能如果不需要复写，可加final限定</strong></p><p>　　　　　　long start = System.currentTimeMillis();</p><p>　　　　　　code(); 　<strong>//不确定的功能部分，提取出来，通过抽象方法实现</strong></p><p>　　　　　　long end = System.currentTimeMillis();</p><p>　　　　　　System.out.println(“毫秒是：”+(end—start));</p><p>　　　　}</p><p>　　　　public <strong>abstract</strong> void code(); 　<strong>//抽象不确定的功能，让子类复写实现</strong></p><p>　　}</p><p>　　class SubDemo extends GetTime{</p><p>　　　　public void code(){ 　<strong>//子类复写功能方法</strong></p><p>　　　　　　for(int y=0; y&lt;1000; y++){</p><p>　　　　　　　　System.out.println(“y”);</p><p>　　　　　　}</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p><strong>接 口：★★★★★</strong></p><p>　　1：是用关键字interface定义的。</p><p>　　2：接口中包含的成员，最常见的有全局常量、抽象方法。</p><p>　　　　注意：接口中的成员都有固定的修饰符。</p><p>　　　　<strong>成员变量：public static final</strong> </p><p>　　　　<strong>成员方法：public abstract</strong> </p><p>　　　　<strong>interface</strong> Inter{</p><p>　　　　　　<strong>public static final</strong> int x = 3;</p><p>　　　　　　<strong>public abstract</strong> void show();</p><p>　　　　}</p><p>　　3：接口中有抽象方法，说明<strong>接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</strong></p><p>　　4：类与类之间存在着继承关系，类与接口中间存在的是<strong>实现</strong>关系。</p><p>　　　　<strong>继承用extends ；实现用implements ；</strong></p><p>　　5：接口和类不一样的地方，就是，<strong>接口可以被多实现</strong>，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。 </p><p>　　6：一个类在继承另一个类的同时，还可以实现多个接口。所以<strong>接口的出现避免了单继承的局限性</strong>。还可以将类进行功能的扩展。</p><p>　　7：其实java中是有多继承的。接口与接口之间存在着继承关系，<strong>接口可以多继承接口</strong>。</p><p>　　<strong>接口都用于设计上，设计上的特点</strong>：（可以理解主板上提供的接口）</p><p>　　　　<strong>1：接口是对外提供的规则。</strong></p><p>　　　　<strong>2：接口是功能的扩展。</strong></p><p>　　　　<strong>3：接口的出现降低了耦合性</strong>。</p><p>　　<strong>抽象类与接口：</strong></p><p>　　<strong>抽象类</strong>：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。</p><p>　　<strong>接口</strong>：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。</p><p>　　<strong>抽象类和接口的共性</strong>：都是不断向上抽取的结果。</p><p>　　<strong>抽象类和接口的区别：</strong></p><p>　　　　<strong>1：抽象类只能被继承，而且只能单继承。</strong></p><p>　　　　　　<strong>接口需要被实现，而且可以多实现。</strong> </p><p>　　　　<strong>2：抽象类中可以定义非抽象方法，子类可以直接继承使用。</strong></p><p>　　　　　　<strong>接口中都有抽象方法，需要子类去实现。</strong></p><p>　　　　<strong>3：抽象类使用的是 is a 关系。</strong></p><p>　　　　　　<strong>接口使用的 like a 关系。</strong> </p><p>　　　　<strong>4：抽象类的成员修饰符可以自定义。</strong></p><p>　　　　　　<strong>接口中的成员修饰符是固定的。全都是public的。</strong></p><p>　　在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。 </p><p>——————————————————————————————————————————————————————</p><p><strong>多 态★★★★★（面向对象特征之一）</strong>：函数本身就具备多态性，某一种事物有不同的具体的体现。</p><p>　　<strong>体现</strong>：<strong>父类引用或者接口的引用指向了自己的子类对象</strong>。//Animal a = new Cat();</p><p>　　<strong>多态的好处</strong>：<strong>提高了程序的扩展性。</strong></p><p>　　<strong>多态的弊端</strong>：<strong>当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法</strong>。(前期不能使用后期产生的功能，即访问的局限性)</p><p>　　<strong>多态的前提：</strong></p><p>　　　　<strong>1：必须要有关系，比如继承、或者实现。</strong></p><p>　　　　<strong>2：通常会有覆盖操作。</strong></p><p>　　<strong>多态的出现思想上也做着变化</strong>：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。</p><p>——————————————————————————————————————————————————————</p><p>　　class 毕姥爷{</p><p>　　　　void 讲课(){</p><p>　　　　　　System.out.println(“企业管理”);</p><p>　　　　}</p><p>　　　　void 钓鱼(){</p><p>　　　　　　System.out.println(“钓鱼”);</p><p>　　　　}</p><p>　　}</p><p>　　class 毕老师 extends 毕姥爷{</p><p>　　　　void 讲课(){</p><p>　　　　　　System.out.println(“JAVA”);</p><p>　　　　}</p><p>　　　　void 看电影(){</p><p>　　　　　　System.out.println(“看电影”);</p><p>　　　　}</p><p>　　}</p><p>　　class {</p><p>　　　　public static void main(String[] args) {</p><p>　　　　　　毕姥爷 x = new 毕老师(); <strong>//毕老师对象被提升为了毕姥爷类型。</strong> </p><p>　　　　　　// x.讲课();</p><p>　　　　　　// x.看电影(); <strong>//错误.</strong></p><p>　　　　　　毕老师 y = (毕老师)x; <strong>//将毕姥爷类型强制转换成毕老师类型。</strong> </p><p>　　　　　　y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？</strong></p><p>　　　　可以可以通过一个关键字 <strong>instanceof</strong> <strong>;//判断对象是否实现了指定的接口或继承了指定的类</strong></p><p>　　格式：&lt;**对象 instanceof 类型**&gt; ，判断一个对象是否所属于指定的类型。</p><p>　　Student instanceof Person = true;//student继承了person类</p><p>　　<strong>多态在子父类中的成员上的体现的特点：</strong></p><p>　　　　<strong>1，成员变量</strong>：在多态中，子父类成员变量同名。</p><p>　　　　　　在编译时期：参考的是<strong>引用型变量所属的类</strong>中是否有调用的成员。<strong>（编译时不产生对象，只检查语法错误）</strong></p><p>　　　　　　运行时期：也是参考<strong>引用型变量所属的类</strong>中是否有调用的成员。</p><p>　　　　　　<strong>简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。</strong></p><p>　　　　　　再说的更容易记忆一些：<strong>成员变量 ——— 编译运行都看 = 左边。</strong></p><p>　　<strong>2，成员函数。</strong></p><p>　　　　编译时期：参考引用型变量所属的类中是否有调用的方法。</p><p>　　　　运行事情：参考的是对象所属的类中是否有调用的方法。</p><p>　　　　为什么是这样的呢？<strong>因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。</strong></p><p>　　　　简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。</p><p>　　　　更简单：<strong>成员函数 ——— 编译看 = 左边，运行看 = 右边。</strong></p><p>　　<strong>3，静态函数。</strong> </p><p>　　　　编译时期：参考的是引用型变量所属的类中是否有调用的成员。</p><p>　　　　运行时期：也是参考引用型变量所属的类中是否有调用的成员。</p><p>　　　　为什么是这样的呢？<strong>因为静态方法，其实不所属于对象，而是所属于该方法所在的类。</strong></p><p>　　　　调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。</p><p>　　　　简单说：<strong>静态函数 ——— 编译运行都看 = 左边。</strong></p><p>——————————————————————————————————————————————————————</p><p>——————java.lang.Object</p><p>　　<strong>Object</strong>：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。</p><p><strong>具体方法：</strong></p><p>　　<strong>1，boolean equals(Object obj)**：用于比较两个对象是否相等，</strong>其实内部比较的就是两个对象地址。**</p><p>　　而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。</p><p>　　public boolean equals(Object obj){</p><p>　　　　if(!(obj instanceof Person))</p><p>　　　　return false;</p><p>　　　　Person p = (Person)obj;</p><p>　　　　return this.age == p.age;</p><p>　　}</p><p>　　**2，String toString()**：将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + ‘@’ + Integer.toHexString(hashCode())</p><p>　　为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。 </p><p>　　public String toString(){</p><p>　　　　return “person : “+age;</p><p>　　}</p><p>　　**3，Class getClass()**：获取任意对象运行时的所属字节码文件对象。</p><p>　　**4，int hashCode()**：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。</p><p>　　<strong>通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>内部类：</strong>如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。</p><p>——————————————————————————————————————————————————————</p><p>class Outer{</p><p>　　int num = 4;</p><p>　　class Inner {</p><p>　　　　void show(){</p><p>　　　　　　System.out.println(“inner show run “+num);</p><p>　　　　}</p><p>　　}</p><p>　　public void method(){</p><p>　　Inner in = new Inner();//创建内部类的对象。</p><p>　　in.show();//调用内部类的方法。 </p><p>　　}</p><p>}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。</strong></p><p>　　1：默认修饰符。</p><p>　　　　<strong>直接访问内部类格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象;</strong></p><p>　　　　<strong>Outer.Inner in = new Outer.new Inner();//这种形式很少用。</strong></p><p>　　　　但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。<strong>想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。</strong></p><p>　　2：私有修饰符。</p><p>　　　　通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 </p><p>　　3：静态修饰符。</p><p>　　　　<strong>如果内部类被静态修饰，相当于外部类</strong>，会出现访问局限性，只能访问外部类中的静态成员。</p><p>　　　　注意；<strong>如果内部类中定义了静态成员，那么该内部类必须是静态的。</strong></p><p>　　<strong>内部类编译后的文件名为：“外部类名$内部类名.java”；</strong></p><p>　　<strong>为什么内部类可以直接访问外部类中的成员呢？</strong></p><p>　　　　那是因为内部中都持有一个外部类的引用。这个是引用是 <strong>外部类名.this</strong> </p><p>　　　　内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。</p><p>　　　　<strong>当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。</strong></p><p>　　<strong>匿名内部类</strong>：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。<strong>想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。</strong></p><p>　　<strong>匿名内部类的格式</strong>：new 父类名&amp;接口名(){ 定义子类成员或者覆盖父类方法 }.方法。</p><p>　　<strong>匿名内部类的使用场景：</strong></p><p>　　　　当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。</p><p>　　　　其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。</p><p>——————————————————————————————————————————————————————</p><p>//面试</p><p>　　　　<strong>//1</strong></p><p>　　　　new Object(){</p><p>　　　　　　void show(){</p><p>　　　　　　　　System.out.println(“show run”);</p><p>　　　　　　}</p><p>　　　　}<strong>.show();</strong></p><p>　　　　<strong>//2</strong></p><p>　　　　Object obj = new Object(){</p><p>　　　　　　void show(){</p><p>　　　　　　　　System.out.println(“show run”);</p><p>　　　　　　}</p><p>　　　　};</p><p>　　　　<strong>obj.show();</strong></p><p>　　　　1和2的写法正确吗？有区别吗？说出原因。</p><p>　　　　写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。</p><p>　　　　区别：</p><p>　　　　　　第一个可是编译通过，并运行。</p><p>　　　　　　第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了</p><p>　　　　　　Object类型，而编译时检查Object类中是否有show方法，所以编译失败。</p><p>——————————————————————————————————————————————————————</p><p>　　class InnerClassDemo6 {</p><p>　　　　<strong>+（static）</strong>class Inner{</p><p>　　　　　　void show(){}</p><p>　　　　}</p><p>　　　　public void method(){</p><p>　　　　　　**this.**new Inner().show();//可以</p><p>　　　　}</p><p>　　　　public static void main(String[] args) {//static不允许this</p><p>　　　　　　This.new Inner().show();//错误，Inner类需要定义成static</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　interface Inter{</p><p>　　　　void show();</p><p>　　}</p><p>　　class Outer{//通过匿名内部类补足Outer类中的代码。</p><p>　　　　public static Inter method(){</p><p>　　　　　　return new Inter(){</p><p>　　　　　　　　public void show(){}</p><p>　　　　　　};</p><p>　　　　}</p><p>　　}</p><p>　　class InnerClassDemo7 {</p><p>　　　　public static void main(String[] args) {</p><p>　　　　　　<strong>Outer.method().show();</strong></p><p>/*</p><p>　　Outer.method():意思是：Outer中有一个名称为method的方法，而且这个方法是静态的。</p><p>　　Outer.method().show():当Outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是Inter类型的。</p><p>*/</p><p>　　　　　　function (new Inter(){</p><p>　　　　　　　　public void show(){}</p><p>　　　　　　}); //匿名内部类作为方法的参数进行传递。</p><p>　　　　}</p><p>　　　　public static void function(Inter in){</p><p>　　　　　　in.show();</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p><strong>异 常：★★★★</strong></p><p>　　异常：就是不正常。程序在运行时出现的不正常情况。其实就是程序中出现的问题。这个问题按照面向对象思想进行描述，并封装成了对象。因为问题的产生有产生的原因、有问题的名称、有问题的描述等多个属性信息存在。当出现多属性信息最方便的方式就是将这些信息进行封装。异常就是java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。</p><p>　　出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了<strong>异常体系</strong>。 </p><p>　　————————java.lang.Throwable：</p><p>　　<strong>Throwable：</strong>可抛出的。 </p><p>　　　　<strong>|——Error</strong>：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。</p><p>　　　　<strong>|——Exception</strong>：异常，可以有针对性的处理方式</p><p>　　无论是错误还是异常，它们都有具体的子类体现每一个问题，它们的子类都有一个共性，就是都<strong>以父类名才作为子类的后缀名。</strong></p><p>　　<strong>这个体系中的所有类和对象都具备一个独有的特点</strong>；<strong>就是可抛性</strong>。</p><p>　　<strong>可抛性的体现</strong>：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。</p><p>——————————————————————————————————————————————————————</p><p>　　class ExceptionDemo{</p><p>　　　　public static void main(String[] args) {</p><p>　　　　　　// byte[] buf = new byte[1024<em>1024</em>700];//java.lang.OutOfMemoryError内存溢出错误</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　在开发时，如果定义功能时，发现该功能会出现一些问题，应该<strong>将问题在定义功能时标示出来</strong>，这样调用者就可以在使用这个功能的时候，预先给出处理方式。</p><p>　　如何标示呢？通过throws关键字完成，<strong>格式：throws 异常类名,异常类名…</strong></p><p>　　这样标示后，调用者，在使用该功能时，就必须要处理，否则编译失败。</p><p>　　<strong>处理方式有两种：1、捕捉；2、抛出。</strong></p><p>　　对于捕捉：java有针对性的语句块进行处理。</p><p>　　<strong>try {</strong></p><p>　　　　<strong>需要被检测的代码；</strong></p><p>　　<strong>}</strong></p><p>　　<strong>catch(异常类 变量名){</strong></p><p>　　　　<strong>异常处理代码；</strong></p><p>　　<strong>}</strong></p><p>　　<strong>fianlly{</strong></p><p>　　<strong>一定会执行的代码；</strong></p><p>　　<strong>}</strong></p><p>——————————————————————————————————————————————————————</p><p>　　catch (Exception e) { //e用于接收try检测到的异常对象。</p><p>　　　　System.out.println(“message:”+e.getMessage());//获取的是异常的信息。</p><p>　　　　System.out.println(“toString:”+e.toString());//获取的是异常的名字+异常的信息。</p><p>　　　　e.printStackTrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>异常处理原则</strong>：<strong>功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。</strong></p><p>　　<strong>特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。</strong></p><p>　　<strong>throw 和throws关键字的区别：</strong></p><p>　　　　throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。</p><p>　　　　throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。</p><p>　　通常情况：函数内容如果有throw，抛出异常对象，并没有进行处理，那么函数上一定要声明，否则编译失败。但是也有特殊情况。</p><p>　　<strong>异常分两种：</strong></p><p>　　　　1：编译时被检查的异常，只要是Exception及其子类都是编译时被检测的异常。</p><p>　　　　2：运行时异常，其中Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，也就说这个异常是编译时不被检查的异常。</p><p>　　<strong>编译时被检查的异常和运行时异常的区别</strong>：</p><p>　　　　编译被检查的异常在函数内被抛出，函数必须要声明，否编译失败。</p><p>　　　　声明的原因：是需要调用者对该异常进行处理。</p><p>　　　　运行时异常如果在函数内被抛出，在函数上不需要声明。</p><p>　　　　不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。</p><p>　　<strong>定义异常处理时，什么时候定义try，什么时候定义throws呢？</strong></p><p>　　　　<strong>功能内部如果出现异常，如果内部可以处理，就用try；</strong></p><p>　　　　<strong>如果功能内部处理不了，就必须声明出来，让调用者处理。</strong></p><p>　　<strong>自定义异常</strong>：当开发时，项目中出现了java中没有定义过的问题时，这时就需要我们按照java异常建立思想，将项目的中的特有问题也进行对象的封装。这个异常，称为自定义异常。</p><p>　　对于除法运算，0作为除数是不可以的。java中对这种问题用ArithmeticException类进行描述。对于这个功能，在我们项目中，除数除了不可以为0外，还不可以为负数。可是负数的部分java并没有针对描述。所以我们就需要自定义这个异常。</p><p>　　<strong>自定义异常的步骤：</strong></p><p>　　　　1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性。</p><p>　　　　2：通过throw 或者throws进行操作。</p><p>　　<strong>异常的转换思想</strong>：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。</p><p>　　<strong>try catch finally的几种结合方式：</strong></p><p>　　1，</p><p>　　　　try </p><p>　　　　catch</p><p>　　　　finally</p><p>　　2,</p><p>　　　　try</p><p>　　　　catch</p><p>　　3,</p><p>　　　　try</p><p>　　　　finally</p><p>　　这种情况，如果出现异常，并不处理，但是资源一定关闭，所以<strong>try finally集合只为关闭资源。</strong></p><p>　　<strong>记住</strong>：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。</p><p>　　<strong>System.exit(0)</strong>; //退出jvm，只有这种情况finally不执行。</p><p>　　<strong>当异常出现后，在子父类进行覆盖时，有了一些新的特点：</strong></p><p>　　　　1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。</p><p>　　　　2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。</p><p>　　<strong>注意：</strong></p><p>　　　　<strong>如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的</strong>，<strong>如果子类的覆盖的方法中出现了异常，只能try不能throws。</strong></p><p>　　　　<strong>如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。</strong></p><p>　　<strong>常见异常：</strong></p><p>　　　　1、脚标越界异常（IndexOutOfBoundsException）包括数组、字符串；</p><p>　　　　　　空指针异常（NullPointerException）</p><p>　　　　2、类型转换异常：ClassCastException</p><p>　　　　3、没有这个元素异常：NullPointerException</p><p>　　　　4、不支持操作异常；</p><p>　　异常要尽量避免，如果避免不了，需要预先给出处理方式。比如家庭备药，比如灭火器。</p><p>——————————————————————————————————————————————————————</p><p><strong>包</strong>：定义包用package关键字。</p><p>　　1：对类文件进行分类管理。</p><p>　　2：给类文件提供多层名称空间。</p><p>　　如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。</p><p>　　一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用<strong>url域名</strong>来进行包名称的定义。</p><p>　　<strong>package</strong> pack;//定义了一个包，名称为pack。 <strong>注意：包名的写法规范：所有字母都小写。</strong></p><p>　　//package cn.itcast.pack.demo;</p><p>　　类的全名称是 <strong>包名.类名</strong></p><p>  编译命令：javac –d 位置（.当前路径） java源文件 （<strong>就可以自动生成包</strong>）</p><p>　　包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；</p><p>类中的成员，如果被包以外访问，也必须public；</p><p>　　<strong>包与包之间访问可以使用的权限有两种</strong>：</p><p>　　　　1：public </p><p>　　　　2：protected：只能是不同包中的子类可以使用的权限。</p><p>　　<strong>总结java中的四种权限：</strong></p><p>  　　<strong>范围    public 　　protected 　　default 　　private</strong> </p><p>　　同一个类中    ok　　　　 ok 　　　　　　ok 　　　　　ok</p><p>　　同一包中  　　ok 　　　　ok　　　　　　 ok</p><p>　　子类 　　　　　 ok  </p><p>　　<strong>不同包中      ok</strong></p><p>——————————————————————————————————————————————————————</p><p><strong>Import — 导入</strong>：类名称变长，写起来很麻烦。为了简化，使用了一个关键字：import，可以使用这个关键字导入指定包中的类。记住：实际开发时,到的哪个类就导入哪个类，不建议使用*.</p><p>　　import packa.*;//这个仅仅是导入了packa当前目录下的所有的类。不包含子包。</p><p>　　import packa.abc.*;//导入了packa包中的子包abc下的当前的所有类。</p><p>　　<strong>如果导入的两个包中存在着相同名称的类。这时如果用到该类，必须在代码中指定包名。</strong></p><p>　　<strong>常见的软件包:</strong></p><p>　　　　<strong>java.lang : language java的核心包，Object System String Throwable jdk1.2版本后，该包中的类自动被导入。</strong></p><p>　　　　<strong>java.awt : 定义的都是用于java图形界面开发的对象。</strong></p><p>　　　　<strong>javax.swing: 提供所有的windows桌面应用程序包括的控件,比如：Frame , Dialog, Table, List 等等,就是java的图形界面库。</strong></p><p>　　　　<strong>java.net : 用于java网络编程方面的对象都在该包中。</strong></p><p>　　　　<strong>java.io : input output 用于操作设备上数据的对象都在该包中。比如：读取硬盘数据，往硬盘写入数据。</strong></p><p>　　　　<strong>java.util : java的工具包，时间对象，集合框架。</strong></p><p>　　　　<strong>java.applet: application+let 客户端java小程序。server+let ——&gt; servlet 服务端java小程序。</strong></p><p>　　　　<strong>jar ：java的压缩包，主要用于存储类文件，或者配置文件等。</strong></p><p>　　　　　　<strong>命令格式</strong>：jar –cf 包名.jar 包目录</p><p>  　　　　　<strong>解压缩</strong>：jar –xvf 包名.jar </p><p> 　　　　　<strong>将jar包目录列表重定向到一个文件中</strong>：jar –tf 包名.jar &gt;c:\1.txt</p><p>——————————————————————————————————————————————————————</p><p><strong>多线程：★★★★</strong></p><p>　　<strong>进程</strong>：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。</p><p>　　<strong>线程</strong>：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。</p><p>　　一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。</p><p>　　jvm在启动的时，首先有一个<strong>主线程</strong>，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。</p><p>　　当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。 </p><p>　　<strong>随机性的原理</strong>：因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。</p><p>　　返回当前线程的名称：<strong>Thread.currentThread().getName()</strong></p><p>　　线程的名称是由：Thread—编号定义的。编号从0开始。</p><p>　　线程要运行的代码都统一存放在了<strong>run方法</strong>中。</p><p>　　线程要运行必须要通过类中指定的方法开启。<strong>start方法</strong>。（启动后，就多了一条执行路径）</p><p>　　<strong>start方法</strong>：1）、启动了线程；2）、让jvm调用了run方法。</p><p>　　<strong>创建线程的第一种方式：继承Thread ，由子类复写run方法。</strong></p><p>　　步骤：</p><p>　　　　1，定义类继承Thread类；</p><p>　　　　2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；</p><p>　　　　3，通过创建Thread类的子类对象，创建线程对象；</p><p>　　　　4，调用线程的start方法，开启线程，并执行run方法。</p><p>　　线程状态：</p><p>　　　　<strong>被创建</strong>：start()</p><p>　　　　<strong>运行</strong>：具备执行资格，同时具备执行权；</p><p>　　　　<strong>冻结</strong>：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；</p><p>　　　　<strong>临时阻塞状态</strong>：线程具备cpu的执行资格，没有cpu的执行权；</p><p>　　　　<strong>消亡</strong>：stop()</p><p> <img src="https://images0.cnblogs.com/i/600704/201404/090117588259525.jpg" alt="img"></p><p>　　<strong>创建线程的第二种方式：实现一个接口Runnable。</strong></p><p>　　步骤：</p><p>　　　　1，定义类实现Runnable接口。</p><p>　　　　2，覆盖接口中的run方法（用于封装线程要运行的代码）。</p><p>　　　　3，通过Thread类创建线程对象；</p><p>　　　　4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。</p><p>　　　　　　为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。</p><p>　　　　5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。</p><p>　　　　　　<strong>Ticket t = new Ticket();</strong></p><p>　　　　　　/*直接创建Ticket对象，并不是创建线程对象。</p><p>　　　　　　因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。</p><p>　　　　　　所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。*/</p><p>　　　　　　<strong>Thread t1 = new Thread(t); //创建线程。</strong></p><p>　　　　　　/*只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联</p><p>　　　　　　为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。*/</p><p>　　　　　　<strong>t1.start();</strong></p><p>　　<strong>为什么要有Runnable接口的出现？</strong></p><p>　　1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。</p><p>　　　　可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？</p><p>　　　　只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。</p><p>　　　　所以，通常创建线程都用第二种方式。</p><p>　　　　<strong>因为实现Runnable接口可以避免单继承的局限性。</strong></p><p>　　2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。</p><p>　　　　所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。</p><p>　　　　<strong>实现Runnable接口可以避免单继承的局限性</strong>。而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以<strong>Runnable接口将线程要执行的任务封装成了对象</strong>。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>//面试</strong></p><p>　　　　new Thread(new Runnable(){ //匿名</p><p>　　　　　　public void run(){</p><p>　　　　　　　　System.out.println(“runnable run”);</p><p>　　　　　　}</p><p>　　　　})</p><p>　　　　{</p><p>　　　　　　public void run(){</p><p>　　　　　　　　System.out.println(“subthread run”);</p><p>　　　　　　}</p><p>　　　　}.start(); <strong>//结果：subthread run</strong></p><p>——————————————————————————————————————————————————————</p><p>　　　　Try {</p><p>　　　　　　Thread.sleep(10);</p><p>　　　　}catch(InterruptedException e){}// 当刻意让线程稍微停一下，模拟cpu 切换情况。</p><p>　　<strong>多线程安全问题的原因：</strong></p><p>　　　　通过图解：发现一个线程在执行多条语句时，并运算同一个数据时，在执行过程中，其他线程参与进来，并操作了这个数据。导致到了错误数据的产生。</p><p>　　<strong>涉及到两个因素：</strong></p><p>　　　　<strong>1，多个线程在操作共享数据。</strong></p><p>　　　　<strong>2，有多条语句对共享数据进行运算</strong>。</p><p>　　　　　　原因：这多条语句，在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。</p><p>　　<strong>解决安全问题的原理：</strong></p><p>　　　　只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。</p><p>　　如何进行多句操作共享数据代码的封装呢？</p><p>　　　　<strong>java中提供了一个解决方式</strong>：<strong>就是同步代码块</strong>。</p><p>　　　　格式：</p><p>　　　　<strong>synchronized(对象) {</strong> <strong>// 任意对象都可以。这个对象就是锁。</strong></p><p>　　　　　　<strong>需要被同步的代码；</strong></p><p>　　　　<strong>}</strong></p><p>——————————————————————————————————————————————————————</p><p><strong>同步：★★★★★</strong></p><p>　　<strong>好处</strong>：解决了线程安全问题。</p><p>　　<strong>弊端</strong>：相对降低性能，因为判断锁需要消耗资源，产生了死锁。</p><p>　　<strong>定义同步是有前提的</strong>：</p><p>　　　　1，必须要有两个或者两个以上的线程，才需要同步。</p><p>　　　　2，多个线程必须保证使用的是同一个锁。</p><p>　　同步的第二种表现形式：</p><p>　　　　<strong>同步函数</strong>：其实就是将同步关键字定义在函数上，让函数具备了同步性。</p><p>　　　　<strong>同步函数是用的哪个锁呢？</strong></p><p>　　　　　　通过验证，函数都有自己所属的对象this，所以<strong>同步函数所使用的锁就是this锁。</strong></p><p>　　　<strong>当同步函数被static修饰时，这时的同步用的是哪个锁呢？</strong></p><p>　　　　静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是<strong>该类的字节码文件对象。</strong></p><p>　　　　所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。</p><p>　　　　这个对象就是 <strong>类名.class</strong></p><p>　　<strong>同步代码块和同步函数的区别？</strong></p><p>　　　　同步代码块使用的锁可以是任意对象。</p><p>　　　　<strong>同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。</strong></p><p>　　　　<strong>在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。</strong></p><p>　　//懒汉式：延迟加载方式。</p><p>　　当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。</p><p>　　<strong>为了效率问题，通过双重判断的形式解决。</strong></p><p>　　class Single{</p><p>　　　　private static Single s = null;</p><p>　　　　private Single(){}</p><p>　　　　public static Single getInstance(){ <strong>//锁是谁？字节码文件对象；</strong></p><p>　　　　<strong>if(s == null){</strong></p><p>　　　　　　<strong>synchronized(Single.class){</strong></p><p>　　　　　　　　<strong>if(s == null)</strong></p><p>　　　　　　　　<strong>s = new Single();</strong></p><p>　　　　　　<strong>}</strong></p><p>　　　　<strong>}</strong></p><p>　　　　return s;</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>同步死锁</strong>：通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。</p><p>　　<strong>线程间通信</strong>：思路：多个线程在操作同一个资源，但是操作的动作却不一样。</p><p>　　　　1：将资源封装成对象。</p><p>　　　　2：将线程执行的任务(任务其实就是run方法。)也封装成对象。</p><p>　　<strong>等待唤醒机制</strong>：涉及的方法：</p><p>　　　　<strong>wait</strong>:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。</p><p>　　　　<strong>notify</strong>：唤醒线程池中某一个等待线程。</p><p>　　　　<strong>notifyAll</strong>:唤醒的是线程池中的所有线程。</p><p>　　注意：</p><p>　　　　1：这些方法都需要定义在同步中。 </p><p>　　　　2：因为这些方法必须要标示所属的锁。</p><p>　　　　　　你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。</p><p>　　　　3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？</p><p>　　　　　　因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，</p><p>　　　　　　那么能被任意对象调用的方法一定定义在Object类中。</p><p>　　<strong>wait和sleep区别</strong>： 分析这两个方法：从执行权和锁上来分析：</p><p>　　　　wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。</p><p>　　　　sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。</p><p>　　　　<strong>wait：线程会释放执行权，而且线程会释放锁。</strong></p><p>　　　　<strong>Sleep：线程会释放执行权，但不是不释放锁。</strong></p><p>　　<strong>线程的停止</strong>：通过stop方法就可以停止线程。但是这个方式过时了。</p><p>　　　　停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。</p><p>　　　　怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。</p><p>　　　　第一种方式：定义循环的结束标记。</p><p>　　　　第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。</p><p>　　<strong>—————————&lt; java.lang.Thread &gt;————</strong></p><p>　　　　**interrupt()**：中断线程。</p><p>　　　　**setPriority(int newPriority)**：更改线程的优先级。</p><p>　　　　**getPriority()**：返回线程的优先级。</p><p>　　　　**toString()**：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。</p><p>　　　　**Thread.yield()**：暂停当前正在执行的线程对象，并执行其他线程。</p><p>　　　　**setDaemon(true)**：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，</p><p>　　　　　　　　　　　　　Java 虚拟机退出。该方法必须在启动线程前调用。</p><p>　　　　<strong>join</strong>：临时加入一个线程的时候可以使用join方法。</p><p>　　　　　　当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。</p><p>　　　　　　A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。</p><p>——————————————————————————————————————————————————————</p><p><strong>Lock接口</strong>：<strong>多线程在JDK1.5版本升级时，推出一个接口Lock接口。</strong></p><p>　　解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。</p><p>　　到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。</p><p>　　在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。</p><p>　　所以<strong>同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步</strong>。</p><p>　　在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。</p><p>　　而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是<strong>Condition</strong>，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 **await()、signal()、signalAll()**体现新版本对象的好处。</p><p><strong>&lt; java.util.concurrent.locks &gt; Condition接口：await()、signal()、signalAll()；</strong></p><p>——————————————————————————————————————————————————————</p><p>　　class BoundedBuffer {</p><p> 　　 <strong>final Lock lock = new ReentrantLock();</strong></p><p> 　　 final Condition notFull = <strong>lock.newCondition();</strong> </p><p> 　　 final Condition notEmpty = <strong>lock.newCondition();</strong> </p><p> 　 final Object[] items = new Object[100];</p><p> 　 int putptr, takeptr, count;</p><p> 　　 public void put(Object x) throws InterruptedException {</p><p> 　　  <strong>lock.lock();</strong></p><p>  　 <strong>try {</strong></p><p>  　  while (count == items.length) </p><p>​    　 <strong>notFull.await();</strong></p><p>   　　 items[putptr] = x; </p><p>   　 if (++putptr == items.length) putptr = 0;</p><p>   　 ++count;</p><p>   　 <strong>notEmpty.signal();</strong></p><p>  　 <strong>}</strong> </p><p>　　　　<strong>finally {</strong></p><p>   　 　 <strong>lock.unlock();</strong></p><p>  　　 <strong>}</strong></p><p>  　}</p><p>  　public Object take() throws InterruptedException {</p><p>  　　　　 <strong>lock.lock();</strong></p><p>  　　　　 <strong>try {</strong></p><p>　　　　　　　while (count == 0) </p><p>　　　　　　　<strong>notEmpty.await();</strong></p><p>　　　　　　　Object x = items[takeptr]; </p><p>　　　　　　　 if (++takeptr == items.length) takeptr = 0;</p><p>　　　　　　　——count;</p><p>　　　　　　　<strong>notFull.signal();</strong></p><p>　　　　　　　 return x;</p><p>   　　　<strong>}</strong> </p><p>　　　　　　<strong>finally {</strong></p><p>   　　　　　　 <strong>lock.unlock();</strong></p><p>  　　　　 <strong>}</strong></p><p>  　　} </p><p>　　 }</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API</strong>：（Application Programming Interface,<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>编程接口）是一些预先定义的<a href="http://baike.baidu.com/view/15061.htm">函数</a>，目的是提供应用程序与开发人员基于某<a href="http://baike.baidu.com/view/37.htm">软件</a>或硬件的以访问一组<a href="http://baike.baidu.com/view/1582587.htm">例程</a>的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>　　——&lt; java.lang &gt;—— <strong>String字符串：★★★☆</strong></p><p>　　java中用String类进行描述。对字符串进行了对象的封装。这样的好处是可以对字符串这种常见数据进行方便的操作。对象封装后，可以定义N多属性和行为。</p><p>　　如何定义字符串对象呢？String s = “abc”;只要是双引号引起的数据都是字符串对象。</p><p>　　<strong>特点：字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　　　<strong>String s1 = “abc”; // s1指向的内存中只有一个对象abc。</strong></p><p>　　　　<strong>String s2 = new String(“abc”); // s2指向的内容中有两个对象abc、new 。</strong></p><p>　　　　<strong>System.out.println(s1==s2);//false</strong></p><p>　　　　<strong>System.out.println(s1.equals(s2));//true ，字符串中equals比较的是字符串内容是否相同。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>字符串的方法：</strong></p><p>　　<strong>1：构造方法：</strong>将字节数组或者字符数组转成字符串。</p><p>　　　　String s1 = new String();//创建了一个空内容的字符串。 </p><p>　　　　String s2 = null;//s2没有任何对象指向，是一个null常量值。</p><p>　　　　String s3 = “”;//s3指向一个具体的字符串对象，只不过这个字符串中没有内容。</p><p>　　　　<strong>//一般在定义字符串时，不用new。</strong></p><p>　　　　String s4 = new String(“abc”);</p><p>　　　　String s5 = “abc”; 一般用此写法</p><p>　　　　<strong>new String(char[]);//将字符数组转成字符串。</strong></p><p>　　　　<strong>new String(char[],offset,count);//将字符数组中的一部分转成字符串。</strong></p><p>　　<strong>2：一般方法：</strong></p><p>　　　　　　按照面向对象的思想：</p><p>　　　　<strong>2.1 获取：</strong></p><p>　　　　　　2.1.1：获取字符串的长度。<strong>length();</strong></p><p>　　　　　　2.1.2：指定位置的字符。char <strong>charAt</strong>(int index);</p><p>　　　　　　2.1.3：获取指定字符的位置。如果不存在返回—1，所以可以通过返回值—1来判断某一个字符不存在的情况。</p><p>　　　　　　　　int <strong>indexOf</strong>(int ch);//返回第一次找到的字符角标</p><p>　　　　　　　　int indexOf(int ch,int fromIndex); //返回从指定位置开始第一次找到的角标</p><p>　　　　　　　　int indexOf(String str); //返回第一次找到的字符串角标</p><p>　　　　　　　　int indexOf(String str,int fromIndex);</p><p>　　　　　　　　int <strong>lastIndexOf</strong>(int ch);</p><p>　　　　　　　　int lastIndexOf(int ch,int fromIndex);</p><p>　　　　　　　　int lastIndexOf(String str);</p><p>　　　　　　　　int lastIndexOf(String str,int fromIndex);</p><p>　　　　　　2.1.4：获取子串。</p><p>　　　　　　　　String <strong>substring</strong>(int start);//从start位开始，到length()—1为止.</p><p>　　　　　　　　String substring(int start,int end);//从start开始到end为止。//包含start位，不包含end位。</p><p>　　　　　　　　substring(0,str.length());//获取整串</p><p>　　　　<strong>2.2 判断：</strong></p><p>　　　　　　2.2.1：字符串中包含指定的字符串吗？</p><p>　　　　　　　　boolean <strong>contains</strong>(String substring);</p><p>　　　　　　2.2.2：字符串是否以指定字符串开头啊？</p><p>　　　　　　　　boolean <strong>startsWith</strong>(string);</p><p>　　　　　　2.2.3：字符串是否以指定字符串结尾啊？</p><p>　　　　　　　　boolean <strong>endsWith</strong>(string);</p><p>　　　　　　2.2.4：判断字符串是否相同</p><p>　　　　　　　　boolean <strong>equals</strong>(string);//覆盖了Object中的方法，判断字符串内容是否相同。</p><p>　　　　　　2.2.5：判断字符串内容是否相同，忽略大小写。</p><p>　　　　　　　　boolean <strong>equalsIgnore</strong>Case(string) ;</p><p>　　　　<strong>2.3 转换：</strong></p><p>　　　　　　2.3.1：通过构造函数可以将字符数组或者字节数组转成字符串。</p><p>　　　　　　2.3.2：可以通过字符串中的静态方法，将字符数组转成字符串。</p><p>　　　　　　　　static String <strong>copyValueOf</strong>(char[] );</p><p>　　　　　　　　static String copyValueOf(char[],int offset,int count);</p><p>　　　　　　　　static String <strong>valueOf</strong>(char[]);</p><p>　　　　　　　　static String valueOf(char[],int offset,int count);</p><p>　　　　　　2.3.3：将基本数据类型或者对象转成字符串。</p><p>　　　　　　　　static String valueOf(char);</p><p>　　　　　　　　static String valueOf(boolean);</p><p>　　　　　　　　static String valueOf(double);</p><p>　　　　　　　　static String valueOf(float);</p><p>　　　　　　　　static String valueOf(int);</p><p>　　　　　　　　static String valueOf(long);</p><p>　　　　　　　　static String valueOf(Object);</p><p>　　　　　　2.3.4：将字符串转成大小写。</p><p>　　　　　　　　String <strong>toLowerCase</strong>();</p><p>　　　　　　　　String <strong>toUpperCase</strong>();</p><p>　　　　　　2.3.5：将字符串转成数组。</p><p>　　　　　　　　char[] <strong>toCharArray</strong>();//转成字符数组。</p><p>　　　　　　　　byte[] <strong>getBytes</strong>();//可以加入编码表。转成字节数组。</p><p>　　　　　　2.3.6：将字符串转成字符串数组。切割方法。</p><p>　　　　　　　　String[] <strong>split</strong>(分割的规则—字符串);</p><p>　　　　　　2.3.7：将字符串进行内容替换。注意：修改后变成新字符串，并不是将原字符串直接修改。</p><p>　　　　　　　　String <strong>replace</strong>(oldChar,newChar);</p><p>　　　　　　　　String replace(oldstring,newstring);</p><p>　　　　　　2.3.8： String <strong>concat</strong>(string); //对字符串进行追加。</p><p>　　　　　　　　String <strong>trim</strong>();//去除字符串两端的空格</p><p>　　　　　　　　int <strong>compareTo</strong>();//如果参数字符串等于此字符串，则返回值 0；如果此字符串按字典顺序小于字符串参数，</p><p>　　　　　　　　　　　　　　　　则返回一个小于 0 的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于 0 的值。</p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.lang &gt;——</strong> <strong>StringBuffer字符串缓冲区：★★★☆</strong></p><p>　　构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。</p><p>　　<strong>特点：</strong></p><p>　　　　<strong>1：可以对字符串内容进行修改。</strong></p><p>　　　　<strong>2：是一个容器。</strong></p><p>　　　　<strong>3：是可变长度的。</strong></p><p>　　　　<strong>4：缓冲区中可以存储任意类型的数据。</strong></p><p>　　　　<strong>5：最终需要变成字符串</strong>。</p><p>　　容器通常具备一些固定的方法：</p><p>　　<strong>1，添加。</strong></p><p>　　　　StringBuffer <strong>append</strong>(data):在缓冲区中追加数据。追加到尾部。</p><p>　　　　StringBuffer <strong>insert</strong>(index,data):在指定位置插入数据。</p><p>　　<strong>2，删除。</strong></p><p>　　　　StringBuffer <strong>delete</strong>(start,end);删除从start至end—1范围的元素</p><p>　　　　StringBuffer deleteCharAt(index);删除指定位置的元素</p><p>　　　　//sb.delete(0,sb.length());//清空缓冲区。</p><p>　　<strong>3，修改。</strong></p><p>　　　　StringBuffer <strong>replace</strong>(start,end,string);将start至end—1替换成string</p><p>　　　　void <strong>setCharAt</strong>(index,char);替换指定位置的字符</p><p>　　　　void <strong>setLength</strong>(len);将原字符串置为指定长度的字符串</p><p>　　<strong>4，查找。（查不到返回—1</strong>）</p><p>　　　　int <strong>indexOf</strong>(string); 返回指定子字符串在此字符串中第一次出现处的索引。</p><p>　　　　int indexOf(string,int fromIndex);从指定位置开始查找字符串</p><p>　　　　int <strong>lastIndexOf</strong>(string); 返回指定子字符串在此字符串中最右边出现处的索引。</p><p>　　　　int lastIndexOf(string,int fromIndex); 从指定的索引开始反向搜索</p><p>　　<strong>5，获取子串。</strong></p><p>　　　　string <strong>substring</strong>(start); 返回start到结尾的子串</p><p>　　　　string substring(start,end); 返回start至end—1的子串</p><p>　　<strong>6，反转。</strong></p><p>　　　　StringBuffer <strong>reverse</strong>();字符串反转</p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.lang &gt;——</strong> <strong>StringBuilder字符串缓冲区：★★★☆</strong></p><p>　　<strong>JDK1.5出现StringBuiler</strong>；构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。</p><p>　　方法和StringBuffer一样；</p><p>　　<strong>StringBuffer 和 StringBuilder 的区别：</strong></p><p>　　　　<strong>StringBuffer线程安全。</strong></p><p>　　　　<strong>StringBuilder线程不安全。</strong></p><p>　　　　<strong>单线程操作，使用StringBuilder 效率高。</strong></p><p>　　　　<strong>多线程操作，使用StringBuffer 安全。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　　　　　StringBuilder sb = new StringBuilder(“abcdefg”);</p><p>　　　　　　sb.append(“ak”); //abcdefgak</p><p>　　　　　　sb.insert(1,”et”);//aetbcdefg</p><p>　　　　　　sb.deleteCharAt(2);//abdefg</p><p>　　　　　　sb.delete(2,4);//abefg</p><p>　　　　　　sb.setLength(4);//abcd</p><p>　　　　　　sb.setCharAt(0,’k’);//kbcdefg</p><p>　　　　　　sb.replace(0,2,”hhhh”);//hhhhcdefg</p><p>　　　　　　<strong>//想要使用缓冲区，先要建立对象。</strong></p><p>　　　　　　StringBuffer sb = new StringBuffer();</p><p>　　　　　　sb.append(12).append(“haha”);//方法调用链。</p><p>　　　　　　String s = “abc”+4+’q’;</p><p>　　　　　　s = new StringBuffer().append(“abc”).append(4).append(‘q’).toString();</p><p>——————————————————————————————————————————————————————</p><p>　　class Test{</p><p>　　　　public static void main(String[] args) {</p><p>　　　　　　String s1 = “java”;</p><p>　　　　　　String s2 = “hello”;</p><p>　　　　　　method_1(s1,s2);</p><p>　　　　　　System.out.println(s1+”….”+s2); <strong>//java….hello</strong></p><p>　　　　　　StringBuilder s11 = new StringBuilder(“java”);</p><p>　　　　　　StringBuilder s22 = new StringBuilder(“hello”);</p><p>　　　　　　method_2(s11,s22);</p><p>　　　　　　System.out.println(s11+”—————“+s22); <strong>//javahello—————hello</strong></p><p>　　　　}</p><p>　　　　public static void method_1(String s1,String s2){</p><p>　　　　　　s1.replace(‘a’,’k’);</p><p>　　　　　　s1 = s2;</p><p>　　　　}</p><p>　　　　public static void method_2(StringBuilder s1,StringBuilder s2){</p><p>　　　　　　s1.append(s2);</p><p>　　　　　　s1 = s2;</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>基本数据类型对象包装类</strong>：是按照面向对象思想将基本数据类型封装成了对象。</p><p>　　好处：</p><p>　　　　1：可以通过对象中的属性和行为操作基本数据。</p><p>　　　　2：可以实现基本数据类型和字符串之间的转换。</p><p>　　<strong>关键字  对应的类名</strong></p><p>　　　　byte  Byte</p><p>　　　　short  Short   paserShort(numstring);</p><p>　　　　int  Integer  静态方法：parseInt(numstring)</p><p>　　　　long  Long</p><p>　　　　float  Float</p><p>　　　　double  Double</p><p>　　　　char  <strong>Character</strong></p><p>　　　　Boolean  Boolean</p><p>　　　　<strong>基本数据类型对象包装类</strong>：都有 <strong>XXX parseXXX 方法</strong></p><p>　　　　只有一个类型没有<strong>parse</strong>方法：Character ；</p><p>——————————————————————————————————————————————————————</p><p><strong>Integer对象： ★★★☆</strong></p><p>　　<strong>数字格式的字符串转成基本数据类型的方法：</strong></p><p>　　　　1：将该字符串封装成了Integer对象，并调用对象的方法intValue();</p><p>　　　　2：使用<strong>Integer.parseInt(numstring)</strong>:不用建立对象，直接类名调用；</p><p>　　<strong>将基本类型转成字符串：</strong></p><p>　　　　1：Integer中的静态方法 String toString(int);</p><p>　　　　2：int+””;</p><p>　　<strong>将一个十进制整数转成其他进制</strong>：</p><p>　　　　转成二进制：toBinaryString</p><p>　　　　转成八进制：toOctalString</p><p>　　　　转成十六进制：toHexString</p><p>　　　　　　toString(int num,int radix);</p><p>　　将其他进制转换十进制：</p><p>　　　　<strong>parseInt(string,radix)</strong>; //将给定的数转成指定的基数进制；</p><p>　　<strong>在jdk1.5版本后，对基本数据类型对象包装类进行升级。在升级中，使用基本数据类型对象包装类可以像使用基本数据类型一样，进行运算。</strong></p><p>　　　　Integer i = new Integer(4); <strong>//1.5版本之前的写法；</strong></p><p>　　　　Integer i = 4; <strong>//自动装箱，1.5版本后的写法</strong>；</p><p>　　　　<strong>i = i + 5;</strong></p><p>　　　　//i对象是不能直接和5相加的，其实底层先将i转成int类型，在和5相加。而转成int类型的操作是隐式的。<strong>自动拆箱：拆箱的原理就是i.intValue()</strong>;i+5运算完是一个int整数。如何赋值给引用类型i呢？其实有对结果进行装箱。</p><p>　　　　Integer c = 127;</p><p>　　　　Integer d = 127;</p><p>　　　　System.out.println(c = = d); //true</p><p>　　　　<strong>//在装箱时，如果数值在byte范围之内，那么数值相同，不会产生新的对象，也就是说多个数值相同的引用指向的是同一个对象。</strong></p><p>——————————————————————————————————————————————————————</p><p><strong>集合框架：★★★★★，用于存储数据的容器。</strong></p><p>　　<strong>特点：</strong></p><p>　　　　1：对象封装数据，对象多了也需要存储。<strong>集合用于存储对象。</strong></p><p>　　　　2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为<strong>集合是可变长度的。</strong></p><p>　　<strong>集合和数组的区别：</strong></p><p>　　　　1：数组是固定长度的；集合可变长度的。</p><p>　　　　2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p><p>　　　　3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p><p>　　<strong>数据结构</strong>：就是容器中存储数据的方式。</p><p>　　对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>　　集合容器在不断向上抽取过程中。出现了集合体系。</p><p>　　<strong>在使用一个体系时，原则：参阅顶层内容。建立底层对象。</strong></p><p> <img src="https://images0.cnblogs.com/i/600704/201404/090145483874597.jpg" alt="img"></p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.util &gt;——</strong> <strong>Collection接口：</strong></p><p>　　<strong>Collection：</strong></p><p>　　　　<strong>|——List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</strong></p><p>　　　　<strong>|——Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</strong></p><p>　　<strong>1，添加：</strong></p><p>　　　　add(object)：添加一个元素</p><p>　　　　addAll(Collection) ：添加一个集合中的所有元素。</p><p>　　<strong>2，删除：</strong></p><p>　　　　clear()：将集合中的元素全删除，<strong>清空集合。</strong></p><p>　　　　remove(obj) ：删除集合中指定的对象。<strong>注意：删除成功，集合的长度会改变。</strong></p><p>　　　　removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。</p><p>　　<strong>3，判断：</strong></p><p>　　　　boolean contains(obj) ：集合中是否包含指定元素 。</p><p>　　　　boolean containsAll(Collection) ：集合中是否包含指定的多个元素。</p><p>　　　　boolean isEmpty()：集合中是否有元素。 </p><p>　　<strong>4，获取：</strong></p><p>　　　　int size()：集合中有几个元素。</p><p>　　<strong>5，取交集：</strong></p><p>　　　　boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。</p><p>　　<strong>6，获取集合中所有元素：</strong></p><p>　　　　<strong>Iterator iterator()：迭代器</strong></p><p>　　<strong>7，将集合变成数组：</strong></p><p>　　　　toArray();</p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.util &gt;——</strong> <strong>Iterator接口：</strong></p><p>　　<strong>迭代器：是一个接口。作用：用于取集合中的元素。</strong></p><table><thead><tr><th>boolean</th><th><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#hasNext()">hasNext</a>() 如果仍有元素可以迭代，则返回 true。</th></tr></thead><tbody><tr><td>E</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#next()">next</a>()  返回迭代的下一个元素。</td></tr><tr><td>void</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#remove()">remove</a>() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。</td></tr></tbody></table><p>　　每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是<strong>Iterator接口。</strong></p><p>　　也就说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。</p><p>　　<strong>Iterator it = coll.iterator();</strong>//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。</p><p>——————————————————————————————————————————————————————</p><p>　　public static void main(String[] args) {</p><p>　　　　Collection coll = new ArrayList();</p><p>　　　　coll.add(“abc0”);</p><p>　　　　coll.add(“abc1”);</p><p>　　　　coll.add(“abc2”);</p><p>　　　　//————————方式1——————————</p><p>　　　　Iterator it = coll.iterator();</p><p>　　　　while(it.hasNext()){</p><p>　　　　　　System.out.println(it.next());</p><p>　　　　}</p><p>　　　　//—————————方式2用此种——————————</p><p>　　　　for(Iterator it = coll.iterator();it.hasNext(); ){</p><p>　　　　　　System.out.println(it.next());</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.util &gt;——</strong> <strong>List接口</strong>：</p><p>　　List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</p><p>　　<strong>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</strong></p><p>　　　　<strong>|——ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</strong></p><p>　　　　<strong>|——LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</strong></p><p>　　　　<strong>|——Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</strong></p><p>　　<strong>1，添加：</strong></p><p>　　　　add(index,element) ：在指定的索引位插入元素。</p><p>　　　　addAll(index,collection) ：在指定的索引位插入一堆元素。</p><p>　　<strong>2，删除：</strong></p><p>　　　　remove(index) ：删除指定索引位的元素。 返回被删的元素。</p><p>　　<strong>3，获取：</strong></p><p>　　　　Object get(index) ：通过索引获取指定元素。</p><p>　　　　int <strong>indexOf</strong>(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回—1；</p><p>　　　　所以，通过—1，可以判断一个元素是否存在。</p><p>　　　　int lastIndexOf(Object o) ：反向索引指定元素的位置。</p><p>　　　　List subList(start,end) ：获取子列表。</p><p>　　<strong>4，修改：</strong></p><p>　　　　Object set(index,element) ：对指定索引位进行元素的修改。</p><p>　　<strong>5，获取所有元素：</strong></p><p>　　　　ListIterator <strong>listIterator</strong>()：list集合特有的迭代器。</p><p>　　<strong>List集合支持对元素的增、删、改、查。</strong></p><p>　　<strong>List集合因为角标有了自己的获取元素的方式： 遍历。</strong></p><p>　　　　**for(int x=0; x</p><p>　　　　　　<strong>sop(“get:”+list.get(x));</strong></p><p>　　　　<strong>}</strong></p><p>　　　　在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。<strong>会发生.ConcurrentModificationException并发修改异常。</strong></p><p>　　<strong>导致的原因是：</strong></p><p>　　　　集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。</p><p>　　<strong>如何解决呢？</strong></p><p>　　　　既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.通过查阅的它的子接口,<strong>ListIterator</strong>,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。</p><p>　　<strong>ListIterator是List集合特有的迭代器。</strong></p><p>　　ListIterator it = list.listIterator;//取代Iterator it = list.iterator;</p><table><thead><tr><th>方法摘要</th><th></th></tr></thead><tbody><tr><td>void</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#add(E)">add</a>(E e) 将指定的元素插入列表（可选操作）。</td></tr><tr><td>boolean</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#hasNext()">hasNext</a>() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。</td></tr><tr><td>boolean</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#hasPrevious()">hasPrevious</a>() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。</td></tr><tr><td>E</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#next()">next</a>() 返回列表中的下一个元素。</td></tr><tr><td>int</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#nextIndex()">nextIndex</a>() 返回对 next 的后续调用所返回元素的索引。</td></tr><tr><td>E</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#previous()">previous</a>() 返回列表中的前一个元素。</td></tr><tr><td>int</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#previousIndex()">previousIndex</a>() 返回对 previous 的后续调用所返回元素的索引。</td></tr><tr><td>void</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#remove()">remove</a>() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。</td></tr><tr><td>void</td><td><a href="https://www.cnblogs.com/In-order-to-tomorrow/p/3652315.html?utm_source=tuicool&amp;utm_medium=referral#set(E)">set</a>(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。</td></tr></tbody></table><p>　　<strong>可变长度数组的原理：</strong></p><p>　　　　当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。</p><p>　　　　ArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。</p><p>　　　　Vector：是按照原数组的100%延长。</p><p>　　<strong>注意</strong>：<strong>对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。</strong></p><p>　　<strong>LinkedList</strong>：<strong>的特有方法。</strong></p><p>　　　　addFirst();</p><p>　　　　addLast();</p><p>　　在jdk1.6以后。</p><p>　　　　offerFirst();</p><p>　　　　offerLast();</p><p>　　　　getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;</p><p>　　　　getLast();</p><p>　　在jdk1.6以后。</p><p>　　　　peekFirst();获取链表中的第一个元素。如果链表为空，返回null。</p><p>　　　　peekLast();</p><p>　　　　removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException</p><p>　　　　removeLast();</p><p>　　在jdk1.6以后。</p><p>　　　　pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。</p><p>　　　　pollLast();</p><p>——————————————————————————————————————————————————————</p><p><strong>——&lt; java.util &gt;——</strong> <strong>Set接口</strong>：</p><p>　　Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，<strong>迭代器。</strong></p><p>　　　　<strong>|——HashSet</strong>：底层数据结构是哈希表，<strong>线程是不同步的。无序，高效；</strong></p><p>　　　　　　　　HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>　　　　　　　　当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>　　　　　　　　如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>　　　　　　　　如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>　　　　　　<strong>|——LinkedHashSet：有序，hashset的子类。</strong></p><p>　　　　<strong>|——TreeSet</strong>：对Set集合中的元素的进行指定顺序的排序。<strong>不同步</strong>。TreeSet底层的数据结构就是二叉树。</p><p>　　<strong>哈希表的原理：</strong></p><p>　　　　1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。</p><p>　　　　2，哈希值就是这个元素的位置。</p><p>　　　　3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。</p><p>　　　　4，存储哈希值的结构，我们称为哈希表。</p><p>　　　　5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。</p><p>　　　　　　这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。</p><p>　　<strong>对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。</strong></p><p>　　<strong>对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。</strong></p><p>　　<strong>TreeSet:</strong></p><p>　　　　用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p><p>　　　　<strong>如果元素不具备比较性，在运行时会发生ClassCastException异常。</strong></p><p>　　　　所以需要元素实现Comparable接口，强制让元素具备比较性，<strong>复写compareTo方法</strong>。</p><p>　　　　依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。</p><p>　　　　<strong>TreeSet方法保证元素唯一性的方式：</strong>就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p><p>　　<strong>注意</strong>：<strong>在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。</strong></p><p>　　　　<strong>在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。</strong></p><p>　　<strong>TreeSet集合排序有两种方式，Comparable和Comparator区别</strong>：</p><p>　　　　<strong>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</strong></p><p>　　　　<strong>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</strong></p><p>　　　　<strong>第二种方式较为灵活。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>Map集合：</strong></p><p>　　　　<strong>|——Hashtable</strong>：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。</p><p>　　　　<strong>|——HashMap</strong>：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.</p><p>　　　　<strong>|——TreeMap</strong>：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。</p><p>　　Map集合存储和Collection有着很大不同：</p><p>　　　　Collection一次存一个元素；Map一次存一对元素。</p><p>　　　　Collection是单列集合；Map是双列集合。</p><p>　　　　Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p><p>　　　　<strong>特点：要保证map集合中键的唯一性。</strong></p><p>　　<strong>1，添加。</strong></p><p>　　　　 <strong>put</strong>(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。</p><p>　　　　void <strong>putAll</strong>(Map);</p><p>　　<strong>2，删除。</strong></p><p>　　　　void <strong>clear</strong>()：清空</p><p>　　　　value <strong>remove</strong>(key) ：删除指定键。</p><p>　　<strong>3，判断。</strong></p><p>　　　　boolean <strong>isEmpty</strong>()：</p><p>　　　　boolean <strong>containsKey</strong>(key)：是否包含key</p><p>　　　　boolean <strong>containsValue</strong>(value) ：是否包含value</p><p>　　<strong>4，取出。</strong></p><p>　　　　int <strong>size</strong>()：返回长度</p><p>　　　　value <strong>get</strong>(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。</p><p>　　　　Collection <strong>values</strong>()：<strong>获取map集合中的所有的值。</strong></p><p>　　<strong>5，想要获取map中的所有元素：</strong></p><p>　　　　原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。</p><p><strong>★ 把map集合转成set的方法：</strong></p><p>　　Set keySet();</p><p>　　Set entrySet();//取的是键和值的映射关系。</p><p>　　　Entry就是Map接口中的内部接口；</p><p>　　　为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>取出map集合中所有元素的方式一：keySet()方法。</strong></p><p>　　　　可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><p>　　　　　　Set keySet = map.keySet();</p><p>　　　　　　Iterator it = keySet.iterator();</p><p>　　　　　　while(it.hasNext()) {</p><p>　　　　　　　　Object key = it.next();</p><p>　　　　　　　　Object value = map.get(key);</p><p>　　　　　　　　System.out.println(key+”:”+value);</p><p>　　　　　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>取出map集合中所有元素的方式二：entrySet()方法。</strong></p><p>　　　　　　Set entrySet = map.entrySet();</p><p>　　　　　　Iterator it = entrySet.iterator();</p><p>　　　　　　while(it.hasNext()) {</p><p>　　　　　　　　Map.Entry me = (Map.Entry)it.next();</p><p>　　　　　　　　System.out.println(me.getKey()+”::::”+me.getValue());</p><p>　　　　　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>使用集合的技巧：</strong></p><p>　　　　看到Array就是数组结构，有角标，查询速度很快。</p><p>　　　　看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；</p><p>　　　　看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。</p><p>　　　　看到tree就是二叉树，就要想到排序，就想要用到比较。</p><p>　　<strong>比较的两种方式：</strong></p><p>　　　　<strong>一个是Comparable：覆盖compareTo方法；</strong></p><p>　　　　<strong>一个是Comparator：覆盖compare方法。</strong></p><p>　　LinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。</p><p>　　<strong>集合什么时候用？</strong></p><p>　　　　当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。</p><p>　　<strong>保证唯一，就用Set。不保证唯一，就用List。</strong></p><p>——————————————————————————————————————————————————————</p><p>　　<strong>Collections</strong>：<strong>它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。</strong></p><p>　　<strong>静态方法：</strong></p><p>　　　　Collections.<strong>sort</strong>(list);//list集合进行元素的自然顺序排序。</p><p>　　　　Collections.sort(list,new ComparatorByLen());//按指定的比较器方法排序。</p><p>　　　　class ComparatorByLen implements Comparator<string>{</string></p><p>　　　　　　public int compare(String s1,String s2){</p><p>　　　　　　　　int temp = s1.length()—s2.length();</p><p>　　　　　　　　return temp==0?s1.compareTo(s2):temp;</p><p>　　　　　　}</p><p>　　　　}</p><p>　　　　Collections.<strong>max</strong>(list); //返回list中字典顺序最大的元素。</p><p>　　　　int index = Collections.<strong>binarySearch</strong>(list,”zz”);//二分查找，返回角标。</p><p>　　　　Collections.<strong>reverseOrder</strong>();//逆向反转排序。</p><p>　　　　Collections.<strong>shuffle</strong>(list);//随机对list中的元素进行位置的置换。</p><p>　　　<strong>将非同步集合转成同步集合的方法</strong>：<strong>Collections中的</strong> XXX synchronizedXXX(XXX);</p><p>　　　　List synchronizedList(list);</p><p>　　　　Map synchronizedMap(map);</p><p>　　　　<strong>原理：定义一个类，将集合所有的方法加同一把锁后返回。</strong></p><p>　　<strong>Collection 和 Collections的区别：</strong></p><p>　　　　Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>　　　　Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>Arrays：</strong></p><p>　　　　用于操作数组对象的工具类，里面都是静态方法。</p><p>　　　　<strong>asList方法</strong>：<strong>将数组转换成list集合。</strong></p><p>　　　　String[] arr = {“abc”,”kk”,”qq”};</p><p>　　　　List<string> list = Arrays.asList(arr);//将arr数组转成list集合。</string></p><p>　　　　<strong>将数组转换成集合，有什么好处呢？用aslist方法，将数组变成集合；</strong></p><p>　　　　可以通过list集合中的方法来操作数组中的元素：isEmpty()、contains、indexOf、set； </p><p>　　　　<strong>注意（局限性）</strong>：数组是固定长度，不可以使用集合对象增加或者删除等，会改变数组长度的功能方法。比如add、remove、clear。（会报不支持操作异常UnsupportedOperationException）；</p><p>　　　　如果数组中存储的引用数据类型，直接作为集合的元素可以直接用集合方法操作。</p><p>　　　　<strong>如果数组中存储的是基本数据类型，asList会将数组实体作为集合元素存在。</strong></p><p>　　<strong>集合变数组</strong>：用的是Collection接口中的方法：<strong>toArray();</strong></p><p>　　　　如果给toArray传递的指定类型的数据长度小于了集合的size，那么toArray方法，会自定再创建一个该类型的数据，长度为集合的size。</p><p>　　　　如果传递的指定的类型的数组的长度大于了集合的size，那么toArray方法，就不会创建新数组，直接使用该数组即可，并将集合中的元素存储到数组中，其他为存储元素的位置默认值null。</p><p>　　　　所以，在传递指定类型数组时，最好的方式就是指定的长度和size相等的数组。</p><p>　　　<strong>将集合变成数组后有什么好处？</strong>限定了对集合中的元素进行增删操作，只要获取这些元素即可。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>Jdk5.0新特性：</strong></p><p>　　Collection在jdk1.5以后，有了一个父接口Iterable，这个接口的出现的将iterator方法进行抽取，提高了扩展性。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>增强for循环</strong>：<strong>foreach语句</strong>，foreach简化了迭代器。</p><p>　　　　格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器</p><p>　　　　<strong>for( 元素类型 变量名 : Collection集合 &amp; 数组 ) {</strong></p><p>　　　　　　<strong>…</strong></p><p>　　　　<strong>}</strong></p><p>　　<strong>高级for循环和传统for循环的区别：</strong></p><p>　　　　高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，<strong>需要使用迭代器。</strong></p><p>　　　　如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。</p><p>　　<strong>高级for循环可以遍历map集合吗？</strong>不可以。但是可以将map转成set后再使用foreach语句。</p><p>　　<strong>1)、作用</strong>：对存储对象的容器进行迭代： 数组 collection  map</p><p>　　<strong>2)、增强for循环迭代数组</strong>：</p><p>　　　　String [] arr = {“a”, “b”, “c”};//数组的静态定义方式，只试用于数组首次定义的时候</p><p>　　　　for(String s : arr) {</p><p>　　　　　　System.out.println(s);</p><p>　　　　}</p><p>　　<strong>3)、单列集合 Collection：</strong></p><p>　　　　List list = new ArrayList();</p><p>　　　　list.add(“aaa”);</p><p>　　　　// 增强for循环, 没有使用泛型的集合能不能使用增强for循环迭代？能</p><p>　　　　for(Object obj : list) {</p><p>　　　　　　String s = (String) obj;</p><p>　　　　　　System.out.println(s);</p><p>　　　　}</p><p>　　<strong>4)、双列集合 Map：</strong></p><p>　　　　Map map = new HashMap();</p><p>　　　　map.put(“a”, “aaa”);</p><p>　　　　<strong>// 传统方式：必须掌握这种方式</strong></p><p>　　　　Set entrys = map.entrySet(); // 1.获得所有的键值对Entry对象</p><p>　　　　iter = entrys.iterator(); // 2.迭代出所有的entry</p><p>　　　　while(iter.hasNext()) {</p><p>　　　　　　Map.Entry entry = (Entry) iter.next();</p><p>　　　　　　String key = (String) entry.getKey(); // 分别获得key和value</p><p>　　　　　　String value = (String) entry.getValue();</p><p>　　　　　　System.out.println(key + “=” + value);</p><p>　　　　}</p><p>　　　　<strong>// 增强for循环迭代</strong>：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。</p><p>　　　　<strong>for(Object obj : map.entrySet()) {</strong></p><p>　　　　　　<strong>Map.Entry entry = (Entry) obj; // obj 依次表示Entry</strong></p><p>　　　　　　<strong>System.out.println(entry.getKey() + “=” + entry.getValue());</strong></p><p>　　　　<strong>}</strong></p><p>　　<strong>5）、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listIterator：有增删的方法）。</strong></p><p>　　<strong>6)、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值；</strong></p><p>　　　　int[] arr = {1,2,3};</p><p>　　　　for(int num : arr) {</p><p>　　　　　　num = 0; //不能改变数组的值</p><p>　　　　}</p><p>　　　　System.out.println(arr[1]); //2</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>可变参数（…）</strong>：用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。</p><p>　　<strong>和以前接收数组不一样的是</strong>：</p><p>　　　　以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。</p><p>　　　　如果在参数列表中使用了可变参数，<strong>可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。</strong></p><p>　　　　如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>静态导入</strong>：导入了类中的所有静态成员，简化静态成员的书写。</p><p>　　　　import static java.util.Collections.*; //导入了Collections类中的所有静态成员</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>枚举：关键字 enum</strong></p><p>　　　　<strong>问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；</strong></p><p>　　解决办法：</p><p>　　　　1）、在setGrade方法中做判断，不符合格式要求就抛出异常；</p><p>　　　　2）、直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个Grade类，私有构造函数，对外提供5个静态的常量表示类的实例；</p><p>　　　　3)、jdk5中新定义了枚举类型，专门用于解决此类问题；</p><p>　　　　4)、枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>自动拆装箱</strong>：java中数据类型分为两种 ： 基本数据类型  引用数据类型(对象)</p><p>　　　　在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：</p><p>　　　　　　int ——&gt; Integer</p><p>　　　　　　byte ——&gt; Byte</p><p>　　　　　　short ——&gt; Short</p><p>　　　　　　long ——&gt; Long</p><p>　　　　　　char ——&gt; Character</p><p>　　　　　　double ——&gt; Double</p><p>　　　　　　float ——&gt; Float</p><p>　　　　　　boolean ——&gt; Boolean</p><p>　　jdk5以前基本数据类型和包装类之间需要互转：</p><p>　　　　基本———引用  Integer x = new Integer(x);</p><p>　　　　引用———基本  int num = x.intValue();</p><p>　　　　　　1)、Integer x = 1; x = x + 1; 经历了什么过程？<strong>装箱 ——&gt; 拆箱——&gt; 装箱；</strong></p><p>　　　　　　2)、为了优化，虚拟机为包装类提供了缓冲池，<strong>Integer池的大小 —128~127 一个字节的大小；</strong></p><p>　　　　　　3)、<strong>String**</strong>池**：Java为了优化字符串操作 提供了一个缓冲池；</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>泛型：</strong>jdk1.5版本以后出现的一个安全机制。表现格式：&lt; &gt;</p><p>　　好处：</p><p>　　　　1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。</p><p>　　　　2：避免了强制转换的麻烦。</p><p>　　只要带有&lt;&gt;的类或者接口，都属于带有类型参数的类或者接口，在使用这些类或者接口时，必须给&lt;&gt;中传递一个具体的引用数据类型。</p><p>　　<strong>泛型技术</strong>：其实应用在编译时期，是给编译器使用的技术，到了运行时期，泛型就不存在了。</p><p>　　为什么? <strong>因为泛型的擦除</strong>：也就是说，编辑器检查了泛型的类型正确后，在生成的类文件中是没有泛型的。</p><p>　　<strong>在运行时，如何知道获取的元素类型而不用强转呢？</strong></p><p>　　<strong>泛型的补偿</strong>：因为存储的时候，类型已经确定了是同一个类型的元素，所以在运行时，只要获取到该元素的类型，在内部进行一次转换即可，所以使用者不用再做转换动作了。</p><p>　　<strong>什么时候用泛型类呢？</strong></p><p>　　　　当类中的操作的引用数据类型不确定的时候，以前用的Object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>泛型在程序定义上的体现：</strong></p><p>　　<strong>//泛型类：将泛型定义在类上。</strong></p><p>　　class Tool<q> {</q></p><p>　　　　private Q obj;</p><p>　　　　public void setObject(Q obj) {</p><p>　　　　　　this.obj = obj;</p><p>　　　　}</p><p>　　　　public Q getObject() {</p><p>　　　　　　return obj;</p><p>　　　　}</p><p>　　}</p><p>　　<strong>//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。</strong></p><p>　　public <w> void method(W w) {</w></p><p>　　　　System.out.println(“method:”+w);</p><p>　　}</p><p>　　<strong>//静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>　　public static <q> void function(Q t) {</q></p><p>　　　　System.out.println(“function:”+t);</p><p>　　}</p><p>　　<strong>//泛型接口.</strong></p><p>　　interface Inter<t> {</t></p><p>　　　　void show(T t);</p><p>　　}</p><p>　　class InterImpl<r> implements Inter<r> {</r></r></p><p>　　　　public void show(R r) {</p><p>　　　　　　System.out.println(“show:”+r);</p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　　　<strong>泛型中的通配符</strong>：可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><p>　　<strong>泛型限定：</strong></p><p>　　　　上限：？extends E：可以接收E类型或者E的子类型对象。</p><p>　　　　下限：？super E：可以接收E类型或者E的父类型对象。</p><p>　　<strong>上限什么时候用</strong>：往集合中添加元素时，既可以添加E类型对象，又可以添加E的子类型对象。为什么？因为取的时候，E类型既可以接收E类对象，又可以接收E的子类型对象。</p><p>　　<strong>下限什么时候用：</strong>当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。</p><p>　　<strong>泛型的细节：</strong></p><p>　　　　1）、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是Object类型；</p><p>　　　　2）、使用带泛型的类创建对象时，等式两边指定的泛型必须一致；</p><p>　　　　　　原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了；</p><p>　　　　3）、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)；</p><p>　　　　　　ArrayList<string> al = new ArrayList<object>(); //错<p></p><p>　　　　　　<strong>//要保证左右两边的泛型具体类型一致就可以了，这样不容易出错。</strong></p><p>　　　　　　ArrayList&lt;? extends Object&gt; al = new ArrayList<string>();</string></p><p>　　　　　　al.add(“aa”); //错</p><p>　　　　　　//因为集合具体对象中既可存储String，也可以存储Object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends Object 代表Object的子类型不确定，怎么能添加具体类型的对象呢？</p><p>　　　　　　public static void method(ArrayList&lt;? extends Object&gt; al) {</p><p>　　　　　　　　al.add(“abc”); //错</p><p>　　　　　　<strong>//只能对al集合中的元素调用Object类中的方法，具体子类型的方法都不能用，因为子类型不确定。</strong></p><p>　　　　　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API**</strong>——— java.lang.<strong>**System</strong>: 属性和行为都是静态的。</p><p>　　<strong>long currentTimeMillis(); // 返回当前时间毫秒值</strong></p><p>　　<strong>exit(); // 退出虚拟机</strong></p><p>　　<strong>Properties</strong> <strong>getProperties**</strong>() ;** <strong>// 获取当前系统的属性信息</strong></p><p>　　Properties prop = System.getProperties(); <strong>//获取系统的属性信息，并将这些信息存储到Properties集合中。</strong> </p><p>　　System.setProperty(“myname”,”毕老师”); <strong>//给系统属性信息集添加具体的属性信息</strong></p><p>　　<strong>//临时设置方式：运行jvm时，可以通过jvm的参数进行系统属性的临时设置，可以在java命令的后面加入 –D= 用法：java –Dmyname=小明 类名。</strong></p><p>　　String name = System.getProperty(“os.name”);<strong>//获取指定属性的信息</strong></p><p>　　<strong>//想要知道该系统是否是该软件所支持的系统中的一个。</strong></p><p>　　Set<string> hs = new HashSet<string>();</string></string></p><p>　　hs.add(“Windows XP”);</p><p>　　hs.add(“Windows 7”);</p><p>　　if(hs.contains(name))</p><p>　　System.out.println(“可以支持”);</p><p>　　else</p><p>　　System.out.println(“不支持”);</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API**</strong>——— java.lang.<strong>**Runtime</strong>: 类中没有构造方法，不能创建对象。</p><p>　　　　但是有非静态方法。说明该类中应该定义好了对象，并可以通过一个static方法获取这个对象。用这个对象来调用非静态方法。这个方法就是 static Runtime getRuntime();</p><p>　　<strong>这个Runtime其实使用单例设计模式进行设计。</strong></p><p>　　class RuntimeDemo {</p><p>　　　　public static void main(String[] args) throws Exception {</p><p>　　　　　　Runtime r = Runtime.getRuntime();</p><p>　　　　　　Process p = r.exec(“notepad.exe SystemDemo.java”); //运行指定的程序</p><p>　　　　　　Thread.sleep(4000);</p><p>　　　　　　p.destroy(); <strong>//杀掉进程</strong></p><p>　　　　}</p><p>　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API**</strong>——— java.util.Math**: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。</p><p>　　　　static double ceil(double a) ; //返回大于指定数值的最小整数</p><p>　　　　static double floor(double a) ; //返回小于指定数值的最大整数</p><p>　　　　static long round(double a) ; //四舍五入成整数</p><p>　　　　static double pow(double a, double b) ; //a的b次幂</p><p>　　　　static double random(); //返回0~1的伪随机数</p><p>　　　　public static void main(String[] args) {</p><p>　　　　　　Random r = new Random();</p><p>　　　　　　for(int x=0; x&lt;10; x++) {</p><p>　　　　　　　　//double d = Math.floor(Math.random()*10+1);</p><p>　　　　　　　　//int d = (int)(Math.random()*10+1);</p><p>　　　　　　　　int d = r.nextInt(10)+1;</p><p>　　　　　　　　System.out.println(d);</p><p>　　　　　　}</p><p>　　　　}</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API——— java.util.Date</strong>：日期类，月份从0—11；</p><p>　　　　<strong>/*</strong></p><p>　　　　<strong>日期对象和毫秒值之间的转换。</strong></p><p>　　　　　　<strong>1，日期对象转成毫秒值。Date类中的getTime方法。</strong></p><p>　　　　　　<strong>2，如何将获取到的毫秒值转成具体的日期呢？</strong></p><p>　　　　　　　　<strong>Date类中的setTime方法。也可以通过构造函数。</strong> </p><p>　　　　*<strong>/</strong></p><p>　　　　<strong>//日期对象转成毫秒值</strong></p><p>　　　　　　Date d = new Date();</p><p>　　　　　　long time1 = d.getTime();</p><p>　　　　　　long time2 = System.currentTimeMillis(); / /毫秒值。</p><p>　　　　<strong>//毫秒值转成具体的日期</strong></p><p>　　　　　　long time = 1322709921312l;</p><p>　　　　　　Date d = new Date();</p><p>　　　　　　d.setTime(time);</p><p>　　　　<strong>/*</strong></p><p>　　　　<strong>将日期字符串转换成日期对象：使用的就是DateFormat方法中的 Date parse(String source) ；</strong></p><p>　　　　*<strong>/</strong></p><p>　　　　public static void method() throws Exception {</p><p>　　　　　　String str_time = “2011/10/25”;</p><p>　　　　　　DateFormat df = new SimpleDateFormat(“yyyy/MM/dd”); <strong>//SimpleDateFormat作为可以指定用户自定义的格式来完成格式化。</strong></p><p>　　　　　　Date d = df.parse(str_time);</p><p>　　　　}</p><p>　　　　<strong>/*</strong></p><p>　　　　<strong>如果不需要使用特定的格式化风格，完全可以使用DateFormat类中的静态工厂方法获取具体的已经封装好风格的对象。getDateInstance();getDateTimeInstance();</strong></p><p>　　　　*<strong>/</strong></p><p>　　　　Date d = new Date();</p><p>　　　　DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);</p><p>　　　　df = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</p><p>　　　　String str_time = df.format(d);</p><p>　　<strong>//将日期对象转换成字符串的方式：DateFormat类中的format方法。</strong></p><p>  　 <strong>//创建日期格式对象。</strong> </p><p>　　　　　　DateFormat df = new SimpleDateFormat(); <strong>//该对象的建立内部会封装一个默认的日期格式。11—12—1 下午1:48</strong></p><p>　　　　<strong>//如果想要自定义日期格式的话。可使用SimpleDateFormat**</strong>的构造函数。将具体的格式作为参数传入到构造函数中。如何表示日期中年的部分呢？可以必须要参与格式对象文档。** </p><p>　　　　<strong>df = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss”);</strong></p><p>　　　　<strong>//调用DateFormat中的format方法。对已有的日期对象进行格式化。</strong></p><p>　　　　String str_time = df.format(d);</p><p>——————————————————————————————————————————————————————</p><p>　　<strong>API——— java.util. Calendar</strong>：日历类</p><p>　　　　public static void method(){</p><p>　　　　　　Calendar c = Calendar.getInstance();</p><p>　　　　　　System.out.println(c.get(Calendar.YEAR)+”年”+(c.get(Calendar.MONTH)+1)+”月”</p><p>　　　　　　　　　　　　　　　　　　　　　　　　+getNum(c.get(Calendar.DAY_OF_MONTH))+”日”</p><p>　　　　　　　　　　　　　　　　　　　　　　　　+”星期”+getWeek(c.get(Calendar.DAY_OF_WEEK)));</p><p>　　　　}</p><p>　　　　public static String getNum(int num){</p><p>　　　　　　return num&gt;9 ? num+”” : “0”+num;</p><p>　　　　}</p><p>　　　　public static String getWeek(int index){</p><p>　　　　/*</p><p>　　　　查表法：建立数据的对应关系.</p><p>　　　　最好：数据个数是确定的，而且有对应关系。如果对应关系的一方，是数字，而且可以作为角标，那么可以通过数组来作为表。</p><p>　　　　*/</p><p>　　　　　　String[] weeks = {“”,”日”,”一”,”二”,”三”,”四”,”五”,”六”};</p><p>　　　　　　return weeks[index];</p><p>　　　　}</p></object></string></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java语法基础&quot;&gt;&lt;a href=&quot;#java语法基础&quot; class=&quot;headerlink&quot; title=&quot;java语法基础&quot;&gt;&lt;/a&gt;java语法基础&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1，关键字&lt;/strong&gt;：其实就是某种语言赋予了特殊含义的单词。&lt;/p&gt;</summary>
      
    
    
    
    <category term="面向对象" scheme="https://rain-sky.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://rain-sky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://rain-sky.github.io/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://rain-sky.github.io/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-12T09:38:09.000Z</published>
    <updated>2021-02-14T10:51:19.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="第一章：计算机系统概论"><a href="#第一章：计算机系统概论" class="headerlink" title="第一章：计算机系统概论"></a>第一章：计算机系统概论</h2><h3 id="1-1计算机系统简介"><a href="#1-1计算机系统简介" class="headerlink" title="1.1计算机系统简介"></a>1.1计算机系统简介</h3><p><strong>第一台电子数字计算机：ENIAC(1946年)</strong></p><p>计算机 = 硬件 + 软件</p><img src="https://img.rruu.net/image/60065c0dda4fb" alt="结构" style="zoom:50%;"><p>一个简单的系统结构</p><img src="https://img.rruu.net/image/60065b93e6211" alt="系统结构" style="zoom:50%;"><h3 id="1-2-认识各个硬件"><a href="#1-2-认识各个硬件" class="headerlink" title="1.2 认识各个硬件"></a>1.2 认识各个硬件</h3><h4 id="1-2-1冯·诺依曼计算机的特点"><a href="#1-2-1冯·诺依曼计算机的特点" class="headerlink" title="1.2.1冯·诺依曼计算机的特点"></a>1.2.1冯·诺依曼计算机的特点</h4><ol><li>计算机由五大部件组成</li><li>指令和数据以同等地位于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序</li><li>**以运算器为中心 ** (存在弊端)</li></ol><img src="https://img.rruu.net/image/60065eee6fca3" style="zoom: 67%;"><p>​                                                                                            以运算器为中心的硬件框图</p><h4 id="1-2-2现代计算机以存储器为中心"><a href="#1-2-2现代计算机以存储器为中心" class="headerlink" title="1.2.2现代计算机以存储器为中心"></a>1.2.2现代计算机以存储器为中心</h4><img src="https://img.rruu.net/image/60066907cf245" alt="现代计算机" style="zoom: 33%;"><p><em>现代计算机结构中控制器和运算器继承于cpu中。</em></p><p>cpu结构：CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示 <strong>（该解释来自于百度百科）</strong></p><p><img src="https://img.rruu.net/image/60066be9352df"></p><h5 id="cpu调度主存储器"><a href="#cpu调度主存储器" class="headerlink" title="cpu调度主存储器"></a>cpu调度主存储器</h5><p><img src="https://img.rruu.net/image/6006703fdd8af"></p><p>主存：运行内存</p><p>辅存：机械硬盘，固态硬盘(应当看作io设备)</p><p><img src="https://img.rruu.net/image/6029001dc6ed0"></p><hr><p><strong><em>特别注意：mar与mdr在功能上属于主存储器，但在微小型机器中放入cpu中，作为主存和CPU的联系接口。</em></strong></p><hr><blockquote><p><strong>地址总线</strong>（<strong>Address Bus</strong>）是一种计算机总线，是CPU或有DMA能力的单元，用来沟通这些单元想要访问（读取/写入）计算机内存组件/地方的物理地址。</p><p>数据总线的宽度，随可寻址的内存组件大小而变，决定有多少的内存可以被访问。</p><p>举例来说：一个 16位元 宽度的位址总线 (通常在 1970年 和 1980年早期的 8位元处理器中使用) 到达 2 的 16 次方 = 65536 = 64 KB 的内存位址，而一个 32位单元位址总线 (通常在像现今 2004年 的 PC 处理器中) 可以寻址到 4,294,967,296 = 4 GB 的位址。但现在很多计算机内存已经大于4G（windows XP x32位系统最大只能识别3.29G，所以要使用4G以上大内存就要用windows x64位系统）。所以主流的计算机都是64位的处理器也就是说可以寻址到2^64=16X10^18=16EB的位址，在很长一段时间内这个数字是用不完的。</p><p>​                                                                                                                                                                        ——引用自百度百科地址总线</p></blockquote><p>*<em>一个例子：C语言中，在寻址能力为64位的CPU上，当我们定义一个int <em>p指针。输出sizeof(p);输出为8(即八个字节)，因为地址是64位二进制数表示的；</em></em></p><blockquote><p><strong>数据总线(DataBus)。</strong>规范了一个大的集成应用系统中同构系统、<a href="https://baike.baidu.com/item/%E5%BC%82%E6%9E%84%E7%B3%BB%E7%BB%9F">异构系统</a>等方面进行<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB">数据共享</a>和交换实现方法，系统间数据交换标准。可用于微处理与内存，微处理器与输入输出接口之间传送信息。数据总线的宽度是决定计算机性能的一个重要指标。微型计算机的数据总线大多是32位或64位。</p><p>​                                                                                                                                                                        ——引用自百度百科数据总线</p></blockquote><blockquote><p>cpu的位宽，操作系统的位宽和寻址能力的关系(参考博客)：</p><p><a href="https://blog.csdn.net/wwwlyj123321/article/details/99940786">https://blog.csdn.net/wwwlyj123321/article/details/99940786</a></p><p><a href="https://blog.csdn.net/haiross/article/details/50977805">https://blog.csdn.net/haiross/article/details/50977805</a></p><p>mdr和数据总线的取别（注意文中所说mdr位数与数据总线宽度可能不一致，现实计算机情况下相同）：</p><p><a href="https://blog.csdn.net/qq_42883292/article/details/106703544">https://blog.csdn.net/qq_42883292/article/details/106703544</a></p></blockquote><p><strong><em>特别注意：</em></strong></p><p><strong>1.64位操作系统是指特别为64位架构<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>系统而设计的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>。</strong></p><p><strong>2.CPU的位宽一般是以 min{ALU位宽、通用寄存器位宽、数据总线位宽}决定的！也就是说CPU由ALU、通用寄存器、数据总线三者之中最少的位宽决定！所以CPU位宽与其寻址能力并不是挂钩的！</strong></p><h5 id="主存储器的存储体"><a href="#主存储器的存储体" class="headerlink" title="主存储器的存储体"></a>主存储器的存储体</h5><p><img src="https://img.rruu.net/image/60067803e1e00"></p><h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p><img src="https://img.rruu.net/image/600a73f063d41"></p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p><img src="https://img.rruu.net/image/600a742889496"></p><hr><p>一次工作过程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b = <span class="number">3</span>,c = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">y = a*b +c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>高级语言最终解释翻译成机器语言读入主存中内存如图所示，工作过程如下——</p><p><strong>PS：由内存结构反映出冯·诺依曼计算机的特点2,4。</strong></p><p><img src="https://img.rruu.net/image/600a7e30a7728"></p><hr><h4 id="1-2-3硬件回顾"><a href="#1-2-3硬件回顾" class="headerlink" title="1.2.3硬件回顾"></a>1.2.3硬件回顾</h4><p><img src="https://img.rruu.net/image/600a7bb91d818" alt="image-20210122151524030"></p><h3 id="1-3计算机的性能指标"><a href="#1-3计算机的性能指标" class="headerlink" title="1.3计算机的性能指标"></a>1.3计算机的性能指标</h3><p><strong>1.3.1 mar位数</strong></p><p>mar位数反映存储单元的个数（最多）</p><p>1byte = 8 bit，1 KB = 1024 byte，1MB = 1024 KB，1GB = 1024 MB</p><p>总内存（理论最大值） = 2的mar位数次方×存储字长(mdr位数) /bit</p><p>EG: mar32位，mdr 8位，则总容量4GB。</p><p><strong>1.3.2 cpu主频</strong></p><p>cpu主频：CPU内数字脉冲信号的震荡频率。（常达GHZ）</p><p>CPI（clock cycle per Instruction）: 执行一条指令需要的时钟周期数。</p><p>时钟周期：完成一个脉冲耗时。（单位，微秒，纳秒）</p><p>cpu主频 = 1 /时钟周期</p><p>执行一条指令耗时 = CPI × CPU时钟周期</p><p>IPS（Instruction per  second）：每秒钟执行指令条数。</p><p>IPS = 主频 / 平均CPI</p><p>FLOPS：每秒执行多少次浮点运算。</p><blockquote><p>不同指令，CPI可能不同，甚至相同指令CPI也可能不同（与cpu内部的指令实现有关）。</p></blockquote><p><strong>1.3.3 数据通路带宽</strong></p><p>数据总线一次性并行传输数据位数。</p><p><strong>1.3.4 吞吐量和响应时间</strong></p><p>吞吐量：计算机单位时间内处理请求个数。</p><p>响应时间：从发起请求到收到结果所需时间。</p><hr><p><img src="https://img.rruu.net/image/600a97fb2c926"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h1&gt;&lt;h2 id=&quot;第一章：计算机系统概论&quot;&gt;&lt;a href=&quot;#第一章：计算机系统概论&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://rain-sky.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计组" scheme="https://rain-sky.github.io/tags/%E8%AE%A1%E7%BB%84/"/>
    
    <category term="底层" scheme="https://rain-sky.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="https://rain-sky.github.io/2020/12/31/spring/"/>
    <id>https://rain-sky.github.io/2020/12/31/spring/</id>
    <published>2020-12-31T01:59:09.000Z</published>
    <updated>2021-04-17T06:11:52.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote><p>简介</p></blockquote><p>Spring : 春天 —&gt;给软件行业带来了春天</p><p>2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。</p><p>2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。</p><p>很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</p><p>Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术</p><p>官网 : <a href="http://spring.io/">http://spring.io/</a></p><p>官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p><p>GitHub : <a href="https://github.com/spring-projects">https://github.com/spring-projects</a></p><blockquote><p>优点</p></blockquote><p>1、Spring是一个开源免费的框架 , 容器  .</p><p>2、Spring是一个轻量级的框架 , 非侵入式的 .</p><p><strong>3、控制反转 IoC  , 面向切面 Aop</strong></p><p>4、对事物的支持 , 对框架的支持</p><p>…….</p><p>一句话概括：</p><p><strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p><blockquote><p>组成</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF6KnNia5YDhfatibrMvAUAhxgF27g4HdJsBGl6Fae9yQlUQJc9Bf8uftw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFetRkkw19r7H3mHDibgs4RpRNHdG6CcIMdnxRCu2yYXNiano7ESCCMF0A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><ul><li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li><li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><blockquote><p>拓展</p></blockquote><p><strong>Spring Boot与Spring Cloud</strong></p><ul><li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</li><li>Spring Cloud是基于Spring Boot实现的；</li><li>Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；</li><li>Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</li><li>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFH5GFXM4YPUGrmA2JdpPic3FwYaI1JZHBZxibaUJVXWzzTFeCayk4XAIg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>IOC理论推导</p><h2 id="IoC基础"><a href="#IoC基础" class="headerlink" title="IoC基础"></a>IoC基础</h2><p>新建一个空白的maven项目</p><blockquote><p>分析实现</p></blockquote><p>我们先用我们原来的方式写一段代码 .</p><p>1、先写一个UserDao接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、再去写Dao的实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"获取用户数据"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、然后去写UserService的接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4、最后写Service的实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>5、测试一下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">   UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">   service.getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p><p>把Userdao的实现类增加一个 .</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMySqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"MySql获取用户数据"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoMySqlImpl();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在假设, 我们再增加一个Userdao的实现类 .</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"Oracle获取用户数据"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p><p><strong>那我们如何去解决呢 ?</strong> </p><p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">// 利用set实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>{</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在去我们的测试类里 , 进行测试 ;</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">   UserServiceImpl service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">   service.setUserDao( <span class="keyword">new</span> UserDaoMySqlImpl() );</span><br><span class="line">   service.getUser();</span><br><span class="line">   <span class="comment">//那我们现在又想用Oracle去实现呢</span></span><br><span class="line">   service.setUserDao( <span class="keyword">new</span> UserDaoOracleImpl() );</span><br><span class="line">   service.getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p><p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p><blockquote><p>IOC本质</p></blockquote><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FFuYibmavlBHq9e4cDqiclpYSG8VT4EicVsnqKp65yJKQeNibsVdTiahQibJSg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p><p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p><h2 id="HelloSpring"><a href="#HelloSpring" class="headerlink" title="HelloSpring"></a>HelloSpring</h2><blockquote><p>导入Jar包</p></blockquote><p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>编写代码</p></blockquote><p>1、编写一个Hello实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">  }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"Hello,"</span>+ name );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Hello"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、我们可以去进行测试了 .</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   <span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line">   Hello hello = (Hello) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">   hello.show();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>思考</p></blockquote><ul><li>Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的】</li><li>Hello 对象的属性是怎么设置的 ?  hello 对象的属性是由Spring容器设置的</li></ul><p><strong>这个过程就叫控制反转 :</strong></p><ul><li><strong>控制</strong> : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li><li>**反转 **: 程序本身不创建对象 , 而变成被动的接收对象 .</li></ul><p>依赖注入 : 就是利用set方法来进行注入的.</p><p> IOC是一种编程思想，由主动的编程变成被动的接收</p><p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p><blockquote><p>修改案例一</p></blockquote><p>我们在案例一中， 新增一个Spring配置文件beans.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MysqlImpl"</span> <span class="attr">class</span>=<span class="string">"com.kuang.dao.impl.UserDaoMySqlImpl"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"OracleImpl"</span> <span class="attr">class</span>=<span class="string">"com.kuang.dao.impl.UserDaoOracleImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.kuang.service.impl.UserServiceImpl"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"OracleImpl"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(<span class="string">"ServiceImpl"</span>);</span><br><span class="line">   serviceImpl.getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! </p><h2 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h2><blockquote><p>通过无参构造方法来创建</p></blockquote><p>1、User.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"user无参构造方法"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"name="</span>+ name );</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、beans.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kuangshen"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   <span class="comment">//在执行getBean的时候, user已经创建好了 , 通过无参构造</span></span><br><span class="line">   User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">   <span class="comment">//调用对象的方法 .</span></span><br><span class="line">   user.show();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p><blockquote><p>通过有参构造方法来创建</p></blockquote><p>1、UserT . java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserT</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">UserT</span><span class="params">(String name)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"name="</span>+ name );</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、beans.xml 有三种方式编写</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"kuangshen2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二种根据参数名字设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kuangshen2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userT"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.UserT"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"kuangshen2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testT</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserT user = (UserT) context.getBean(<span class="string">"userT"</span>);</span><br><span class="line">   user.show();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</strong></p><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><blockquote><p>别名</p></blockquote><p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"userT"</span> <span class="attr">alias</span>=<span class="string">"userNew"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Bean的配置</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">   如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">   name可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class是bean的全限定名=包名+类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">name</span>=<span class="string">"hello2 h2,h3;h4"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Hello"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>import</p></blockquote><p>团队的合作通过import来实现 .</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"{path}/beans.xml"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><blockquote><p>概念</p></blockquote><ul><li>依赖注入（Dependency Injection,DI）。</li><li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li><li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .</li></ul><blockquote><p>构造器注入</p></blockquote><p>我们在之前的案例已经讲过了</p><blockquote><p>Set 注入 （重点）</p></blockquote><p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p><p>测试pojo类 :</p><p>Address.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Student.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(String[] books)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.books = books;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.hobbys = hobbys;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(Set&lt;String&gt; games)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Properties info)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+ name</span><br><span class="line">                + <span class="string">",address="</span>+ address.getAddress()</span><br><span class="line">                + <span class="string">",books="</span></span><br><span class="line">       );</span><br><span class="line">        <span class="keyword">for</span> (String book:books){</span><br><span class="line">            System.out.print(<span class="string">"&lt;&lt;"</span>+book+<span class="string">"&gt;&gt;\t"</span>);</span><br><span class="line">       }</span><br><span class="line">        System.out.println(<span class="string">"\n爱好:"</span>+hobbys);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"card:"</span>+card);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"games:"</span>+games);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"wife:"</span>+wife);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"info:"</span>+info);</span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1、<strong>常量注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小明"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>{</span><br><span class="line">     ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"> </span><br><span class="line">     Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line"> </span><br><span class="line">     System.out.println(student.getName());</span><br><span class="line"> </span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>2、<strong>Bean注入</strong> </p><p><em>注意点：这里的值是一个引用，ref</em></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"addr"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Address"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"重庆"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小明"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"addr"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、<strong>数组注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小明"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"addr"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>4、<strong>List注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbys"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>爬山<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>5、<strong>Map注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"中国邮政"</span> <span class="attr">value</span>=<span class="string">"456456456465456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"建设"</span> <span class="attr">value</span>=<span class="string">"1456682255511"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>6、<strong>set注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>7、<strong>Null注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>8、<strong>Properties注入</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"学号"</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"性别"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"姓名"</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYGHEFnrCA8Jyr6ian5MWrUHtnKBpYYTTtysbp5UPYKQxSiaUHJibPKlicuQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>p命名和c命名注入</p></blockquote><p>User.java ：【<strong>注意：这里没有有参构造器！</strong>】</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1、P命名空间注入 : 需要在头文件中加入约束文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:p="http://www.springframework.org/schema/p"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"狂神"</span> <span class="attr">p:age</span>=<span class="string">"18"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、c 命名空间注入 : 需要在头文件中加入约束文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:c="http://www.springframework.org/schema/c"</span><br><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">c:name</span>=<span class="string">"狂神"</span> <span class="attr">c:age</span>=<span class="string">"18"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>发现问题：爆红了，刚才我们没有写有参构造！</p><p><strong>解决：把有参构造器加上，这里也能知道，<code>c 就是所谓的构造器注入！</code></strong></p><p>测试代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>{</span><br><span class="line">    ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Bean的作用域</p></blockquote><p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7K5cyS8ZRTpajtSInicNHbMYfmmAQF8hrnicY49FRXEkR5xkxD5A4H5pVUia3mFhrDdh4gBt183EiaFaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p><h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cn.csdn.service.ServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>{</span><br><span class="line">    ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    User user2 = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccount"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line"> 或者</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"account"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccount"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">cn.csdn.LoginAction</span>" <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p><h2 id="自动装配-就是注值的一种方式嘛"><a href="#自动装配-就是注值的一种方式嘛" class="headerlink" title="自动装配(就是注值的一种方式嘛)"></a>自动装配(就是注值的一种方式嘛)</h2><p>Bean的自动装配</p><blockquote><p>自动装配说明</p></blockquote><ul><li><strong>自动装配是使用spring满足bean依赖的一种方法</strong></li><li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li></ul><p>Spring中bean有三种装配机制，分别是：</p><ol><li><p>在xml中显式配置；</p></li><li><p>在java中显式配置；</p></li><li><p>隐式的bean发现机制和自动装配。</p><blockquote><p>个人习惯于在xml中配置或者使用J注解，要获取类上的注解需要开启注解支持</p><p>xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context"</a><br><a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p><p><a href="context:annotation-config/">context:annotation-config/</a></p></blockquote></li></ol><p>这里我们主要讲第三种：自动化的装配bean。</p><p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p><ol><li>**组件扫描(component scanning)**：spring会自动发现应用上下文中所创建的bean；</li><li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li></ol><p><code>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</code></p><p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p><blockquote><p>测试环境搭建</p></blockquote><p>1、新建一个项目</p><p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"miao~"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"wang~"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、新建一个用户类 User</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4、编写Spring配置文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">ref</span>=<span class="string">"cat"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">ref</span>=<span class="string">"dog"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"str"</span> <span class="attr">value</span>=<span class="string">"qinjiang"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>5、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodAutowire</span><span class="params">()</span> </span>{</span><br><span class="line">       ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">       user.getCat().shout();</span><br><span class="line">       user.getDog().shout();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果正常输出，环境OK</p><blockquote><p>byName</p></blockquote><p><strong>autowire byName (按名称自动装配)</strong></p><p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p><p>采用自动装配将避免这些错误，并且使配置简单化。</p><p>测试：</p><p>1、修改bean配置，增加一个属性  autowire=”byName”</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"str"</span> <span class="attr">value</span>=<span class="string">"qinjiang"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、再次测试，结果依旧成功输出！</p><p>3、我们将 cat 的bean id修改为 catXXX</p><p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p><p><strong>小结：</strong></p><p>当一个bean节点带有 autowire byName的属性时。</p><ol><li><p><strong>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</strong></p></li><li><p>去spring容器中寻找是否有此字符串名称id的对象。</p></li><li><p>如果有，就取出注入；如果没有，就报空指针异常。</p></li></ol><blockquote><p>byType</p></blockquote><p><strong>autowire byType (按类型自动装配)</strong></p><p>使用autowire byType首先需要<strong>保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException</span><br></pre></td></tr></tbody></table></figure><p>测试：</p><p>1、将user的bean配置修改一下 ： autowire=”byType”</p><p>2、测试，正常输出</p><p>3、<strong>再注册一个cat 的bean对象！</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"str"</span> <span class="attr">value</span>=<span class="string">"qinjiang"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>4、<strong>测试，报错：NoUniqueBeanDefinitionException</strong></p><p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p><p>这就是按照类型自动装配！</p><p>使用注解</p><blockquote><p>使用注解</p></blockquote><p><strong>jdk1.5开始支持注解，spring2.5开始全面支持注解。</strong></p><p>准备工作：利用注解的方式注入属性。</p><p>1、在spring配置文件中引入context文件头</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></tbody></table></figure><p>2、开启属性注解支持！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li>@Autowired是按类型自动转配的，不支持id匹配。</li><li>需要导入 spring-aop的包！</li></ul><p>测试：</p><p>1、将User类中的set方法去掉，使用@Autowired注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> cat;</span><br><span class="line">  }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> dog;</span><br><span class="line">  }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、此时配置文件内容</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、测试，成功输出结果！</p><p>【小狂神科普时间】</p><p><strong>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></tbody></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul><li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li><li>@Qualifier不能单独使用。</li></ul><p>测试实验步骤：</p><p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、没有加Qualifier测试，直接报错</p><p>3、在属性上添加Qualifier注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = "cat2")</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = "dog2")</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></tbody></table></figure><p>测试，成功输出！</p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul><li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li><li>其次再进行默认的byName方式进行装配；</li><li><code>如果以上都不成功，则按byType的方式自动装配。</code></li><li>都不成功，则报异常。</li></ul><p>实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line">   <span class="meta">@Resource(name = "cat2")</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="keyword">private</span> String str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>beans.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试：结果OK</p><p>配置文件2：beans.xml ， 删掉cat2</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Cat"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>实体类上只保留注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></tbody></table></figure><p>结果：OK</p><p>结论：先进行byName查找，失败；再进行byType查找，成功。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>@Autowired与@Resource异同：</p><p>1、@Autowired与@Resource都可以用来装配bean。<code>都可以写在字段上，或写在setter方法上</code>。</p><p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p><p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在set方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。<strong>但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</strong></p><p><code>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</code></p><p><code>两注解均为用于注入引用类型</code></p><h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><blockquote><p>说明</p></blockquote><p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IzypAUHDfDEujP4ry6cHxWTvAS6qRS0qrmMCic3QqF9icGNcPj8IZwNo3R9VEgpAgWHrStBN1ya6Tg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>在配置文件当中，还得要引入一个context约束</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Bean的实现</p></blockquote><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p><p>1、配置扫描哪些包下的注解</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kuang.pojo"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、在指定包下编写类，增加注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component("user")</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id="user" class="当前注解的类"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="keyword">public</span> String name = <span class="string">"秦疆"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext applicationContext =</span><br><span class="line">       <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br><span class="line">   System.out.println(user.name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>属性注入</p></blockquote><p>使用注解注入属性</p><p>1、可以不用提供set方法，直接在直接名上添加@value(“值”)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component("user")</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id="user" class="当前注解的类"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="meta">@Value("秦疆")</span></span><br><span class="line">   <span class="comment">// 相当于配置文件中 &lt;property name="name" value="秦疆"/&gt;</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、如果提供了set方法，在set方法上添加@value(“值”);</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component("user")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value("秦疆")</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>衍生注解</p></blockquote><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p><p><strong>@Component三个衍生注解</strong></p><p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p><ul><li>@Controller：web层(springMvc中注册一个controller)</li><li>@Service：service层</li><li>@Repository：dao层</li></ul><p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p><blockquote><p>自动装配注解</p></blockquote><p>在Bean的自动装配已经讲过了，可以回顾！</p><blockquote><p>作用域</p></blockquote><p>@scope</p><ul><li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li><li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller("user")</span></span><br><span class="line"><span class="meta">@Scope("prototype")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="meta">@Value("秦疆")</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>小结</p></blockquote><p><strong>XML与注解比较</strong></p><ul><li>XML可以适用任何场景 ，结构清晰，维护方便</li><li>注解不是自己提供的类使用不了，开发简单方便</li></ul><p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p><ul><li>xml管理Bean</li><li>注解完成属性注入</li><li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span>  </span><br></pre></td></tr></tbody></table></figure><p>作用：</p><ul><li><p>进行注解驱动注册，从而使注解生效</p></li><li><p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p></li><li><p>如果不扫描包，就需要手动配置bean</p></li><li><p>如果不加注解驱动，则注入的值为null！</p><hr><p>使用&lt;context:annotation- config/&gt;隐式地向 Spring容器注册AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor以及PersistenceAnnotationBeanPostProcessor这4个BeanPostProcessor。</p></li></ul><blockquote><p>基于Java类进行配置</p></blockquote><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p><p>测试：</p><p>1、编写一个实体类，Dog</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//将这个类标注为Spring的一个组件，放到容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">   <span class="keyword">public</span> String name = <span class="string">"dog"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、新建一个config配置包，编写一个MyConfig配置类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>{</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="comment">//通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext applicationContext =</span><br><span class="line">           <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig.class);</span><br><span class="line">   Dog dog = (Dog) applicationContext.getBean(<span class="string">"dog"</span>);</span><br><span class="line">   System.out.println(dog.name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4、成功输出结果！</p><p><strong>导入其他配置如何做呢？</strong></p><p>1、我们再编写一个配置类！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig2</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、在之前的配置类中我们来选择导入这个配置类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyConfig2.class)</span>  <span class="comment">//导入合并其他配置类，类似于配置文件中的 inculde 标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>{</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p><h2 id="静态-动态代理模式"><a href="#静态-动态代理模式" class="headerlink" title="静态/动态代理模式"></a>静态/动态代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！</p><p>代理模式：</p><ul><li>静态代理</li><li>动态代理</li></ul><p>学习aop之前 , 我们要先了解一下代理模式！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLRnfS7LpO0Iic7fEEPFCgRs0ggNXCwf6IKo1tibjPmNSTEYeII5ro7YLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4></blockquote><p><strong>静态代理角色分析</strong></p><ul><li><p>抽象角色 : 一般使用接口或者抽象类来实现</p></li><li><p>真实角色 : 被代理的角色</p></li><li><p>代理角色 : 代理真实角色 ，代理真实角色后 , 一般会做一些附属的操作 </p></li><li><p>客户  :  使用代理角色来进行一些操作 .</p></li></ul><p><strong>代码实现</strong></p><p>Rent . java 即抽象角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Host . java 即真实角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"房屋出租"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Proxy . java 即代理角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色：中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Host host;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>{ }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.host = host;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//租房，原真实角色的操作更加存粹，只需关注本身的操作</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>{</span><br><span class="line">       seeHouse();</span><br><span class="line">       host.rent();</span><br><span class="line">       fare();</span><br><span class="line">  }</span><br><span class="line">   <span class="comment">//看房，代理的附加操作</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"带房客看房"</span>);</span><br><span class="line">  }</span><br><span class="line">   <span class="comment">//收中介费</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"收中介费"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Client . java 即客户</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户都会去找代理！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">       <span class="comment">//房东要租房</span></span><br><span class="line">       Host host = <span class="keyword">new</span> Host();</span><br><span class="line">       <span class="comment">//中介帮助房东</span></span><br><span class="line">       Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//你去找中介！</span></span><br><span class="line">       proxy.rent();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p><p><strong>静态代理的好处:</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li><strong>公共业务发生扩展时变得更加集中和方便 .</strong></li></ul><p>缺点 :</p><ul><li>虽然在不改变原有代码的情况下增加了功能实现，但增加了代理类，工作量增大</li></ul><p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p><blockquote><h4 id="静态代理再理解"><a href="#静态代理再理解" class="headerlink" title="静态代理再理解"></a>静态代理再理解</h4></blockquote><p>同学们练习完毕后，我们再来举一个例子，巩固大家的学习！</p><p>练习步骤：</p><p>1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：增删改查业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、我们需要一个真实对象来完成这些增删改查操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实对象，完成增删改查操作的人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"增加了一个用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"删除了一个用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"更新了一个用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"查询了一个用户"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、需求来了，现在我们需要增加一个日志功能，怎么实现！</p><ul><li>思路1 ：在实现类上增加代码 【麻烦！】</li><li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li></ul><p>4、设置一个代理类来处理日志！代理角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色，在这里面增加日志的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.userService = userService;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">       log(<span class="string">"add"</span>);</span><br><span class="line">       userService.add();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>{</span><br><span class="line">       log(<span class="string">"delete"</span>);</span><br><span class="line">       userService.delete();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">       log(<span class="string">"update"</span>);</span><br><span class="line">       userService.update();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>{</span><br><span class="line">       log(<span class="string">"query"</span>);</span><br><span class="line">       userService.query();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"执行了"</span>+msg+<span class="string">"方法"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>5、测试访问类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">       <span class="comment">//真实业务</span></span><br><span class="line">       UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">       <span class="comment">//代理类</span></span><br><span class="line">       UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">       <span class="comment">//使用代理类实现日志功能！</span></span><br><span class="line">       proxy.setUserService(userService);</span><br><span class="line"></span><br><span class="line">       proxy.add();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想；</p><p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</p><p>聊聊AOP：纵向开发，横向开发</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLJqcgicA5aEKtxYibgLPicNfDwicKIn9NlFl86rriaVRicKnEXlPNiacbHiaLibw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4></blockquote><ul><li><p>动态代理的角色和静态代理的一样 .</p></li><li><p>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</p></li><li><p>动态代理分为<code>两类</code> : 一类是基于接口动态代理 , 一类是基于类的动态代理</p></li><li><ul><li>基于接口的动态代理—-JDK动态代理</li><li>基于类的动态代理–cglib</li><li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li><li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！</li></ul></li></ul><p><strong>JDK的动态代理需要了解两个类</strong></p><p>核心 : InvocationHandler   和   Proxy  ， 打开JDK帮助文档看看</p><blockquote><p>InvocationHandler:</p></blockquote><p><code>InvocationHandler</code>是由代理实例的<em>调用处理程序</em>实现的<em>接口</em>  。</p><p>每个代理实例都有一个关联的调用处理程序。  当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的<code>invoke</code>方法。 </p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>invoke(Object proxy, 方法 method, Object[] args)</code>  处理代理实例上的方法调用并返回结果。</td></tr></tbody></table><blockquote><p>Proxy:</p></blockquote><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>static InvocationHandler</code></td><td><code>getInvocationHandler(Object proxy)</code>  返回指定代理实例的调用处理程序。</td></tr><tr><td><code>static 类</code></td><td><code>getProxyClass(ClassLoader loader, 类... interfaces)</code>  给出类加载器和接口数组的代理类的 <code>java.lang.Class</code>对象。</td></tr><tr><td><code>static boolean</code></td><td><code>isProxyClass(类 cl)</code>  如果且仅当使用 <code>getProxyClass</code>方法或  <code>newProxyInstance</code>方法将指定的类动态生成为代理类时，则返回true。</td></tr><tr><td><code>static Object</code></td><td><code>newProxyInstance(ClassLoader loader, 类[] interfaces, InvocationHandler h)</code>  返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</td></tr></tbody></table><p><strong>【InvocationHandler：调用处理程序】</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, 方法 method, Object[] args)</span></span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//proxy - 调用该方法的代理实例</span></span><br><span class="line"><span class="comment">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span></span><br><span class="line"><span class="comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span></span><br></pre></td></tr></tbody></table></figure><p><strong>【Proxy  : 代理】</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLficZiaPU0h9wdeDicTMgBHemVvIdYTsE712DhkDfg0pdRg169oG5FHTmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jMLCIv9ibKb4c9KjmZNNbsDbZojUy0aB1lS3ibqa1SJaBzkK7KneicEX43Zw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7LoeicP1O2nfyA6H0XPa9jML394CqGFmCP1nUlaU9mdLk19o1qIzjicTgDiaPz7ibR371jAo3uNNQ8Qgw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                 rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码实现</strong> </p><p>抽象角色和真实角色和之前的一样！</p><p>Rent . java 即抽象角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Host . java 即真实角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"房屋出租"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ProxyInvocationHandler. java 即代理角色</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个代理实例都有一个关联的调用处理程序对象，它实现了接口InvocationHandler 。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.rent = rent;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">               rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">   <span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throwsThrowable </span>{</span><br><span class="line">       seeHouse();</span><br><span class="line">       <span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line">       Object result = method.invoke(rent, args);</span><br><span class="line">       fare();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//看房</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"带房客看房"</span>);</span><br><span class="line">  }</span><br><span class="line">   <span class="comment">//收中介费</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"收中介费"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Client . java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">       <span class="comment">//真实角色</span></span><br><span class="line">       Host host = <span class="keyword">new</span> Host();</span><br><span class="line">       <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">       ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">       pih.setRent(host); <span class="comment">//将真实角色放置进去！</span></span><br><span class="line">       Rent proxy = (Rent)pih.getProxy(); <span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">       proxy.rent();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！</strong></p><blockquote><h4 id="深化理解"><a href="#深化理解" class="headerlink" title="深化理解"></a>深化理解</h4></blockquote><p>我们来使用动态代理实现代理我们后面写的UserService！</p><p>我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成代理类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">               target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// proxy : 代理类</span></span><br><span class="line">   <span class="comment">// method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> throwsThrowable </span>{</span><br><span class="line">       log(method.getName());</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String methodName)</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"执行了"</span>+methodName+<span class="string">"方法"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">       <span class="comment">//真实对象</span></span><br><span class="line">       UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">       <span class="comment">//代理对象的调用处理程序</span></span><br><span class="line">       ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">       pih.setTarget(userService); <span class="comment">//设置要代理的对象</span></span><br><span class="line">       UserService proxy = (UserService)pih.getProxy(); <span class="comment">//动态生成代理类！</span></span><br><span class="line">       proxy.delete();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试，增删改查，查看结果！</p><blockquote><h5 id="动态代理的好处"><a href="#动态代理的好处" class="headerlink" title="动态代理的好处"></a>动态代理的好处</h5></blockquote><p>静态代理有的它都有，静态代理没有的，它也有！</p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li><li>一个动态代理 , 一般代理某一类业务</li><li>一个动态代理可以代理多个类，代理的是接口！</li></ul><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>那我们接下来就来聊聊AOP吧！</p><blockquote><p>什么是AOP</p></blockquote><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>Aop在Spring中的作用</p></blockquote><p>提供声明式事务；允许用户自定义切面</p><p>以下名词需要了解下：</p><ul><li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li><li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li><li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li><li>目标（Target）：被通知对象。</li><li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li><li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li><li>连接点（JointPoint）：与切入点匹配的执行点。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p><blockquote><p>使用Spring实现Aop</p></blockquote><p>【重点】使用AOP织入，需要导入一个依赖包！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>第一种方式</strong></p><p><strong>通过 Spring API 实现</strong></p><p>首先编写我们的业务接口和实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"增加用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"更新用户"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"查询用户"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line">   <span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line">   <span class="comment">//Object : 目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">       System.out.println( o.getClass().getName() + <span class="string">"的"</span> + method.getName() + <span class="string">"方法被执行了"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>{</span><br><span class="line">   <span class="comment">//returnValue 返回值</span></span><br><span class="line">   <span class="comment">//method被调用的方法</span></span><br><span class="line">   <span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line">   <span class="comment">//target 被调用的目标对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args,Object target)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">       System.out.println(<span class="string">"执行了"</span> + target.getClass().getName()</span><br><span class="line">       +<span class="string">"的"</span>+method.getName()+<span class="string">"方法,"</span></span><br><span class="line">       +<span class="string">"返回值："</span>+returnValue);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.kuang.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.kuang.log.Log"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.kuang.log.AfterLog"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"log"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">       userService.search();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p><p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . </p><p><strong>第二种方式</strong></p><p><strong>自定义类来实现Aop</strong></p><p>目标业务类不变依旧是userServiceImpl</p><p>第一步 : 写我们自己的一个切入类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointcut</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"---------方法执行前---------"</span>);</span><br><span class="line">  }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"---------方法执行后---------"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>去spring中配置</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种方式自定义实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.kuang.config.DiyPointcut"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"diyPonitcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.kuang.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"diyPonitcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"diyPonitcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>{</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">       ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">       UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">       userService.add();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第三种方式</strong></p><p><strong>使用注解实现</strong></p><p>第一步：编写一个注解实现的增强类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointcut</span> </span>{</span><br><span class="line">   <span class="meta">@Before("execution(* com.kuang.service.UserServiceImpl.*(..))")</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"---------方法执行前---------"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After("execution(* com.kuang.service.UserServiceImpl.*(..))")</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>{</span><br><span class="line">       System.out.println(<span class="string">"---------方法执行后---------"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around("execution(* com.kuang.service.UserServiceImpl.*(..))")</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">       System.out.println(<span class="string">"环绕前"</span>);</span><br><span class="line">       System.out.println(<span class="string">"签名:"</span>+jp.getSignature());</span><br><span class="line">       <span class="comment">//执行目标方法proceed</span></span><br><span class="line">       Object proceed = jp.proceed();</span><br><span class="line">       System.out.println(<span class="string">"环绕后"</span>);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式:注解实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"annotationPointcut"</span> <span class="attr">class</span>=<span class="string">"com.kuang.config.AnnotationPointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>aop:aspectj-autoproxy：说明</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过aop命名空间的<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>隐藏起来了</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>  <span class="attr">poxy-target-class</span>=<span class="string">"true"</span>/&gt;</span>时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></tbody></table></figure><h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><blockquote><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4></blockquote><p>1、导入相关jar包</p><p>junit</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mybatis</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mysql-connector-java</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>spring相关</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>aspectJ AOP 织入器</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>mybatis-spring整合包 【重点】</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>配置Maven静态资源过滤问题！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、编写配置文件</p><p>3、代码实现</p><blockquote><h4 id="回忆MyBatis"><a href="#回忆MyBatis" class="headerlink" title="回忆MyBatis"></a>回忆MyBatis</h4></blockquote><p><strong>编写pojo实体类</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="comment">//id</span></span><br><span class="line">   <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">   <span class="keyword">private</span> String pwd;   <span class="comment">//密码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实现mybatis的配置文件</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kuang.pojo"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kuang.dao"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>UserDao接口编写</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>接口对应的Mapper映射文件</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.kuang.dao.UserMapper"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line"></span><br><span class="line">   String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">   InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">   SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">   SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">   UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">   List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line">   <span class="keyword">for</span> (User user: userList){</span><br><span class="line">       System.out.println(user);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   sqlSession.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>总结原来mybatis编写步骤：</strong></p><ol><li>导入mybatis与mysqsl相关包</li><li>编写mybatis核心配置文件</li><li>编写业务接口</li><li>编写接口对应的***mapper.xml</li><li>在mybatise核心配置文件中注册mapper</li><li>获取核心配置文件的输入流,通过输入流build(**)获得sqlsessionFactory,通过sqlsessionFactory获得sqlsession</li><li>通过sqlsession.getMapper(***.class)动态代理获得业务接口实现类</li><li>掉用业务对应方法</li></ol><blockquote><h4 id="MyBatis-Spring学习"><a href="#MyBatis-Spring学习" class="headerlink" title="MyBatis-Spring学习"></a>MyBatis-Spring学习</h4></blockquote><p>引入Spring之前需要了解mybatis-spring包中的一些重要类；</p><p><a href="http://www.mybatis.org/spring/zh/index.html">http://www.mybatis.org/spring/zh/index.html</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JXnZ2vicYHdibF3mvk0w89CqKXn1bvBicZVeBJHGlFZOd8a6X5uzjVp6RnMR4ibS7hPdrHSxNGevkib0w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>什么是 MyBatis-Spring？</strong></p><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p><p><strong>知识基础</strong></p><p>在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要</p><p>MyBatis-Spring 需要以下版本：</p><table><thead><tr><th align="left">MyBatis-Spring</th><th align="left">MyBatis</th><th align="left">Spring 框架</th><th align="left">Spring Batch</th><th align="left">Java</th></tr></thead><tbody><tr><td align="left">2.0</td><td align="left">3.5+</td><td align="left">5.0+</td><td align="left">4.0+</td><td align="left">Java 8+</td></tr><tr><td align="left">1.3</td><td align="left">3.4+</td><td align="left">3.2.2+</td><td align="left">2.1+</td><td align="left">Java 6+</td></tr></tbody></table><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。</p><p>在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><p>在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。</p><p>在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p><p>SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p><p>一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。</p><p>需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（<environments>），数据源（<datasource>）和 MyBatis 的事务管理器（<transactionmanager>）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。</transactionmanager></datasource></environments></p><p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。</p><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p><p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate"&gt;</span><br><span class="line"> &lt;constructor-arg index="0" ref="sqlSessionFactory" /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSession sqlSession)</span> </span>{</span><br><span class="line">   <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String userId)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> sqlSession.getMapper...;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按下面这样，注入 SqlSessionTemplate：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.sample.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="整合实现一"><a href="#整合实现一" class="headerlink" title="整合实现一"></a>整合实现一</h4></blockquote><p>1、引入Spring配置文件beans.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、配置数据源替换mybaits的数据源</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、配置SqlSessionFactory，关联MyBatis</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--关联Mybatis--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/kuang/dao/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>4、注册sqlSessionTemplate，关联sqlSessionFactory；</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--利用构造器注入--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>5、增加Dao接口的实现类；私有化sqlSessionTemplate</p><p>由于使用spring容器管理类,固mybatis整合spring后需多增加一个实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">//sqlSession不用我们自己创建了，Spring来管理</span></span><br><span class="line">   <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>{</span><br><span class="line">       <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>{</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>6、注册bean实现</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.kuang.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>7、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">     ApplicationContext context = newClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">     UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">     List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">     System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kuang.pojo"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="整合实现二"><a href="#整合实现二" class="headerlink" title="整合实现二"></a>整合实现二</h4></blockquote><p>mybatis-spring1.2.3版以上的才有这个 .</p><p>官方文档截图 :</p><p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JXnZ2vicYHdibF3mvk0w89Cq6qzPguHd15ribJeF3ickXAy98VG8YFjxwftEdsvvCLWkWLPeiaiaVibbPxQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>测试：</p><p>1、将我们上面写的UserDaoImpl修改一下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>{</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、修改bean的配置</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.kuang.dao.UserDaoImpl"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！</strong></p><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><blockquote><h4 id="回顾事务"><a href="#回顾事务" class="headerlink" title="回顾事务"></a>回顾事务</h4></blockquote><ul><li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li><li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li></ul><p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p><p><strong>事务四个属性ACID</strong></p><ol><li><p>原子性（atomicity）</p></li><li><ul><li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li></ul></li><li><p>一致性（consistency）</p></li><li><ul><li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li></ul></li><li><p>隔离性（isolation）</p></li><li><ul><li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li></ul></li><li><p>持久性（durability）</p></li></ol><ol start="8"><li><ul><li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li></ul></li></ol><blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></blockquote><p>将上面的代码拷贝到一个新项目中</p><p>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个用户</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>mapper文件，我们故意把 deletes 写错，测试！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.kuang.pojo.User"</span>&gt;</span></span><br><span class="line">insert into user (id,name,pwd) values (#{id},#{name},#{pwd})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">deletes from user where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>编写接口的实现类，在实现类中，我们去操作一波</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">//增加一些操作</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>{</span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"小明"</span>,<span class="string">"123456"</span>);</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       mapper.addUser(user);</span><br><span class="line">       mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">       <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//新增</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>{</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       <span class="keyword">return</span> mapper.addUser(user);</span><br><span class="line">  }</span><br><span class="line">   <span class="comment">//删除</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">       <span class="keyword">return</span> mapper.deleteUser(id);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>报错：sql异常，delete写错了</p><p>结果 ：插入成功！</p><p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要<strong>事务！</strong></p><p>以前我们都需要自己手动管理事务，十分麻烦！</p><p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p><blockquote><p>Spring中的事务管理</p></blockquote><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p><p><strong>编程式事务管理</strong></p><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><p><strong>声明式事务管理</strong></p><ul><li>一般情况下比编程式事务好用。</li><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li></ul><p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx="http://www.springframework.org/schema/tx"</span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>事务管理器</strong></p><ul><li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li><li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li></ul><p><strong>JDBC事务</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"search*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>spring事务传播特性：</strong></p><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li></ul><p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p><p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p><p><strong>配置AOP</strong></p><p>导入aop的头文件！</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.kuang.dao.*.*(..))"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>进行测试</strong></p><p>删掉刚才插入的数据，再次测试！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">   UserMapper mapper = (UserMapper) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">   List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">   System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>思考问题？</p></blockquote><p>为什么需要配置事务？</p><ul><li>如果不配置，就需要我们手动提交控制事务；</li><li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li></ul><p>![(<a href="https://img-blog.csdnimg.cn/20190421210933488.png">https://img-blog.csdnimg.cn/20190421210933488.png</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring : 春天 —&amp;gt;</summary>
      
    
    
    
    <category term="spring框架" scheme="https://rain-sky.github.io/categories/spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="spring" scheme="https://rain-sky.github.io/tags/spring/"/>
    
  </entry>
  
</feed>
