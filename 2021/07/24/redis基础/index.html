<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis基础 | 雨水的天空落了雨</title><meta name="keywords" content="数据库,redis,noSql"><meta name="author" content="rain-Sky"><meta name="copyright" content="rain-Sky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么使用noSql noSql，不仅仅是sql  单机mysql时代在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多，无论读写都在同一个实例中完成。   APP 应用端 DAL 数据访问层（jdbc，或者orm框架如mybaties，Hibernate等） mysql instance 数据库实例  Memcached+">
<meta property="og:type" content="article">
<meta property="og:title" content="redis基础">
<meta property="og:url" content="https://rain-sky.github.io/2021/07/24/redis%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="雨水的天空落了雨">
<meta property="og:description" content="为什么使用noSql noSql，不仅仅是sql  单机mysql时代在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多，无论读写都在同一个实例中完成。   APP 应用端 DAL 数据访问层（jdbc，或者orm框架如mybaties，Hibernate等） mysql instance 数据库实例  Memcached+">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rain-sky.github.io/img/10006.jpg">
<meta property="article:published_time" content="2021-07-24T07:41:03.000Z">
<meta property="article:modified_time" content="2021-08-04T08:56:20.226Z">
<meta property="article:author" content="rain-Sky">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="noSql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rain-sky.github.io/img/10006.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rain-sky.github.io/2021/07/24/redis%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/rain-sky" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-04 16:56:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="雨水的天空落了雨" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/rain-sky/images/raw/master/20210814102605.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-film"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-heart"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雨水的天空落了雨</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-film"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-heart"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">redis基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-24T07:41:03.000Z" title="Created 2021-07-24 15:41:03">2021-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-08-04T08:56:20.226Z" title="Updated 2021-08-04 16:56:20">2021-08-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>44min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="为什么使用noSql"><a href="#为什么使用noSql" class="headerlink" title="为什么使用noSql"></a>为什么使用noSql</h2><blockquote>
<p>noSql，不仅仅是sql</p>
</blockquote>
<h3 id="单机mysql时代"><a href="#单机mysql时代" class="headerlink" title="单机mysql时代"></a>单机mysql时代</h3><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。<br>在那个时候，更多的都是静态网页，动态交互类型的网站不多，无论读写都在同一个实例中完成。</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210726114217.png"></p>
<ul>
<li>APP 应用端</li>
<li>DAL 数据访问层（jdbc，或者orm框架如mybaties，Hibernate等）</li>
<li>mysql instance 数据库实例</li>
</ul>
<h3 id="Memcached-MySQL-垂直拆分"><a href="#Memcached-MySQL-垂直拆分" class="headerlink" title="Memcached+MySQL+垂直拆分"></a>Memcached+MySQL+垂直拆分</h3><p> 后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p>
<p> Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210726114531.png" style="zoom:80%;">

<h3 id="Mysql主从读写分离"><a href="#Mysql主从读写分离" class="headerlink" title="Mysql主从读写分离"></a>Mysql主从读写分离</h3><p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210726121707.png" style="zoom:80%;">

<ul>
<li>M 主服务器，负责写业务</li>
<li>S 从服务器，同步M数据</li>
</ul>
<h3 id="分库分表-水平拆分-mysql集群"><a href="#分库分表-水平拆分-mysql集群" class="headerlink" title="分库分表+水平拆分+mysql集群"></a>分库分表+水平拆分+mysql集群</h3><p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM在写数据的时候会使用表锁，在高并发写数据的情况下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p>
<ul>
<li>MyISAM 表锁</li>
<li>InnoDB 行锁</li>
</ul>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210726122057.png"></p>
<p><strong>一个现代互联网服务架构模型</strong></p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210726123128.png" style="zoom: 67%;">

<p>最前面的是企业级防火墙，后面通过负载均衡主机（软负载：Nginx，硬负载：F5）在 web 服务器集群之间进行调度，再由具体的 web 服务器（Tomcat）去访问缓存，访问数据库。</p>
<h3 id="noSql的优势"><a href="#noSql的优势" class="headerlink" title="noSql的优势"></a>noSql的优势</h3><ul>
<li><p>易扩展<br> NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
</li>
<li><p>大数据量，高性能<br> NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p>
</li>
<li><p>灵活的数据模型<br> NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。</p>
</li>
<li><p>高可用<br> NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。比如Cassandra，HBase模型，通过复制模型也能实现高可用。</p>
</li>
</ul>
<p><strong>一些常用的nosql举例</strong></p>
<ul>
<li>CouchDB ：CouchDB是一种<strong>面向文档</strong>(document-oriented)的nosql数据库，文档的存储格式通过JSON进行描述，在结构部署上采用的是peer-based方式，即每台机器在功能上来讲是同等重要的，没有master和slave的区分，所存储的数据也都是相同的(没有做到数据的分布式存储)，类似于Subversion中版本库和工作拷贝的概念。</li>
<li>Redis：Redis是一种基于<strong>key-value存储格式</strong>的nosql数据库，在结构部署上采用了master/slave的方式，其中slave节点起到备份的作用，当master节点出现问题的时候，slave节点可替换成master，从而确保了系统安全稳定的特性。</li>
<li>MongoDB：同CouchDB一样，MongoDB也是一种<strong>面向文档</strong>的nosql数据库，所不同的是在存储方式上采用的是分布式存储，其部署结构与Redis相似(基于master/slave方式)，只不过功能组件较Redis划分的更加详细。</li>
</ul>
<p><strong>四种nosql对比</strong></p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210727145920.png"></p>
<h2 id="redis-介绍"><a href="#redis-介绍" class="headerlink" title="redis 介绍"></a>redis 介绍</h2><blockquote>
<p>基于redis6.x版</p>
</blockquote>
<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<p><strong>Redis与其他key-value存储有什么不同？</strong></p>
<ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ul>
<h3 id="linux下安装redis"><a href="#linux下安装redis" class="headerlink" title="linux下安装redis"></a>linux下安装redis</h3><p>准备好压缩包传输到Linux目录</p>
<p><strong>解压后得到redis</strong></p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210731174107.png"></p>
<p>进入解压后的文件</p>
<p>yum install gcc-c++</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210731175718.png" style="zoom: 50%;">

<p>安装redis6.X以上版本安装6.0以上版本需要升级gcc到5.3及以上,如下：</p>
<p>运行下面命令升级gcc<br>#第一步<br>sudo yum install centos-release-scl<br>#第二步<br>sudo yum install devtoolset-7-gcc*<br>#第三步<br>scl enable devtoolset-7 bash</p>
<p>更新完成gcc后我们进入redis目录下，执行make</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210731180138.png" style="zoom:50%;">

<p>至此redis基本安装完成，默认安装到/usr/local/bin目录下</p>
<p>复制一份redis配置文件到此目录下，修改此配置文件，daemonize修改为yes,让redis后台启动</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210731183404.png"></p>
<p>指定配置文件启动</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210731183637.png"></p>
<p>连接redis服务</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210731183754.png"></p>
<p>查看redis服务是否开启</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210731183950.png" style="zoom:67%;">

<p>断开redis服务</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210731184120.png"></p>
<p>再次查看服务是否存在</p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210731184222.png" style="zoom:67%;">

<blockquote>
<p>redis的安装相关就到此搞一段落~💪</p>
</blockquote>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h3><p>redis默认有16个数据库，配置文件中可以看到，默认使用第0个，可以使用select命令切换数据库。</p>
<p>切换数据库：select  7</p>
<p>数据库大小：dbsize</p>
<p>输入一个键值对：set keyname value</p>
<p>得到一个value：get  keyname</p>
<p>修改key名称：rename key newkey</p>
<p>查询所有的key：key *</p>
<p>查询某个key是否存在：exists keynane</p>
<p>移除某一个key：move keyname  2（2代表从第二个数据库中移除）</p>
<p>查询某个key还剩多少时间过期：ttl keyname</p>
<p>设置某个键的过期时间：expire keyname 10(10s后过期)</p>
<p>查看当前key的类型：type keyname</p>
<p>清空当前数据库：flushdb</p>
<p>清空所有数据库：flushall</p>
<p><strong>redis是单线程的</strong></p>
<blockquote>
<p>redis是基于内存操作，cpu并不是redis的性能瓶颈，redis的瓶颈是机器的内存和网络带宽。</p>
</blockquote>
<p>为什么redis单线程这么快？</p>
<p>误区1：高性能的服务器一定是多线程的？</p>
<p>误区2：多线程一定比单线程效率高？</p>
<p>核心：redis是将所有数据存放于内存中的，所以说redis使用单线程是最快的，因为没有CPU上下文切换，对于内存系统来说，多次读写都是在一个CPU上的。</p>
<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><h4 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h4><hr>
<p>基本命令操作：</p>
<p>set  name  rain 输入一个字符串类型为 rain</p>
<p>append name sky 给名为name的key追加字符sky，所以追加后为rainsky（若指定keyname不存在，则相当于set key）</p>
<p>strlen name 获取name的长度，rainsky即为7</p>
<p>set num 1 设置num初始值为1</p>
<p>incr num使num自增1.即为2</p>
<p>decr num使num自减1，即为1</p>
<p>incrby num 10 使num自增10</p>
<p>decrby num 10使num自减10</p>
<hr>
<p>set str “hello,world!”</p>
<p>getrange str 0 4获取str0-4区间内容（闭区间），即为hello</p>
<p>setrange str 1 xxxx从指定位置开始用指定字符串作替换，即为hxxxx,world!</p>
<hr>
<blockquote>
<p>setex与setnx</p>
</blockquote>
<p>SETEX key seconds value</p>
<p>含义：</p>
<p>​     将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。</p>
<p>​     如果 key 已经存在， SETEX 命令将覆写旧值。</p>
<p>返回值：</p>
<p>​     设置成功时返回 OK 。</p>
<p>​     当 seconds 参数不合法时，返回一个错误。</p>
<p>SETNX key value（分布式锁常用）</p>
<p>含义：</p>
<p>​     将 key 的值设为 value ，当且仅当 key 不存在。</p>
<p>​     若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>​     SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：</p>
<p>​     设置成功，返回 1 。</p>
<p>​     设置失败，返回 0 。</p>
<blockquote>
<p>mset与mget，msetnx</p>
</blockquote>
<p>mset k1 v1 k2 v2 k3 v3…一次性输入多个值</p>
<p>mget k1 k2 k3 一次性获取多个值</p>
<p>msetnx k1 v1 k2 v2 …一次性设置多个值，如果有一个key已经存在，则整个句子执行失败（原子性）</p>
<blockquote>
<p>设置一个对象</p>
</blockquote>
<p>如：set user:1 {name:rain,age:14}</p>
<p>另一种设计：</p>
<p>mset user:1:name rain user:1:age 14</p>
<blockquote>
<p>getset组合命令</p>
</blockquote>
<p>getset name rainsky 先获取值再重新设置值，不存在则返回nil</p>
<h4 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部，可存在重复值。</p>
<p><strong>基本用法</strong></p>
<p>此处list列表名即为key</p>
<p>lpush list cat 往名为list的列表左侧添加一个cat</p>
<p>若再一次添加dog，pig，则此列表中就有三个元素</p>
<p>lrange list 0 -1 输出列表中的元素，如上的话则为pig dog cat</p>
<p>rpush list duck 往列表右侧添加一个元素</p>
<p>lpop list移除list队列左侧第一个元素</p>
<p>rpop list移除list右侧第一个元素</p>
<p>lindex list 1 获取list中下标为1的元素</p>
<p>llen list 获取列表长度</p>
<p>lrem list 1 cat 移除list中一个cat ，1为移除的个数</p>
<p>ltrim list n1 n2 阶段list为n1,n2中间的元素，闭区间</p>
<p>rpoplpush list1  list2 把list1中的最右边一个元素添加到list2最左边</p>
<p>lset list 0 item 将list列表中指定下标处的值更新为指定值，如果不存在列表或下标越界将会报错</p>
<p>linsert list before v2 nv 往v2的左侧插入一个nv，同样也有after插入</p>
<p><strong>一些应用</strong></p>
<p>消息队列，生产者消费者等</p>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p><strong>基本用法</strong></p>
<p>此处set集合名即为key值</p>
<p>sadd myset hello 往myset中存入hello</p>
<p>smembers myset 列出myset中所有值</p>
<p>sismember myset hello 查询myset中是否含有hello这个值，有返回1，无0</p>
<p>scard myset 获取元素个数</p>
<p>srem myset hello 删除hello</p>
<p>spop myset 随机删除一个元素</p>
<p>srandmember  myset从指定集合中随机抽取一个元素</p>
<p>smove myset myset2  “hello” 将myset中hello元素移动到myset2中</p>
<p>sdiff set1 set2 查询set1与set2的差集</p>
<p>sinter set1 set2 交集(共同关注<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> )</p>
<p>sunion set1 set2 并集</p>
<h4 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h4><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象，就像map。</p>
<p><strong>基本用法</strong></p>
<p>hset myhash name rainsky将name-&gt;rainsky键值对（哈希值）存入myhash这个哈希表</p>
<p>hget myhash name 从myhash中获取key为name的value</p>
<p>hmset myhash name rainsky age 18 存入多个哈希值</p>
<p>hmget myhash name age 获取哈希表中多个key对应的value值</p>
<p>hgetall myhash 获取所有哈希值，结果以key换行value换行key换行value换行…显示</p>
<p>hdel myhash name 删除myhash哈希表中name对应的哈希值</p>
<p>hlen myhash 获取哈希表哈希值个数</p>
<p>exists myhash name判断name为key的哈希值是否存在于myhash中</p>
<p>hkeys myhash获取所有key</p>
<p>hvals myhash获取所有value</p>
<p>hincrby myhash age  1 让age对应value自增1</p>
<p>hsetnx myhash name rain 当此哈希值不存在时插入指定哈希值</p>
<h4 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>基本用法</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis 分数为1处元素为redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES 输出zset中score再0-10区间的内容并把score连带升序输出</span><br><span class="line"></span><br><span class="line">1) "redis"</span><br><span class="line">2) "1"</span><br><span class="line">3) "mongodb"</span><br><span class="line">4) "2"</span><br><span class="line">5) "mysql"</span><br><span class="line">6) "4"</span><br><span class="line"></span><br><span class="line">zrem runoobkey redis 移除一个指定元素</span><br><span class="line">zcard runoobkey 查看元素个数</span><br><span class="line">zrevrange myzset 降序排序，默认是升序</span><br><span class="line">zcount myset n1 n2获取n1 n2区间的元素个数</span><br><span class="line">zrangebyscore myzset -inf +inf 将zset中元素按score排序，score范围为-inf到+inf</span><br></pre></td></tr></tbody></table></figure>

<p>可以有什么应用呢？</p>
<p>存储带权重（score）的数据，然后排序，如各种排行榜。</p>
<h3 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h3><h4 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h4><p>将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。这些数据将会存储到sorted set这样的目的是为了方便使用GEORADIUS或者GEORADIUSBYMEMBER命令对数据进行半径查询等操作。</p>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
<p>当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p>
<p><strong>相关指令</strong></p>
<p>groadd：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将城市信息添加进city中，两个数字分别对应维度，经度，第三个参数代表名称</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD city 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></tbody></table></figure>

<p>gropops：从key里返回所有给定位置元素的位置（经度和纬度）。GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOPOS city Palermo Catania NonExisting</span></span><br><span class="line">1) 1) "13.361389338970184"</span><br><span class="line">   2) "38.115556395496299"</span><br><span class="line">2) 1) "15.087267458438873"</span><br><span class="line">   2) "37.50266842333162"</span><br><span class="line">3) (nil)</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></tbody></table></figure>

<p>GEODIST：命令 - 返回两个给定位置之间的距离</p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEODIST Sicily Palermo Catania</span></span><br><span class="line">"166274.15156960039"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEODIST Sicily Palermo Catania km</span></span><br><span class="line">"166.27415156960038"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEODIST Sicily Palermo Catania mi</span></span><br><span class="line">"103.31822459492736"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEODIST Sicily Foo Bar</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></tbody></table></figure>

<p>GEORADIUS: 命令 - 以给定的经纬度为中心， 找出某一半径内的元素</p>
<ul>
<li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li>
</ul>
<p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<ul>
<li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
<p>返回值<br>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。<br>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。<br>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：</p>
<p>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。<br>geohash 整数。<br>由两个元素组成的坐标，分别为经度和纬度。<br>举个例子， GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST 这样的命令返回的每个子数组都是类似以下格式的：</p>
<p>[“Palermo”,”190.4424”,[“13.361389338970184”,”38.115556395496299”]]</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEORADIUS Sicily 15 37 200 km WITHDIST</span></span><br><span class="line">1) 1) "Palermo"</span><br><span class="line">   2) "190.4424"</span><br><span class="line">2) 1) "Catania"</span><br><span class="line">   2) "56.4413"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEORADIUS Sicily 15 37 200 km WITHCOORD</span></span><br><span class="line">1) 1) "Palermo"</span><br><span class="line">   2) 1) "13.361389338970184"</span><br><span class="line">      2) "38.115556395496299"</span><br><span class="line">2) 1) "Catania"</span><br><span class="line">   2) 1) "15.087267458438873"</span><br><span class="line">      2) "37.50266842333162"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span></span><br><span class="line">1) 1) "Palermo"</span><br><span class="line">   2) "190.4424"</span><br><span class="line">   3) 1) "13.361389338970184"</span><br><span class="line">      2) "38.115556395496299"</span><br><span class="line">2) 1) "Catania"</span><br><span class="line">   2) "56.4413"</span><br><span class="line">   3) 1) "15.087267458438873"</span><br><span class="line">      2) "37.50266842333162"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></tbody></table></figure>

<p> GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOHASH Sicily Palermo Catania</span></span><br><span class="line">1) "sqc8b49rny0"</span><br><span class="line">2) "sqdtr74hyu0"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></tbody></table></figure>

<p>GEORADIUSBYMEMBER 命令 - 找出位于指定范围内的元素，中心点是由给定的位置元素决定</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD Sicily 13.583333 37.316667 <span class="string">"Agrigento"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GEORADIUSBYMEMBER Sicily Agrigento 100 km</span></span><br><span class="line">1) "Agrigento"</span><br><span class="line">2) "Palermo"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>geo底层就是zset</p>
</blockquote>
<p>可以看出geo未给出移除元素api，我们可以使用zrem来操作</p>
<p>如：zrange Sicily -inf +inf 列出所有城市名称，zrem Sicily Palermo 删除一个城市</p>
<h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<blockquote>
<p>什么是基数？</p>
</blockquote>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p><strong>基本用法</strong><br>pfadd mypf  1 2 3 4 5 6 7加入数据集</p>
<p>pfadd yourpf 1 2 4 8 9</p>
<p>pcount mypf 计算基数</p>
<p>pfmerge  all mypf yourpf 将mypf，yourpf合并为all</p>
<h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><p>Redis提供的Bitmaps这个“数据结构”可以实现对位的操作。Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。</p>
<p>可以把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量。单个bitmaps的最大长度是512MB，即2^32个比特位。<br><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 10 1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> getbit key 10</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> getbit key 11</span></span><br><span class="line">(integer) 0</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 0 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 100 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bitcount key</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></tbody></table></figure>



<h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><p><strong>引言</strong></p>
<blockquote>
<p>在数据库相关理论中，一个逻辑工作单元想要成为事务，就必须满足<strong>ACID</strong>，即原子性、一致性、隔离性和持久性。</p>
<ul>
<li>(1)原子性：原子性这个概念其实就是指，一个事务内的所有SQL操作都是一个整体，因此只有所有的SQL操作都完全执行成功，该事务方可以认为提交成功。如果在提交事务过程中某一条SQL语句执行失败，则整个事务必须回滚到事务提交前的状态。</li>
<li>(2)一致性：而一致性这个概念则是指，事务在完成的时候，必须要保证所有的数据都保持一致的状态，而落实到数据库的各个组成部分上，则要求开发人员能够保证数据、索引、约束、日志等在事务前后具备一致性。</li>
<li>(3)隔离性：隔离性这个概念主要针对并发，其核心思想就是不同的并发事务对数据产生的修改必须是相互隔离的，假设有两个不同的事务A和B并发执行，那么对A来讲，它在执行前的状态只有两种，即B执行前和B执行后。同理，对B来讲同样是如此，这样的特性我们就称为隔离性。</li>
<li>(4)持久性：持久性相对简单，是指事务完成以后它对数据的影响是永久性的。</li>
</ul>
</blockquote>
<h4 id="redis事务处理"><a href="#redis事务处理" class="headerlink" title="redis事务处理"></a>redis事务处理</h4><p><strong>redis事务介绍</strong></p>
<ol>
<li>Redis 的事务是通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 这四个命令来完成的。</li>
<li>Redis 的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</li>
<li>Redis 将命令集合序列化并确保处于同一事务的<strong>命令集合连续且不被打断</strong>的执行</li>
<li>Redis不支持回滚操作</li>
</ol>
<p>思考：为什么 Redis 不支持事务回滚？</p>
<ul>
<li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的。</li>
<li>Redis 为了<strong>性能方面</strong>就忽略了事务回滚。</li>
</ul>
<blockquote>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
</blockquote>
<p><strong>事务处理命令</strong></p>
<p>事务处理命令会像非事务状态下一样被立刻执行</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802120751.jpeg"></p>
<p><strong>事务处理流程</strong></p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>1）开始事务。（非事务状态-&gt;事务状态）</li>
<li>2）命令入队。（并不执行）</li>
<li>3）执行事务。</li>
</ul>
<p>一个简单事务示例</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; SET Book_Name "GIt Pro" </span><br><span class="line">QUEUED </span><br><span class="line">127.0.0.1:6379&gt; SADD Program_Language "C++" "C#" "Jave" "Python"  </span><br><span class="line">QUEUED </span><br><span class="line">127.0.0.1:6379&gt; GET Book_Name </span><br><span class="line">QUEUED </span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (integer) 4 </span><br><span class="line">3) "GIt Pro" </span><br></pre></td></tr></tbody></table></figure>

<h4 id="事务处理情况示例"><a href="#事务处理情况示例" class="headerlink" title="事务处理情况示例"></a>事务处理情况示例</h4><p>放弃事务</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802145006.jpeg"></p>
<p>命令性错误，所有命令均不会执行</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802145320.png"></p>
<p>运行时错误，其他命令依然执行</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802145525.png"></p>
<h4 id="redis实现乐观锁"><a href="#redis实现乐观锁" class="headerlink" title="redis实现乐观锁"></a>redis实现乐观锁</h4><p><strong>悲观锁</strong></p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p><strong>乐观锁</strong></p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<p><strong>redis实现乐观锁</strong></p>
<p>使用watch对数据加锁，当执行事务期间，被加锁数据未背修改则事务可成功执行，否则执行失败</p>
<p>先在一个连接（假设为线程1）里编写一个事务，</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set money 100</span><br><span class="line">set out 0</span><br><span class="line">multi</span><br><span class="line">decrby money 10</span><br><span class="line">incrby out 10</span><br></pre></td></tr></tbody></table></figure>

<p>还未exec我们开启另外一个连接（假设为线程2），相当于另外一个用户，执行以下操作</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby money 100</span><br></pre></td></tr></tbody></table></figure>

<p>执行完毕后我们回到线程1</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set money 100</span><br><span class="line">set out 0</span><br><span class="line">multi</span><br><span class="line">decrby money 10</span><br><span class="line">incrby out 10</span><br><span class="line">exec</span><br></pre></td></tr></tbody></table></figure>

<p>当我们执行exec后会报错，因为在我们执行事务期间监视值money已经被其他线程修改</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unwatch 放弃监视</span><br><span class="line">watch money 监视money此时已经是最新值</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>乐观锁的一些应用：秒杀系统</p>
</blockquote>
<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><p>Redis官方推荐的Java连接开发工具</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-java.html">参考学习</a></p>
<p>maven项目使用</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>连接到redis</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisJava</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth("123456"); </span></span><br><span class="line">        System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">"服务正在运行: "</span>+jedis.ping());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//String操作</span></span><br><span class="line">        <span class="comment">//设置 redis 字符串数据</span></span><br><span class="line">        jedis.set(<span class="string">"runoobkey"</span>, <span class="string">"www.runoob.com"</span>);</span><br><span class="line">        <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">        System.out.println(<span class="string">"redis 存储的字符串为: "</span>+ jedis.get(<span class="string">"runoobkey"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//List操作</span></span><br><span class="line">        jedis.lpush(<span class="string">"site-list"</span>, <span class="string">"Runoob"</span>);</span><br><span class="line">        jedis.lpush(<span class="string">"site-list"</span>, <span class="string">"Google"</span>);</span><br><span class="line">        jedis.lpush(<span class="string">"site-list"</span>, <span class="string">"Taobao"</span>);</span><br><span class="line">        <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(<span class="string">"site-list"</span>, <span class="number">0</span> ,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) {</span><br><span class="line">            System.out.println(<span class="string">"列表项为: "</span>+list.get(i));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不再赘述，所有操作与命令均相似</p>
<blockquote>
<p>一个事务的栗子<span class="github-emoji"><span>📝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4dd.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</blockquote>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802155721.png"></p>
<h2 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h2><p>spring系列与数据操作相关的项目为spring-data，<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">官网</a></p>
<img src="https://gitee.com/rain-sky/images/raw/master/20210802160745.png" style="zoom:50%;">

<p>在springboot2.x后，操作redis的jedis更换为lettuce。</p>
<p>jedis：采用直连，多个线程操作的话不安全，需要使用Jedis  pool ，类似BIO模式。</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全情况，类似NIO模式。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p><strong>导入starter</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>配置解析</strong></p>
<p>找到自动配置类，可以看到为我们注入了两个常用类，方法参数为一个redis连接工厂对象，点进去发现是一个接口，而此接口的实现类有两个。</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802161509.png"></p>
<p>实现类</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802164132.png"></p>
<p>看看绑定的配置类，找到配置类，可以看到一些默认配置</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210802161554.png"></p>
<p><strong>配置连接示例</strong></p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）  </span></span><br><span class="line"><span class="string">spring.redis.database=0</span>  </span><br><span class="line"><span class="comment"># Redis服务器地址  </span></span><br><span class="line"><span class="string">spring.redis.host=192.168.0.24</span>  </span><br><span class="line"><span class="comment"># Redis服务器连接端口  </span></span><br><span class="line"><span class="string">spring.redis.port=6379</span>  </span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）  </span></span><br><span class="line"><span class="string">spring.redis.password=</span>  </span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）  </span></span><br><span class="line"><span class="string">spring.redis.pool.max-active=200</span>  </span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）  </span></span><br><span class="line"><span class="string">spring.redis.pool.max-wait=-1</span>  </span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接  </span></span><br><span class="line"><span class="string">spring.redis.pool.max-idle=10</span> </span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接  </span></span><br><span class="line"><span class="string">spring.redis.pool.min-idle=0</span>  </span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）  </span></span><br><span class="line"><span class="string">spring.redis.timeout=1000</span> </span><br></pre></td></tr></tbody></table></figure>

<p><strong>简单测试</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootRedisApplicationTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//对String类型的操作</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"myKey"</span>,<span class="string">"myValue"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"myKey"</span>));</span><br><span class="line">        <span class="comment">//对list的操作</span></span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">"hello"</span>,<span class="string">"world!"</span>);</span><br><span class="line">        redisTemplate.opsForList().leftPop(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        connection.flushAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>自定义RedisTemplate</strong></p>
<p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 网络传输的对象必须序列化</p>
<p>自定义序列化方式</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803085557.png"></p>
<p>往往结合自己注入的RedisTempalte再自定义一个redis工具类</p>
<h2 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h2><p>redis启动的时候就是通过指定配置文件来启动的</p>
<p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 存储单位可选，大小写不敏感</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803100112.png"></p>
<p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>引入其他配置文件</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803100219.png"></p>
<p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>网络配置，参见network部分</p>
<ul>
<li>bind 127.0.0.1 绑定的主机地址</li>
</ul>
<p>关于bind，这个问题是由于很多文档解释bind而导致的误会。很多地方翻译如下：</p>
<blockquote>
<p>指定redis只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中最好设置该项</p>
</blockquote>
<p>但是，实际上，应该bind的是redis所在服务器网卡的ip。也就是说，如果你的redis服务器有两张网卡，一张是ip-1,另一张是ip-2，如果你bind ip-1.那么只有请求ip-1的请求会被受理。</p>
<ul>
<li>port 6379 指定 Redis 监听端口，默认端口为 6379。</li>
</ul>
<p><span class="github-emoji"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>通常配置</p>
<p>daemonize no：Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程。</p>
<p>pidfile /var/run/redis_6379.pid：以守护进程运行绑定的pid文件</p>
<p>loglevel notic ：指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</p>
<p>logfile “” ：日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</p>
<p>databases 16 ：数据库个数</p>
<p>always-show-logo no：是否显示redis的logo</p>
<p><span class="github-emoji"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>快照SNAPSHOTTING</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803103030.png"></p>
<p>Redis 默认配置文件中提供了三个条件：</p>
<p><strong>save 900 1</strong></p>
<p><strong>save 300 10</strong></p>
<p><strong>save 60 10000</strong></p>
<p>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</p>
<p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes <span class="comment">#是否压缩rdb文件</span></span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment">#在保存数据库文件时出错是否停止写入</span></span><br><span class="line">rdbcherksum yes <span class="comment">#rdb文件保存时是否错误检查</span></span><br><span class="line">rdbfilename dump.rdb <span class="comment">#指定rdb持久化文件名</span></span><br><span class="line">dir ./ <span class="comment">#rdb持久化文件保存的目录</span></span><br></pre></td></tr></tbody></table></figure>



<p><span class="github-emoji"><span>6⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0036-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>主从复制REPLICATION</p>
<p><span class="github-emoji"><span>🚶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6b6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p><span class="github-emoji"><span>7⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0037-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>安全SECURITY</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass <span class="string">"你的密码"</span></span><br><span class="line">config get requirepass 获取密码</span><br><span class="line">auth <span class="string">"你的密码"</span> 密码验证</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803110057.png"></p>
<p><span class="github-emoji"><span>8⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0038-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>APPEND ONLY MODE(AOF)</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认不开启AOF</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># The name of the append only file (default: "appendonly.aof")</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment">#每秒执行一次sync</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#不执行sync，操作系统自主同步数据</span></span><br><span class="line">appendfsync no</span><br><span class="line"><span class="comment">#每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync always</span><br></pre></td></tr></tbody></table></figure>



<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>产生一个数据快照文件</p>
<p>RDB是Redis用来进行持久化的一种方式，在指定时间间隔把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803152638.png"></p>
<p>在rdb方式中，redis会fork一个子进程来将内存中的数据写入一个临时rdb文件中，写入完成后会替换原有rdb文件，父进程仍然可以处理客户端请求。</p>
<p><strong>触发规则</strong></p>
<ul>
<li>save规则满足时</li>
<li>flushall时</li>
<li>退出redis时</li>
</ul>
<p><strong>恢复rdb文件</strong></p>
<p>在config get dir结果目录下存在rdb文件启动时便会自动加载</p>
<p><strong>利弊</strong></p>
<p>优点：</p>
<ul>
<li>紧凑型备份文件，占用内存小</li>
<li>在子进程中完成备份</li>
<li>恢复大量数据集时速度快</li>
<li>单文件易于传输</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果服务器宕机会出现数据丢失</li>
<li>数据庞大时，fork操作耗时</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Redis的另外一种持久化方案就是AOF，Append Only File。AOF相当于一个操作的日志记录，每次对于数据的变更（读操作不记录）都会记录追加到AOF日志。当服务启动的时候就会读这些操作日志，重新执行一次操作，从而恢复原始数据。</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803154830.png"></p>
<p>在reids.conf中可以看到，aof是默认不开启的</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认不开启AOF</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># The name of the append only file (default: "appendonly.aof")</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span> <span class="comment">#默认产生记录文件，若该文件损坏，redis无法启动，我们可以使用redis-cherk-aof来修复该文件，但不能保证数据不丢失，redis-check-aof --fix appendonly.aof 即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#每秒执行一次sync</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#不执行sync，操作系统自主同步数据</span></span><br><span class="line">appendfsync no</span><br><span class="line"><span class="comment">#每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync always</span><br><span class="line"></span><br><span class="line">- auto-aof-rewrite-percentage 100 <span class="comment">#当文件增长100%（一倍）时候，自动重写。</span></span><br><span class="line">- auto-aof-rewrite-min-size 64mb <span class="comment">#日志重写最小文件大小，如果小于该大小，不会自动重写。</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>优缺点</strong></p>
<p>优点</p>
<ul>
<li>默认每秒同步一次，文件完整性更好</li>
</ul>
<p>缺点：</p>
<ul>
<li>aof文件体积大，修复速度慢</li>
<li>大量写入的时候aof效率低</li>
</ul>
<blockquote>
<p>如何选择</p>
</blockquote>
<p>以上已经基本了解过RDB和AOF的使用、基本原理以及对应的优缺点。那么在实际当中，我们到底怎么去选择用哪种持久化方式呢？</p>
<p>一般来说，不考虑硬盘大小，最安全的做法是RDB与AOF同时使用，即使AOF损坏无法修复，还可以用RDB来恢复数据。</p>
<p>如果Redis的数据在你的服务中并不是必要的数据，例如只是当简单的缓存，没有缓存也不会造成缓存雪崩。说明数据的安全可靠性并不是首要考虑范围内，那么单独只使用RDB就可以了。</p>
<p>不推荐单独使用AOF，因为AOF对于数据的恢复载入来说，比RDB慢。并且Redis官方也说明了，AOF有一个罕见的bug。出了问题无法很好的解决。所以使用AOF的时候，最好还是有RDB作为数据备份。</p>
<h2 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a>redis发布订阅</h2><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803162718.png"></p>
<p><strong>相关命令</strong></p>
<p>PSUBSCRIBE pattern [pattern1 ….]</p>
<ul>
<li>说明：订阅一个或多个符合给定模式的频道，每个模式以*作为匹配符</li>
<li>参数：pattern(给定的模式)</li>
<li>返回：接受到的信息</li>
</ul>
<p>PUNSUBSCRIBE pattern [pattern1 ….]</p>
<ul>
<li>说明：用于退订所有给定模式的频道</li>
<li>参数：pattern(给定的模式)</li>
<li>返回：这个命令在不同的客户端中有不同的表现。</li>
</ul>
<p>SUBSCRIBE channel [channel1 …]</p>
<ul>
<li>说明：用于订阅给定的一个或多个频道的信息</li>
<li>参数：channel(给定的频道名)</li>
<li>返回：接收到的信息</li>
</ul>
<p>UNSUBSCRIBE channel [channel1 …]</p>
<ul>
<li>说明：用于退订给定的一个或多个频道的信息</li>
<li>参数：channel(给定的频道名)</li>
<li>返回：这个命令在不同的客户端中有不同的表现</li>
</ul>
<p>PUBLISH channel message</p>
<ul>
<li>说明：用于将信息发送到指定的频道</li>
<li>参数：channel(频道名称)，message(将要发送的信息)</li>
<li>返回：接收到此消息的订阅者数量</li>
</ul>
<p>PUBSUB  &lt; subcommand &gt; argument [argument1 ….]</p>
<ul>
<li>说明：用于查看订阅与发布系统状态，它由数个不同格式的子命令组成</li>
<li>参数：subcommand(子命令)，argument(子命令参数)</li>
<li>返回：由活跃频道组成的列表</li>
<li>子命令如下</li>
</ul>
<table>
<thead>
<tr>
<th>subcommand</th>
<th>argument</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CHANNELS</td>
<td>[pattern]</td>
<td>返回指定模式pattern的活跃的频道,指定返回由SUBSCRIBE订阅的频道</td>
</tr>
<tr>
<td>NUMSUB</td>
<td>channel channel2 …</td>
<td>返回指定频道的订阅数量</td>
</tr>
<tr>
<td>NUMPAT</td>
<td></td>
<td>返回订阅模式的数量，注意：这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和</td>
</tr>
</tbody></table>
<blockquote>
<p>举个栗子<span class="github-emoji"><span>🍎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</blockquote>
<p>在连接2中我们发布消息</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803165009.png"></p>
<p>在连接1中接受订阅</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803165057.png"></p>
<blockquote>
<p>应用</p>
</blockquote>
<p>如微信公众号，好友动态，时事消息系统，实时聊天室，订阅关注…</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制，是指将一台Redis服务器上的数据，复制到其他redis服务器上，前者为master主节点，后者为follower从节点，数据复制是单向的，只能从主节点到从节点，master以写操作为主，从节点以读为主。</p>
<p><strong>主从复制的作用</strong></p>
<ol>
<li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
</li>
<li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
</li>
<li><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
</li>
<li><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p>
</li>
<li><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
</li>
</ol>
<p><strong>从节点开启主从复制，有3种方式：</strong></p>
<ol>
<li><p>配置文件： 在从服务器的配置文件中加入：slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>启动命令： redis-server启动命令后加入 –slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>客户端命令： Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip>  <masterport>，则该Redis实例成为从节点。</masterport></masterip></p>
</li>
</ol>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210803213647.jpeg"></p>
<p>每台redis服务器都是主节点，但每一个从节点只能有一个主节点</p>
<blockquote>
<p>仅仅使用单台redis服务器会造成的问题</p>
<p>1，从结构上来说，容易造成单点故障并且请求压力大</p>
<p>2，从容量上来说，单个redis服务器内存容量有限，通常来说，单台redis最大使用内存不应该超过20G</p>
</blockquote>
<p><strong>相关指令</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info repication <span class="comment">#查看当前库的信息</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>配置主从复制环境</strong></p>
<p>我们可以使用多台物理机来当作从服务器，当然我们学习阶段可以使用虚拟机软件安装多个系统当作从节点，还有一个办法就是在同一个系统中，配置多份配置文件，通过不同的配置文件启动不同的几个redis数据库，在同一个操作系统下搭建集群环境。</p>
<p>例如主节点通过配置文件master.conf启动</p>
<p>复制配置文件，复制三分，两份为从节点，一分为主节点，修改配置文件名称分别为：</p>
<p>redis6380.conf     redis6381.conf    master.conf 表示在另外三个端口监听请求</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804092337.png"></p>
<p><em>同时我们需要修改这三份配置文件内部的rdb文件名避免重复，还有pid文件，logfile文件，最重要的这三份配置文件的监听端口分别修改为6380，6381，6379</em></p>
<p><span class="github-emoji"><span>🐥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f425.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>最后可以查看以下redis服务，可以看到开启了三个，分别在不同的端口</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804094454.png"></p>
<p> 采用命令暂时配置主从关系：</p>
<p>例如我们在6380与6381端口处redis服务下执行 <strong>slaveof 127.0.0.1 6379</strong> 则等同于为这两个redis服务配置主机，再去6379处查看一下，可以看到两台从机</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804104008.png"></p>
<p>修改配置永久配置主从关系：</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804094851.png"></p>
<p><span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>到此主从复制基本环境配置完成</p>
<blockquote>
<p>主从复制细节</p>
</blockquote>
<p>主机能读能写，从机将不能写，如在从机上执行set name rain会失败</p>
<p>主机写完后从机将会自动同步主机内容，如主机6379 设置了一个值 set name rain 那么从机6380，6381可以get name 得到name的值。</p>
<p>主机断开了连接从机依然能够独立完成读操作请求。</p>
<p>如果是配置暂时性主从关系，从机重启后会失去主从关系，无法同步主机数据，需要重新配置，一般生产环境中都配置永久性主从关系。</p>
<blockquote>
<p>复制原理</p>
</blockquote>
<p>主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。</p>
<p><strong>全量同步</strong><br>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>- 从服务器连接主服务器，发送SYNC命令；<br>- 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>- 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p>
<p><strong>增量同步</strong><br>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<p><strong>Redis主从同步策略</strong><br>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<blockquote>
<p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 宕机后主动配置主机，非哨兵模式</p>
</blockquote>
<p> <img src="https://gitee.com/rain-sky/images/raw/master/20210804111419.png"></p>
<p>假设此处主节点宕机了，那么从节点1仍然是从节点点，无法完成写操作，那么怎么重新选举他为主节点，在从节点1使用命令slaveof no one将自己配置为主节点，从节点1可以写操作，从节点1的从节点依然从他处同步数据但只能读，重启主节点后，主节点的从节点就只有从节点2了。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><span class="github-emoji"><span>⚔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2694.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>自动谋权篡位</p>
<p>Redis 的 Sentinel （redis-sentinel程序）系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>哨兵模式中哨兵是一个独立的进程，其原理是通过哨兵向节点发送命令等待redis服务器响应来监控节点状态。</p>
<p>哨兵的作用：</p>
<ul>
<li>发送命令监测节点响应从而监控服务器运行状态</li>
<li>监测到master宕机，自动将slave切换成master，然后通过发布订阅模式通知其余服务器修改配置文件切换主机。</li>
</ul>
<blockquote>
<p>单哨兵</p>
</blockquote>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804114247.webp"></p>
<p>如果哨兵进程出现了问题，那么哨兵模式将会崩坏，为此单个哨兵是不合适的。</p>
<blockquote>
<p>多哨兵</p>
</blockquote>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804114339.webp"></p>
<p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>
<h3 id="redis配置哨兵模式"><a href="#redis配置哨兵模式" class="headerlink" title="redis配置哨兵模式"></a>redis配置哨兵模式</h3><p>先搭建一个链式主从配置</p>
<p>6379(master)-&gt;6380(slave)-&gt;6381(slave)</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804115619.png"></p>
<p><strong>哨兵模式配置文件</strong></p>
<p>例如在usr/local/bin/myconfig/目录下创建一个sentinel.cof文件</p>
<p>核心配置，配置远不止此</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 1</span><br></pre></td></tr></tbody></table></figure>

<p>monitor: 监控    master: 被监控的节点名称   host  port  1代表主机挂了后从机投票选举新主机</p>
<p>启动哨兵</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel usr/<span class="built_in">local</span>/bin/myconfig/sentinel.conf</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804122903.png"></p>
<p>可以看到我们的master与他的slave信息，现在我们尝试关闭master，可以看到哨兵控制台输出</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804124954.png"></p>
<p>查看6380处信息，可以看到6380通过一个投票算法被选举为新的master</p>
<p><img src="https://gitee.com/rain-sky/images/raw/master/20210804125048.png"></p>
<p>当主机恢复后将作为6380的从机</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>有点：</p>
<p>1，哨兵集群，基于主从复制模式，拥有所有主从配置有点</p>
<p>2，主从可以切换，故障转移系统可用性更好</p>
<p>3，主动完成</p>
<p>缺点：</p>
<p>1，redis不适合在线扩容，集群容量一旦达到上线，在线扩容就是问题</p>
<p>2，实现哨兵模式配置麻烦</p>
<p>配置文件</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 26379 <span class="comment">#配置端口，如果有哨兵集群</span></span><br><span class="line">dir /tmp <span class="comment">#工作目录</span></span><br><span class="line">sentinel down-after-milliseconfs mater <span class="comment">#指定多少时间主节点未应答哨兵认为主节点下线</span></span><br></pre></td></tr></tbody></table></figure>





<h2 id="缓存穿透与雪崩"><a href="#缓存穿透与雪崩" class="headerlink" title="缓存穿透与雪崩"></a>缓存穿透与雪崩</h2><blockquote>
<p>缓存穿透</p>
</blockquote>
<p>描述：访问一个缓存和数据库都不存在的 key，此时会直接打到数据库上，并且查不到数据，没法写缓存，所以下一次同样会打到数据库上。</p>
<p>此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被打挂。此时缓存就好像被“穿透”了一样，起不到任何作用。</p>
<p>1、<strong>接口校验。</strong>在正常业务流程中可能会存在少量访问不存在 key 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、数据合法性校验等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。</p>
<p>2、<strong>缓存空值</strong>。当访问缓存和DB都没有查询到值时，可以将空值写进缓存，但是设置较短的过期时间，该时间需要根据产品业务特性来设置。</p>
<p>3、<strong>布隆过滤器</strong>。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</p>
<blockquote>
<p>缓存击穿</p>
</blockquote>
<p>描述：某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p>
<p>解决方案：</p>
<p>1、<strong>加互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</p>
<p>关于互斥锁的选择，网上看到的大部分文章都是选择 Redis 分布式锁，因为这个可以保证只有一个请求会走到数据库，这是一种思路。</p>
<p>但是其实仔细想想的话，这边其实没有必要保证只有一个请求走到数据库，只要保证走到数据库的请求能大大降低即可，所以还有另一个思路是 JVM 锁。</p>
<p>JVM 锁保证了在单台服务器上只有一个请求走到数据库，通常来说已经足够保证数据库的压力大大降低，同时在性能上比分布式锁更好。</p>
<p>需要注意的是，无论是使用“分布式锁”，还是“JVM 锁”，加锁时要按 key 维度去加锁。</p>
<p>我看网上很多文章都是使用一个“固定的 key”加锁，这样会导致不同的 key 之间也会互相阻塞，造成性能严重损耗。</p>
<p>使用 redis 分布式锁的伪代码，仅供参考：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    Object value = redis.get(key);</span><br><span class="line">    <span class="comment">// 缓存值过期</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// lockRedis：专门用于加锁的redis；</span></span><br><span class="line">        <span class="comment">// "empty"：加锁的值随便设置都可以</span></span><br><span class="line">        <span class="keyword">if</span> (lockRedis.set(key, <span class="string">"empty"</span>, <span class="string">"PX"</span>, lockExpire, <span class="string">"NX"</span>)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 查询数据库，并写到缓存，让其他线程可以直接走缓存</span></span><br><span class="line">                value = getDataFromDb(key);</span><br><span class="line">                redis.set(key, value, <span class="string">"PX"</span>, expire);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="comment">// 异常处理</span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lockRedis.delete(key);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// sleep50ms后，进行重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> getData(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>2、<strong>热点数据不过期</strong>。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。</p>
<p>这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，不要到时候缓存刷新不上，一直是脏数据，那就凉了。</p>
<blockquote>
<p>缓存雪崩</p>
</blockquote>
<p>描述：大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。</p>
<p>缓存雪崩其实有点像“升级版的缓存击穿”，缓存击穿是一个热点 key，缓存雪崩是一组热点 key。</p>
<p>解决方案：</p>
<p>1、<strong>过期时间打散</strong>。既然是大量缓存集中失效，那最容易想到就是让他们不集中生效。可以给缓存的过期时间时加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。</p>
<p>2、<strong>热点数据不过期</strong>。该方式和缓存击穿一样，也是要着重考虑刷新的时间间隔和数据异常如何处理的情况。</p>
<p>3、<strong>加互斥锁</strong>。该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>redis基础</p>
</blockquote>
<ol>
<li><p>redis是什么</p>
<ul>
<li>一种key-value型nosql内存数据库</li>
</ul>
</li>
<li><p>redis基本数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Hash</li>
<li>Zset</li>
</ul>
</li>
<li><p>redis三种特殊类型</p>
<ul>
<li>geospatial</li>
<li>Hyperlog</li>
<li>Bitmaps</li>
</ul>
</li>
<li><p>redis事务</p>
<ul>
<li><p>redis事务开启，终止各种情况</p>
</li>
<li><p>redis事务不保证原子性</p>
</li>
<li><p>不支持回滚，为什么？</p>
</li>
</ul>
</li>
<li><p>redis持久化</p>
<ul>
<li>RDB方式</li>
<li>AOF方式</li>
<li>两种持久化的原理，过程</li>
<li>两种方式的优缺点</li>
</ul>
</li>
<li><p>redis发布订阅</p>
</li>
<li><p>redis主从复制</p>
<ul>
<li>主从复制环境搭建</li>
<li>配置主从关系</li>
<li>主从复制原理</li>
</ul>
</li>
<li><p>redis哨兵模式</p>
<ul>
<li>选举流程</li>
</ul>
</li>
<li><p>redis缓存</p>
<ul>
<li>穿透</li>
<li>击穿</li>
<li>雪崩</li>
<li>各种问题的解决方案</li>
</ul>
</li>
<li><p>redis分布式锁</p>
</li>
</ol>
<blockquote>
<p>问题</p>
</blockquote>
<p><strong>Redis</strong></p>
<ul>
<li>项目中使用的 Redis 版本</li>
<li>Redis 在项目中的使用场景</li>
<li>Redis 怎么保证高可用</li>
<li>Redis 的选举流程</li>
<li>Redis 和 Memcache 的区别</li>
<li>Redis 的集群模式</li>
<li>Redis 集群要增加分片，槽的迁移怎么保证无损</li>
<li>Redis 分布式锁的实现</li>
<li>Redis 删除过期键的策略</li>
<li>Redis 的内存淘汰策略</li>
<li>Redis 的 Hash 对象底层结构</li>
<li>Redis 中 Hash 对象的扩容流程</li>
<li>Redis 的 Hash 对象的扩容流程在数据量大的时候会有什么问题吗</li>
<li>Redis 的持久化机制有哪几种</li>
<li>RDB 和 AOF 的实现原理、优缺点</li>
<li>AOF 重写的过程</li>
<li>哨兵模式的原理</li>
<li>使用缓存时，先操作数据库还是先操作缓存</li>
<li>为什么是让缓存失效，而不是更新缓存</li>
<li>缓存穿透、缓存击穿、缓存雪崩</li>
<li>更新缓存的几种设计模式</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">rain-Sky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rain-sky.github.io/2021/07/24/redis%E5%9F%BA%E7%A1%80/">https://rain-sky.github.io/2021/07/24/redis%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/noSql/">noSql</a></div><div class="post_share"><div class="social-share" data-image="/img/10006.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/24/springSecurity/"><img class="prev-cover" src="/img/100018.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">springSecurity</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/22/springboot/"><img class="next-cover" src="/img/100011.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">springboot</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/04/04/select-子句后的列取别名不能应用与where子句的问题/" title="select 子句后的列取别名不能应用与where子句的问题"><img class="cover" src="/img/100019.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-04</div><div class="title">select 子句后的列取别名不能应用与where子句的问题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://gitee.com/rain-sky/images/raw/master/20210814102605.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">rain-Sky</div><div class="author-info__description">努力勇敢一点点</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rain-sky"><i class="fab fa-github"></i><span>空间转移</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">正在施工ing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8noSql"><span class="toc-number">1.</span> <span class="toc-text">为什么使用noSql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9C%BAmysql%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.</span> <span class="toc-text">单机mysql时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memcached-MySQL-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">Memcached+MySQL+垂直拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.3.</span> <span class="toc-text">Mysql主从读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86-mysql%E9%9B%86%E7%BE%A4"><span class="toc-number">1.4.</span> <span class="toc-text">分库分表+水平拆分+mysql集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noSql%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.5.</span> <span class="toc-text">noSql的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">redis 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E4%B8%8B%E5%AE%89%E8%A3%85redis"><span class="toc-number">2.1.</span> <span class="toc-text">linux下安装redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text">redis数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">String字符串类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">List列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">3.2.3.</span> <span class="toc-text">set集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E5%93%88%E5%B8%8C"><span class="toc-number">3.2.4.</span> <span class="toc-text">Hash哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">3.2.5.</span> <span class="toc-text">zset有序集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#geospatial%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">geospatial地理位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hyperloglog"><span class="toc-number">3.3.2.</span> <span class="toc-text">Hyperloglog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmaps"><span class="toc-number">3.3.3.</span> <span class="toc-text">Bitmaps</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.4.</span> <span class="toc-text">redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">redis事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%83%85%E5%86%B5%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">事务处理情况示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.4.3.</span> <span class="toc-text">redis实现乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jedis"><span class="toc-number">4.</span> <span class="toc-text">jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot%E6%95%B4%E5%90%88redis"><span class="toc-number">5.</span> <span class="toc-text">springboot整合redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-conf"><span class="toc-number">6.</span> <span class="toc-text">redis.conf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">7.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">7.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">8.</span> <span class="toc-text">redis发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">redis配置哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9"><span class="toc-number">11.</span> <span class="toc-text">缓存穿透与雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/" title="排序算法归纳"><img src="/img/10006.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法归纳"/></a><div class="content"><a class="title" href="/2021/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3/" title="排序算法归纳">排序算法归纳</a><time datetime="2021-08-15T09:50:21.000Z" title="Created 2021-08-15 17:50:21">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E6%B7%B1%E6%80%9D%E7%86%9F%E8%99%91-%E9%80%89%E6%8B%A9%E8%80%83%E7%A0%94/" title="深思熟虑,选择考研"><img src="/img/100019.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深思熟虑,选择考研"/></a><div class="content"><a class="title" href="/2021/08/14/%E6%B7%B1%E6%80%9D%E7%86%9F%E8%99%91-%E9%80%89%E6%8B%A9%E8%80%83%E7%A0%94/" title="深思熟虑,选择考研">深思熟虑,选择考研</a><time datetime="2021-08-14T01:50:08.000Z" title="Created 2021-08-14 09:50:08">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%86%E6%9E%90/" title="Java类加载再分析"><img src="/img/10002.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java类加载再分析"/></a><div class="content"><a class="title" href="/2021/08/13/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%86%8D%E5%88%86%E6%9E%90/" title="Java类加载再分析">Java类加载再分析</a><time datetime="2021-08-13T10:01:43.000Z" title="Created 2021-08-13 18:01:43">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/11/%E5%85%B3%E4%BA%8EString-StringBuffer%E7%AD%89/" title="关于String,StringBuffer等"><img src="/img/100013.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于String,StringBuffer等"/></a><div class="content"><a class="title" href="/2021/08/11/%E5%85%B3%E4%BA%8EString-StringBuffer%E7%AD%89/" title="关于String,StringBuffer等">关于String,StringBuffer等</a><time datetime="2021-08-11T08:15:38.000Z" title="Created 2021-08-11 16:15:38">2021-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/08/web%E9%A1%BB%E7%9F%A5/" title="web须知"><img src="/img/100017.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web须知"/></a><div class="content"><a class="title" href="/2021/08/08/web%E9%A1%BB%E7%9F%A5/" title="web须知">web须知</a><time datetime="2021-08-08T11:01:16.000Z" title="Created 2021-08-08 19:01:16">2021-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rain-Sky</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, 欢迎光临雨水的小窝</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TGj0zYjdRMW2f2kd8Jp7ehjN-gzGzoHsz',
      appKey: 'VTWVdzNGf2aAQR168F40vnOY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="雨天,蓝色,Aimer,Hiten,抒情,纯音乐,旷野,星空,微风,蓝海" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?rain-sky";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="rain-sky";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>