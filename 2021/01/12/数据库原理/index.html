<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据库原理 | 雨水的天空落了雨</title><meta name="keywords" content="数据库原理"><meta name="author" content="rain-Sky"><meta name="copyright" content="rain-Sky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库概念 数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。  数据库系统的特点   数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高 数据由DBMS统一管理和控制   两大类数据模型   概念模型也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。 逻辑模型和物理模型，逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库原理">
<meta property="og:url" content="https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="雨水的天空落了雨">
<meta property="og:description" content="数据库概念 数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。  数据库系统的特点   数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高 数据由DBMS统一管理和控制   两大类数据模型   概念模型也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。 逻辑模型和物理模型，逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rain-sky.github.io/image/10016.jpg">
<meta property="article:published_time" content="2021-01-12T09:39:46.000Z">
<meta property="article:modified_time" content="2021-01-22T13:09:25.758Z">
<meta property="article:author" content="rain-Sky">
<meta property="article:tag" content="数据库原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rain-sky.github.io/image/10016.jpg"><link rel="shortcut icon" href="/rain-sky.github.io/img/favicon.png"><link rel="canonical" href="https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/rain-sky.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/rain-sky.github.io/rain-sky" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/rain-sky.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-01-22 21:09:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/rain-sky.github.io/atom.xml" title="雨水的天空落了雨" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/rain-sky/images/raw/master/20210516135239.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/rain-sky.github.io/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/rain-sky.github.io/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/rain-sky.github.io/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/gallery/"><i class="fa-fw fas fa-film"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/rain-sky.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/rain-sky.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/rain-sky.github.io/image/10016.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/rain-sky.github.io/">雨水的天空落了雨</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/gallery/"><i class="fa-fw fas fa-film"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/rain-sky.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/rain-sky.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/rain-sky.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-01-12T09:39:46.000Z" title="Created 2021-01-12 17:39:46">2021-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-01-22T13:09:25.758Z" title="Updated 2021-01-22 21:09:25">2021-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/rain-sky.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>50min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>数据库概念</strong></p>
<p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>
<ol>
<li>数据库系统的特点</li>
</ol>
<ul>
<li>数据结构化</li>
<li>数据的共享性高，冗余度低，易扩充</li>
<li>数据独立性高</li>
<li>数据由DBMS统一管理和控制</li>
</ul>
<ol>
<li>两大类数据模型</li>
</ol>
<ul>
<li>概念模型也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</li>
<li>逻辑模型和物理模型，逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li>
</ul>
<ol>
<li>关系数据库</li>
</ol>
<ul>
<li>关系数据库系统采用关系模型作为数据的组织方式，在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。</li>
</ul>
<ol>
<li>数据库系统的三级模式结构</li>
</ol>
<ul>
<li>模式（Schema）</li>
<li>外模式（External Schema）</li>
<li>内模式（Internal Schema）</li>
</ul>
<ol>
<li>关系模式</li>
</ol>
<ul>
<li><p>关系模式可以形式化地表示为：</p>
<p><strong>R（U，D，DOM，F）</strong></p>
<p><strong>R 关系名</strong></p>
<p><strong>U 组成该关系的属性名集合</strong></p>
<p><strong>D 属性组U中属性所来自的域</strong></p>
<p><strong>DOM 属性向域的映象集合</strong></p>
<p><strong>F 属性间的数据依赖关系集合</strong></p>
</li>
</ul>
<ol>
<li>实体完整性规则（Entity Integrity）</li>
</ol>
<ul>
<li>若属性A是基本关系R的主属性，则属性A不能取空值;关系模型中以主码作为唯一性标识。</li>
</ul>
<ol>
<li>参照完整性规则</li>
</ol>
<ul>
<li>若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值</li>
</ul>
</li>
</ul>
<ol>
<li>关系代数运算符</li>
</ol>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230252369.png" alt="img"><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302525419.png" alt="img"></p>
<p><strong>关系数据库标准语言SQL</strong></p>
<p>SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言。集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。可以独立完成数据库生命周期中的全部活动：</p>
<ul>
<li>定义关系模式，插入数据，建立数据库；</li>
<li>对数据库中的数据进行查询和更新；</li>
<li>数据库重构和维护</li>
<li>数据库安全性、完整性控制等</li>
</ul>
<ol>
<li>能完成核心功能9个动词</li>
</ol>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302534580.png" alt="img"></p>
<ol>
<li>SQL的基本概念</li>
</ol>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230253185.png" alt="img"></p>
<ol>
<li>数据定义</li>
</ol>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302531614.png" alt="img"></p>
<ul>
<li><p>定义模式</p>
<ul>
<li><p>定义模式实际上定义了一个命名空间</p>
</li>
<li><p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p>
</li>
<li><p>在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。</p>
<p><strong>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</strong></p>
</li>
</ul>
</li>
<li><p>删除模式</p>
<p>**DROP SCHEMA &lt;模式名&gt; **</p>
<ul>
<li>CASCADE(级联)</li>
</ul>
<p>删除模式的同时把该模式中所有的数据库对象全部删除</p>
<ul>
<li>RESTRICT(限制)</li>
</ul>
<p>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。当该模式中没有任何下属的对象时 才能执行。</p>
</li>
<li><p>定义基本表</p>
<p><strong>CREATE TABLE &lt;表名&gt;</strong></p>
<p><strong>（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</strong></p>
<p><strong>[，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …</strong></p>
<p><strong>[，&lt;表级完整性约束条件&gt; ] ）；</strong></p>
<p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p>
</li>
<li><p>数据类型</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302541124.png" alt="img"></p>
</li>
<li><p>模式与表</p>
<ul>
<li><p>每一个基本表都属于某一个模式</p>
</li>
<li><p>一个模式包含多个基本表</p>
</li>
<li><p>定义基本表所属模式</p>
</li>
<li><p>方法一：在表名中明显地给出模式名</p>
<p><strong>Create table “S-T”.Student（……）; /*模式名为 S-T*/</strong></p>
<p><strong>Create table “S-T”.Cource（……）;</strong></p>
<p><strong>Create table “S-T”.SC（……）;</strong></p>
</li>
<li><p>方法二：在创建模式语句中同时创建表</p>
</li>
<li><p>方法三：设置所属的模式</p>
</li>
</ul>
</li>
<li><p>修改基本表</p>
<p><strong>ALTER TABLE &lt;表名&gt;</strong></p>
<p><strong>[ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</strong></p>
<p><strong>[ DROP &lt;完整性约束名&gt; ]</strong></p>
<p><strong>[ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]；</strong></p>
</li>
<li><p>删除基本表</p>
<p><strong>DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］；</strong></p>
<ul>
<li>RESTRICT：删除表是有限制的。<ul>
<li>欲删除的基本表不能被其他表的约束所引用</li>
<li>如果存在依赖该表的对象，则此表不能被删除</li>
</ul>
</li>
<li>CASCADE：删除该表没有限制。<ul>
<li>在删除基本表的同时，相关的依赖对象一起删除</li>
</ul>
</li>
</ul>
</li>
<li><p>索 引</p>
<ul>
<li>RDBMS中索引一般采用B+树、HASH索引来实现<ul>
<li>B+树索引具有动态平衡的优点</li>
<li>HASH索引具有查找速度快的特点</li>
</ul>
</li>
<li>采用B+树，还是HASH索引 则由具体的RDBMS来决定</li>
<li>索引是关系数据库的内部实现技术，属于内模式的范畴</li>
<li>CREATE INDEX语句定义索引时，可以定义索引是唯一索引、非唯一索引或聚簇索引</li>
</ul>
</li>
<li><p>建立索引</p>
<ul>
<li><p>语句格式</p>
<p><strong>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;</strong></p>
<p><strong>ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…)；</strong></p>
<ul>
<li>在最经常查询的列上建立聚簇索引以提高查询效率</li>
<li>一个基本表上最多只能建立一个聚簇索引</li>
<li>经常更新的列不宜建立聚簇索引</li>
</ul>
</li>
</ul>
</li>
<li><p>删除索引</p>
<p><strong>DROP INDEX &lt;索引名&gt;；</strong></p>
</li>
</ul>
<ol>
<li>数据查询</li>
</ol>
<ul>
<li><p>语句格式</p>
<p><strong>SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[，&lt;目标列表达式&gt;] …</strong></p>
<p><strong>FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] …</strong></p>
<p><strong>[ WHERE &lt;条件表达式&gt; ]</strong></p>
<p><strong>[ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]</strong></p>
<p><strong>[ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]；</strong></p>
</li>
<li><p>单表查询</p>
<ul>
<li>选择表中的若干列</li>
<li>选择表中的若干元组</li>
<li>ORDER BY子句<ul>
<li>可以按一个或多个属性列排序</li>
<li>升序：ASC；降序：DESC；缺省值为升序</li>
<li>当排序列含空值时</li>
<li>ASC：排序列为空值的元组最后显示</li>
<li>DESC：排序列为空值的元组最先显示</li>
</ul>
</li>
<li>聚集函数<ul>
<li>计数</li>
<li>COUNT（[DISTINCT|ALL] *）</li>
<li>COUNT（[DISTINCT|ALL] &lt;列名&gt;）</li>
<li>计算总和</li>
<li>SUM（[DISTINCT|ALL] &lt;列名&gt;）  </li>
<li>计算平均值</li>
<li>AVG（[DISTINCT|ALL] &lt;列名&gt;）</li>
<li>最大最小值</li>
<li>MAX（[DISTINCT|ALL] &lt;列名&gt;）</li>
<li>MIN（[DISTINCT|ALL] &lt;列名&gt;）</li>
</ul>
</li>
<li>GROUP BY子句</li>
</ul>
</li>
<li><p>查询的一般规律：先依据条件查询得到结果集，再将分组后的结果集筛选并排序。</p>
</li>
<li><p>HAVING短语与WHERE子句的区别：</p>
<ul>
<li>作用对象不同</li>
<li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li>
<li>HAVING短语作用于组，从中选择满足条件的组。</li>
</ul>
</li>
<li><p>常用的查询条件</p>
</li>
</ul>
<p>查 询 条 件</p>
<p>谓 词</p>
<p>比 较</p>
<p>=，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；NOT+上述比较运算符</p>
<p>确定范围</p>
<p>BETWEEN AND，NOT BETWEEN AND</p>
<p>确定集合</p>
<p>IN，NOT IN</p>
<p>字符匹配</p>
<p>LIKE，NOT LIKE</p>
<p>空 值</p>
<p>IS NULL，IS NOT NULL</p>
<p>多重条件（逻辑运算）</p>
<p>AND，OR，NOT</p>
<ul>
<li><p>ESCAPE ‘＼’ 表示” ＼” 为换码字符</p>
</li>
<li><p>连接查询</p>
<ul>
<li>等值与非等值连接查询</li>
<li>自身连接<ul>
<li>一个表与其自己进行连接<ul>
<li>需要给表起别名以示区别</li>
<li>由于所有属性名都是同名属性，因此必须使用别名前缀</li>
</ul>
</li>
</ul>
</li>
<li>外连接<ul>
<li>外连接与普通连接的区别<ul>
<li>普通连接操作只输出满足连接条件的元组</li>
<li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li>
</ul>
</li>
<li>左外连接<ul>
<li>列出左边关系（如本例Student）中所有的元组</li>
</ul>
</li>
<li>右外连接<ul>
<li>列出右边关系中所有的元组</li>
</ul>
</li>
</ul>
</li>
<li>复合条件连接</li>
</ul>
</li>
<li><p>嵌套查询</p>
<p>一个SELECT-FROM-WHERE语句称为一个查询块</p>
<p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<ul>
<li>子查询的限制<ul>
<li>不能使用ORDER BY子句<ul>
<li>层层嵌套方式反映了 SQL语言的结构化</li>
<li>有些嵌套查询可以用连接运算替代</li>
</ul>
</li>
</ul>
</li>
<li>嵌套查询求解方法<ul>
<li>子查询的查询条件不依赖于父查询<ul>
<li>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</li>
<li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li>
<li>然后再取外层表的下一个元组</li>
<li>重复这一过程，直至外层表全部检查完为止</li>
</ul>
</li>
</ul>
</li>
<li>带有比较运算符的子查询<ul>
<li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</li>
<li>与ANY或ALL谓词配合使用</li>
</ul>
</li>
<li>带有ANY（SOME）或ALL谓词的子查询<ul>
<li>需要配合使用比较运算符<ul>
<li>&gt; ANY  大于子查询结果中的某个值</li>
<li>&gt; ALL  大于子查询结果中的所有值</li>
<li>&lt; ANY  小于子查询结果中的某个值</li>
<li>&lt; ALL  小于子查询结果中的所有值</li>
<li>&gt;= ANY  大于等于子查询结果中的某个值</li>
<li>&gt;= ALL  大于等于子查询结果中的所有值</li>
<li>&lt;= ANY  小于等于子查询结果中的某个值</li>
<li>&lt;= ALL  小于等于子查询结果中的所有值</li>
<li>= ANY  等于子查询结果中的某个值</li>
<li>=ALL  等于子查询结果中的所有值（通常没有实际意义）</li>
<li>!=（或&lt;&gt;）ANY  不等于子查询结果中的某个值</li>
<li>!=（或&lt;&gt;）ALL  不等于子查询结果中的任何一个值</li>
</ul>
</li>
</ul>
</li>
<li>带有EXISTS谓词的子查询<ul>
<li>\1. EXISTS谓词,存在量词$</li>
<li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。<ul>
<li>若内层查询结果非空，则外层的WHERE子句返回真值</li>
<li>若内层查询结果为空，则外层的WHERE子句返回假值</li>
</ul>
</li>
<li>由EXISTS引出的子查询，其目标列表达式通常都用* ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义</li>
<li>\2. NOT EXISTS谓词<ul>
<li>若内层查询结果非空，则外层的WHERE子句返回假值</li>
<li>若内层查询结果为空，则外层的WHERE子句返回真值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集合查询</p>
<ul>
<li>集合操作的种类<ul>
<li>并操作UNION</li>
<li>交操作INTERSECT</li>
<li>差操作EXCEPT</li>
</ul>
</li>
<li>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同</li>
</ul>
</li>
<li><p>SELECT语句的一般格式</p>
<p><strong>SELECT [ALL|DISTINCT]</strong></p>
<p><strong>&lt;目标列表达式&gt; [别名] [ ，&lt;目标列表达式&gt; [别名]] …</strong></p>
<p><strong>FROM &lt;表名或视图名&gt; [别名]</strong></p>
<p><strong>[ ，&lt;表名或视图名&gt; [别名]] …</strong></p>
<p><strong>[WHERE &lt;条件表达式&gt;]</strong></p>
<p><strong>[GROUP BY &lt;列名1&gt;</strong></p>
<p><strong>[HAVING &lt;条件表达式&gt;]]</strong></p>
<p><strong>[ORDER BY &lt;列名2&gt; [ASC|DESC]</strong></p>
</li>
</ul>
<ol>
<li>数据更新</li>
</ol>
<ul>
<li><p>插入数据</p>
<ul>
<li><p>插入元组</p>
<ul>
<li><p>语句格式</p>
<p><strong>INSERT</strong></p>
<p><strong>INTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)]</strong></p>
<p><strong>VALUES (&lt;常量1&gt; [，&lt;常量2&gt;] … )</strong></p>
</li>
</ul>
</li>
<li><p>插入子查询结果</p>
<ul>
<li>语句格式</li>
</ul>
<p><strong>INSERT</strong></p>
<p><strong>INTO &lt;表名&gt; [(&lt;属性列1&gt; [，&lt;属性列2&gt;… )]</strong></p>
<p><strong>子查询；</strong></p>
<ul>
<li>子查询</li>
</ul>
<p>SELECT子句目标列必须与INTO子句匹配</p>
<ul>
<li>值的个数</li>
<li>值的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>修改数据</li>
</ol>
<ul>
<li><p>语句格式</p>
<p><strong>UPDATE &lt;表名&gt;</strong></p>
<p><strong>SET &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</strong></p>
<p><strong>[WHERE &lt;条件&gt;]；</strong></p>
</li>
</ul>
<ol>
<li>删除数据</li>
</ol>
<ul>
<li><p>语句格式</p>
<p><strong>DELETE</strong></p>
<p><strong>FROM &lt;表名&gt;</strong></p>
<p><strong>[WHERE &lt;条件&gt;]；</strong></p>
</li>
</ul>
<ol>
<li>视 图</li>
</ol>
<ul>
<li><p>虚表，是从一个或几个基本表（或视图）导出的表</p>
</li>
<li><p>只存放视图的定义，不存放视图对应的数据</p>
</li>
<li><p>基表中的数据发生变化，从视图中查询出的数据也随之改变</p>
</li>
<li><p>建立视图</p>
<ul>
<li>语句格式</li>
</ul>
<p><strong>CREATE VIEW</strong></p>
<p><strong>&lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]</strong></p>
<p><strong>AS &lt;子查询&gt;</strong></p>
<p><strong>[WITH CHECK OPTION]；</strong></p>
</li>
<li><p>删除视图</p>
<p><strong>DROP VIEW &lt;视图名&gt;；</strong></p>
</li>
<li><p>查询视图</p>
<ul>
<li>用户角度：查询视图与查询基本表相同</li>
</ul>
</li>
<li><p>视图的作用</p>
</li>
</ul>
<ol>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ol>
<p><strong>数据库安全性</strong></p>
<ol>
<li>数据库安全性控制的常用方法</li>
</ol>
<ul>
<li>用户标识和鉴定</li>
<li>存取控制</li>
<li>视图</li>
<li>审计</li>
<li>密码存储</li>
</ul>
<ol>
<li><p>关系数据库系统中存取控制对象</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302543665.png" alt="img"></p>
</li>
<li><p>授权与回收</p>
</li>
</ol>
<ul>
<li><p>GRANT</p>
<ul>
<li>GRANT语句的一般格式：</li>
</ul>
<p><strong>GRANT &lt;权限&gt;[,&lt;权限&gt;]…</strong></p>
<p><strong>[ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p>
<p><strong>TO &lt;用户&gt;[,&lt;用户&gt;]…</strong></p>
<p><strong>[WITH GRANT OPTION];</strong></p>
</li>
<li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p>
</li>
<li><p>WITH GRANT OPTION子句</p>
<ul>
<li>WITH GRANT OPTION子句:<ul>
<li>指定：可以再授予</li>
<li>没有指定：不能传播</li>
</ul>
</li>
<li>不允许循环授权</li>
</ul>
</li>
<li><p>REVOKE</p>
<ul>
<li>授予的权限可以由DBA或其他授权者用REVOKE语句收回</li>
<li>REVOKE语句的一般格式为：</li>
</ul>
<p><strong>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…</strong></p>
<p><strong>[ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p>
<p><strong>FROM &lt;用户&gt;[,&lt;用户&gt;]…;</strong></p>
</li>
<li><p>创建数据库模式的权限</p>
<ul>
<li>DBA在创建用户时实现</li>
<li>CREATE USER语句格式</li>
</ul>
<p>**CREATE USER **</p>
<p><strong>[WITH][DBA | RESOURCE | CONNECT]</strong></p>
</li>
</ul>
<ol>
<li>数据库角色</li>
</ol>
<ul>
<li><p>数据库角色：被命名的一组与数据库操作相关的权限</p>
<ul>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
</ul>
</li>
<li><p>角色的创建</p>
<p><strong>CREATE ROLE &lt;角色名&gt;</strong></p>
</li>
<li><p>给角色授权</p>
<p><strong>GRANT &lt;权限&gt;［，&lt;权限&gt;］…</strong></p>
<p><strong>ON &lt;对象类型&gt;对象名</strong></p>
<p><strong>TO &lt;角色&gt;［，&lt;角色&gt;］…</strong></p>
</li>
<li><p>将一个角色授予其他的角色或用户</p>
<p><strong>GRANT &lt;角色1&gt;［，&lt;角色2&gt;］…</strong></p>
<p><strong>TO &lt;角色3&gt;［，&lt;用户1&gt;］…</strong></p>
<p><strong>［WITH ADMIN OPTION］</strong></p>
</li>
<li><p>角色权限的收回</p>
<p><strong>REVOKE &lt;权限&gt;［，&lt;权限&gt;］…</strong></p>
<p><strong>ON &lt;对象类型&gt; &lt;对象名&gt;</strong></p>
<p><strong>FROM &lt;角色&gt;［，&lt;角色&gt;］…</strong></p>
</li>
</ul>
<p><strong>数据库完整性</strong></p>
<ul>
<li>数据库的完整性<ul>
<li>数据的正确性和相容性</li>
</ul>
</li>
<li>数据的完整性和安全性是两个不同概念<ul>
<li>数据的完整性<ul>
<li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
<li>防范对象：不合语义的、不正确的数据</li>
</ul>
</li>
<li>数据的安全性<ul>
<li>保护数据库防止恶意的破坏和非法的存取</li>
<li>防范对象：非法用户和非法操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>实体完整性</strong><ul>
<li>关系模型的实体完整性<ul>
<li>CREATE TABLE中用PRIMARY KEY定义</li>
</ul>
</li>
<li>单属性构成的码有两种说明方法<ul>
<li>定义为列级约束条件</li>
<li>定义为表级约束条件</li>
</ul>
</li>
<li>对多个属性构成的码只有一种说明方法<ul>
<li>定义为表级约束条件</li>
</ul>
</li>
<li>插入或对主码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：</li>
</ul>
</li>
</ul>
<ol>
<li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li>
</ol>
<ul>
<li><p>检查记录中主码值是否唯一的一种方法是进行全表扫描</p>
</li>
<li><p><strong>参照完整性</strong></p>
<ul>
<li><p>关系模型的参照完整性定义</p>
<ul>
<li><p>在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码</p>
</li>
<li><p>用REFERENCES短语指明这些外码参照哪些表的主码</p>
<p>例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno，Cno分别参照引用Student表的主码和Course表的主码</p>
<p>［例3］ 定义SC中的参照完整性</p>
<p>CREATE TABLE SC</p>
<p>(Sno CHAR(9) NOT NULL，</p>
<p>Cno CHAR(4) NOT NULL，</p>
<p>Grade SMALLINT，</p>
<p>PRIMARY KEY (Sno， Cno)， /<em>在表级定义实体完整性</em>/</p>
<p>FOREIGN KEY (Sno) REFERENCES Student(Sno)，</p>
<p>/<em>在表级定义参照完整性</em>/</p>
<p>FOREIGN KEY (Cno) REFERENCES Course(Cno)</p>
<p>/<em>在表级定义参照完整性</em>/</p>
<p>);</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>用户定义的完整性</strong></p>
<ul>
<li>属性上的约束条件的定义<ul>
<li>CREATE TABLE时定义</li>
<li>列值非空（NOT NULL）</li>
<li>列值唯一（UNIQUE）</li>
<li>检查列值是否满足一个布尔表达式（CHECK）</li>
</ul>
</li>
<li>属性上的约束条件检查和违约处理<ul>
<li>插入元组或修改属性的值时，RDBMS检查属性上的约束条件是否被满足</li>
<li>如果不满足则操作被拒绝执行</li>
</ul>
</li>
<li>元组上的约束条件的定义<ul>
<li>在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制</li>
<li>同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件</li>
</ul>
</li>
<li>元组上的约束条件检查和违约处理<ul>
<li>插入元组或修改属性的值时，RDBMS检查元组上的约束条件是否被满足</li>
<li>如果不满足则操作被拒绝执行</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>完整性约束命名子句</strong></p>
<ul>
<li><p>CONSTRAINT 约束</p>
<p><strong>CONSTRAINT &lt;完整性约束条件名&gt;</strong></p>
<p><strong>［PRIMARY KEY短语</strong></p>
<p><strong>|FOREIGN KEY短语</strong></p>
<p><strong>|CHECK短语］</strong></p>
</li>
<li><p>使用ALTER TABLE语句修改表中的完整性限制</p>
</li>
<li><p>SQL支持域的概念，并可以用CREATE DOMAIN语句建立一个域以及该域应该满足的完整性约束条件。</p>
</li>
</ul>
</li>
<li><p><strong>触发器</strong></p>
<ul>
<li><p>定义触发器</p>
<ul>
<li><p>CREATE TRIGGER语法格式</p>
<p><strong>CREATE TRIGGER &lt;触发器名&gt;</strong></p>
<p><strong>{BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;</strong></p>
<p><strong>FOR EACH {ROW | STATEMENT}</strong></p>
<p><strong>［WHEN &lt;触发条件&gt;］</strong></p>
<p><strong>&lt;触发动作体&gt;</strong></p>
</li>
</ul>
</li>
<li><p>定义触发器的语法说明:</p>
<ul>
<li>\1. 创建者：表的拥有者</li>
<li>\2. 触发器名</li>
<li>\3. 表名：触发器的目标表</li>
<li>\4. 触发事件：INSERT、DELETE、UPDATE</li>
<li>\5. 触发器类型<ul>
<li>行级触发器（FOR EACH ROW）</li>
<li>语句级触发器（FOR EACH STATEMENT）</li>
</ul>
</li>
<li>\6. 触发条件<ul>
<li>触发条件为真</li>
<li>省略WHEN触发条件</li>
</ul>
</li>
<li>\7. 触发动作体<ul>
<li>触发动作体可以是一个匿名PL/SQL过程块</li>
<li>也可以是对已创建存储过程的调用</li>
</ul>
</li>
</ul>
</li>
<li><p>激活触发器</p>
<ul>
<li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li>
<li>一个数据表上可能定义了多个触发器<ul>
<li>同一个表上的多个触发器激活时遵循如下的执行顺序：</li>
<li>（1） 执行该表上的BEFORE触发器；</li>
<li>（2） 激活触发器的SQL语句；</li>
<li>（3） 执行该表上的AFTER触发器。</li>
</ul>
</li>
</ul>
</li>
<li><p>删除触发器</p>
<ul>
<li><p>删除触发器的SQL语法：</p>
<p><strong>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</strong></p>
</li>
<li><p>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>关系数据理论</strong></p>
<ul>
<li><p><strong>数据依赖</strong></p>
<ul>
<li><p>数据依赖的类型</p>
<ul>
<li>函数依赖（Functional Dependency，简记为FD）</li>
<li>多值依赖（Multivalued Dependency，简记为MVD）</li>
<li>其他</li>
</ul>
</li>
<li><p>数据依赖对关系模式的影响</p>
<ul>
<li>“好”的模式：<ul>
<li>不会发生插入异常、删除异常、更新异常，</li>
<li>数据冗余应尽可能少</li>
<li>原因：由存在于模式中的某些数据依赖引起的</li>
<li>解决方法：通过分解关系模式来消除其中不合适的数据依赖</li>
</ul>
</li>
</ul>
</li>
<li><p>函数依赖</p>
<ul>
<li><p><strong>定义6.1</strong> 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。</p>
</li>
<li><p>在关系模式R(U)中，对于U的子集X和Y，</p>
<ul>
<li>如果X→Y，但Y Í X，则称X→Y是非平凡的函数依赖</li>
<li>若X→Y，但Y Í X, 则称X→Y是平凡的函数依赖</li>
<li>若X→Y，则X称为这个函数依赖的决定属性组，也称为决定因素（Determinant）。</li>
<li>若X→Y，Y→X，则记作X←→Y。</li>
<li>若Y不函数依赖于X，则记作X→Y。</li>
</ul>
</li>
</ul>
</li>
<li><p>完全函数依赖与部分函数依赖</p>
<ul>
<li><strong>定义6.2</strong> 在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有X’ Y, 则称Y对X完全函数依赖，记作X→F Y 。 若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X→P Y。</li>
</ul>
</li>
<li><p>传递函数依赖</p>
<ul>
<li><p><strong>定义6.3</strong> 在R(U)中，如果X→Y，(Y ÍX) ,Y→X Y→Z， 则称Z对X传递函数依赖。记为：X →传递 Z</p>
</li>
<li><p>注: 如果Y→X， 即X←→Y，则Z直接依赖于X。</p>
</li>
</ul>
</li>
<li><p>码</p>
<ul>
<li><p><strong>定义6.4</strong> 设K为R&lt;U,F&gt;中的属性或属性组合。若K U， 则K称为R的侯选码（Candidate Key）。若候选码多于一个，则选定其中的一个做为主码（Primary Key）。</p>
</li>
<li><p>主属性与非主属性</p>
<ul>
<li>包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）</li>
<li>不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</li>
</ul>
</li>
<li><p>全码</p>
<ul>
<li>整个属性组是码，称为全码（All-key）</li>
</ul>
</li>
</ul>
</li>
<li><p>外部码</p>
<ul>
<li>定义6.5 关系模式 R 中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>范式</strong></p>
<ul>
<li>范式是符合某一种级别的关系模式的集合</li>
<li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式</li>
<li>范式的种类：  <ul>
<li>第一范式(1NF)</li>
<li>第二范式(2NF)</li>
<li>第三范式(3NF)</li>
<li>BC范式(BCNF)</li>
<li>第四范式(4NF)</li>
<li>第五范式(5NF)</li>
</ul>
</li>
<li>各种范式之间存在联系：</li>
<li>某一关系模式R为第n范式，可简记为R∈nNF。</li>
<li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化</li>
<li>1NF<ul>
<li>1NF的定义<ul>
<li>如果一个关系模式R的<strong>所有属性都是不可分的基本数据项</strong>，则R∈1NF</li>
</ul>
</li>
<li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库</li>
<li>但是满足第一范式的关系模式并不一定是一个好的关系模式</li>
</ul>
</li>
<li>2NF<ul>
<li>2NF的定义<ul>
<li>  定义6.6 若<strong>R∈1NF，且每一个非主属性完全函数依赖于码</strong>，则R∈2NF。</li>
</ul>
</li>
</ul>
</li>
<li>3NF<ul>
<li>3NF的定义<ul>
<li>定义6.7 关系模式R&lt;U，F&gt; 中若不存在这样的码X、属性组Y及非主属性Z（Z Í Y）, 使得X→Y，Y→Z成立， Y → X，则称R&lt;U，F&gt; ∈ 3NF。</li>
<li>若R∈3NF，则<strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>BC范式（BCNF）<ul>
<li>定义6.8 关系模式R&lt;U，F&gt;∈1NF，若X→Y且Y Í X时，X必含有码，则R&lt;U，F&gt; ∈BCNF。</li>
<li>等价于：每一个决定属性因素都包含码</li>
<li>若R∈BCNF<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有的主属性对每一个不包含它的码，也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ul>
</li>
<li>R ∈BCNF <img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302542269.png" alt="img"><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302559238.png" alt="img"> R ∈3NF</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多值依赖</strong></p>
<ul>
<li>定义6.9<ul>
<li>设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y。关系模式R(U)中多值依赖 X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对（x，z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关</li>
</ul>
</li>
<li>多值依赖的另一个等价的形式化的定义：<ul>
<li>在R（U）的任一关系r中，如果存在元组t，s 使得t[X]=s[X]，那么就必然存在元组 w，vÎ r，（w，v可以与s，t相同），使得w[X]=v[X]=t[X]，而w[Y]=t[Y]，w[Z]=s[Z]，v[Y]=s[Y]，v[Z]=t[Z]（即交换s，t元组的Y值所得的两个新元组必在r中），则Y多值依赖于X，记为X→→Y。 这里，X，Y是U的子集，Z=U-X-Y。</li>
</ul>
</li>
<li>平凡多值依赖和非平凡的多值依赖<ul>
<li>若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖</li>
<li>否则称X→→Y为非平凡的多值依赖</li>
</ul>
</li>
<li>多值依赖的性质<ul>
<li>（1）多值依赖具有对称性。若X→→Y，则X→→Z，其中Z＝U－X－Y</li>
<li>（2）多值依赖具有传递性。若X→→Y，Y→→Z， 则X→→Z –Y</li>
<li>（3）函数依赖是多值依赖的特殊情况。若X→Y，则X→→Y。</li>
<li>（4）若X→→Y，X→→Z，则X→→YÈ Z。</li>
<li>（5）若X→→Y，X→→Z，则X→→Y∩Z。</li>
<li>（6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y。</li>
</ul>
</li>
<li>多值依赖与函数依赖的区别<ul>
<li>(1) 多值依赖的有效性与属性集的范围有关</li>
<li>(2)<ul>
<li>若函数依赖X→Y在R（U）上成立，则对于任何Y’ Ì Y均有X→Y’ 成立</li>
<li>多值依赖X→→Y若在R(U)上成立，不能断言对于任何Y’ Ì Y有X→→Y’ 成立</li>
</ul>
</li>
</ul>
</li>
<li>4NF<ul>
<li>定义6.10 关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y Í X），X都含有码，则R∈4NF。</li>
<li>如果R ∈ 4NF， 则R ∈ BCNF<ul>
<li>不允许有非平凡且非函数依赖的多值依赖</li>
<li>允许的非平凡多值依赖是函数依赖</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据依赖的公理系统</strong></p>
<ul>
<li><p>逻辑蕴含</p>
<ul>
<li>定义6.11 对于满足一组函数依赖 F 的关系模式R &lt;U，F&gt;，其任何一个关系r，若函数依赖X→Y都成立, （即r中任意两元组t，s，若tX］=sX］，则tY］=sY］），则称F逻辑蕴含X →Y</li>
</ul>
</li>
<li><p>关系模式R &lt;U，F &gt;来说有以下的推理规则：</p>
<ul>
<li><p>A1.自反律（Reflexivity）：若Y Í X Í U，则X →Y为F所蕴含。</p>
</li>
<li><p>A2.增广律（Augmentation）：若X→Y为F所蕴含，且Z Í U，则XZ→YZ为F所蕴含。</p>
</li>
<li><p>A3.传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。</p>
<ul>
<li><p>自反律: 若Y Í X Í U，则X →Y为F所蕴含</p>
<p>证: 设Y Í X Í U</p>
<p>对R &lt;U，F&gt; 的任一关系r中的任意两个元组t，s：</p>
<p>若t[X]=s[X]，由于Y Í X，有t[y]=s[y]，</p>
<p>所以X→Y成立，自反律得证</p>
</li>
<li><p>增广律: 若X→Y为F所蕴含，且Z Í U，则XZ→YZ 为F所蕴含。</p>
<p>证：设X→Y为F所蕴含，且Z Í U。</p>
<p>设R&lt;U，F&gt; 的任一关系r中任意的两个元组t，s：</p>
<p>若t[XZ]=s[XZ]，则有t[X]=s[X]和t[Z]=s[Z]；</p>
<p>由X→Y，于是有t[Y]=s[Y]，所以t[YZ]=s[YZ]，所以</p>
<p>XZ→YZ为F所蕴含，增广律得证。</p>
</li>
<li><p>传递律：若X→Y及Y→Z为F所蕴含，则X→Z为 F所蕴含。</p>
<p>证：设X→Y及Y→Z为F所蕴含。</p>
<p>对R&lt;U，F&gt; 的任一关系 r中的任意两个元组 t，s：</p>
<p>若t[X]=s[X]，由于X→Y，有 t[Y]=s[Y]；</p>
<p>再由Y→Z，有t[Z]=s[Z]，所以X→Z为F所蕴含，传递律得证。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>导出规则</p>
<ul>
<li><p>1.根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：</p>
<ul>
<li><p>合并规则：由X→Y，X→Z，有X→YZ。</p>
<p>（A2， A3）</p>
</li>
<li><p>伪传递规则：由X→Y，WY→Z，有XW→Z。</p>
<p>（A2， A3）</p>
</li>
<li><p>分解规则：由X→Y及 ZÍY，有X→Z。</p>
<p>（A1， A3）</p>
</li>
</ul>
</li>
<li><p>2.根据合并规则和分解规则，可得引理6.1</p>
<ul>
<li>引理6.l X→A1 A2…Ak成立的充分必要条件是X→Ai成立（i=l，2，…，k）</li>
</ul>
</li>
</ul>
</li>
<li><p>函数依赖闭包</p>
<ul>
<li>定义6.l2 在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依赖的全体叫作 F的闭包，记为F+。</li>
<li>定义6.13 设F为属性集U上的一组函数依赖，X ÍU， XF+ ={ A|X→A能由F 根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F 的闭包</li>
</ul>
</li>
<li><p>函数依赖集等价</p>
<ul>
<li><p>定义6.14 如果G+=F+，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。</p>
</li>
<li><p>引理6.3 F+ = G+ 的充分必要条件是F Í G+ ，和G Í F+</p>
<p>证: 必要性显然，只证充分性。</p>
<p>（1）若FÍG+ ，则XF+ Í XG++ 。</p>
<p>（2）任取X→YÎF+ 则有 Y Í XF+ Í XG++ 。</p>
<p>​     所以X→Y Î (G+）+= G+。即F+ Í G+。</p>
<p>（3）同理可证G+ Í F+ ，所以F+ = G+。</p>
</li>
</ul>
</li>
<li><p>最小依赖集</p>
<ul>
<li>定义6.15 如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集。亦称为最小依赖集或最小覆盖。<ul>
<li>(1) F中任一函数依赖的右部仅含有一个属性。</li>
<li>(2) F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</li>
<li>(3) F中不存在这样的函数依赖X→A， X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</li>
</ul>
</li>
</ul>
</li>
<li><p>极小化过程</p>
<ul>
<li><p>定理6.3 每一个函数依赖集F均等价于一个极小函数依赖集Fm。此Fm称为F的最小依赖集。</p>
<p>证明: 构造性证明，找出F的一个最小依赖集。</p>
<p>(1)逐一检查F中各函数依赖FDi：X→Y，若Y=A1A2 …Ak，k &gt; 2，</p>
<p>则用 { X→Aj |j=1，2，…， k} 来取代X→Y。</p>
<p>(2)逐一检查F中各函数依赖FDi：X→A，令G=F-{X→A}，</p>
<p>若AÎXG+， 则从F中去掉此函数依赖。</p>
<p>(3)逐一取出F中各函数依赖FDi：X→A，设X=B1B2…Bm，</p>
<p>逐一考查Bi （i=l，2，…，m），若A Î（X-Bi ）F+ ，</p>
<p>则以X-Bi 取代X。</p>
</li>
</ul>
</li>
<li><p>模式的分解</p>
<ul>
<li>三种模式分解等价的定义：<ul>
<li>⒈ 分解具有无损连接性</li>
<li>⒉ 分解要保持函数依赖</li>
<li>⒊ 分解既要保持函数依赖，又要具有无损连接性</li>
</ul>
</li>
<li>定义6.16 关系模式R&lt;U,F&gt;的一个分解：<em>ρ</em>={ R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;，…，Rn&lt;Un,Fn&gt;}，U= ∪U<em>i</em>，且不存在 Ui Í Uj，Fi 为 F在 Ui 上的投影</li>
<li>定义6.17 函数依赖集合{X→Y | X→Y Î F+∧XY ÍUi} 的一个覆盖 Fi 叫作 F 在属性 Ui 上的投影</li>
</ul>
</li>
<li><p>具有无损连接性的模式分解</p>
<ul>
<li>关系模式R&lt;U,F&gt;的一个分解 ρ={ R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;， …，Rn&lt;Un,Fn&gt;}，若R与R1、R2、…、Rn自然连接的结果相等，则称关系模式R的这个分解ρ具有无损连接性（Lossless join）</li>
<li>具有无损连接性的分解保证不丢失信息</li>
<li>无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题</li>
</ul>
</li>
<li><p>保持函数依赖的模式分解</p>
<ul>
<li>设关系模式R&lt;U,F&gt;被分解为若干个关系模式，R1&lt;U1,F1&gt;，R2&lt;U2,F2&gt;，…，Rn&lt;Un,Fn&gt; ，（其中U=U1∪U2∪…∪Un，且不存在Ui Í Uj，Fi为F在Ui上的投影），若F所逻辑蕴含的函数依赖一定也由分解得到的某个关系模式中的函数依赖Fi所逻辑蕴含，则称关系模式R的这个分解是保持函数依赖的（Preserve dependency）</li>
</ul>
</li>
<li><p>关系模式的规范化，其基本思想：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230255351.png" alt="img"></p>
</li>
<li><p>小结</p>
<ul>
<li>若要求分解具有无损连接性，那么模式分解一定能够达到4NF</li>
<li>若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF</li>
<li>若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF，但不一定能够达到BCNF</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>数据库设计</strong></p>
<ol>
<li><p>数据库设计的特点</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302558747.png" alt="img"></p>
</li>
<li><p>数据库设计方法</p>
</li>
</ol>
<ul>
<li>基本思想：过程迭代和逐步求精<ul>
<li>新奥尔良（New Orleans）方法<ul>
<li>将数据库设计分为若干阶段和步骤</li>
</ul>
</li>
<li>基于E-R模型的数据库设计方法<ul>
<li>概念设计阶段广泛采用</li>
</ul>
</li>
<li>3NF（第三范式）的设计方法<ul>
<li>逻辑阶段可采用的有效方法</li>
</ul>
</li>
<li>ODL（Object Definition Language）方法<ul>
<li>面向对象的数据库设计方法</li>
</ul>
</li>
<li>计算机辅助设计<ul>
<li>ORACLE Designer 2000</li>
<li>SYBASE PowerDesigner</li>
</ul>
</li>
</ul>
</li>
<li>数据库设计的基本步骤<ul>
<li>数据库设计分6个阶段<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ul>
</li>
<li>需求分析和概念设计独立于任何数据库管理系统</li>
<li>逻辑设计和物理设计与选用的DBMS密切相关</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302576437.png" alt="img"></p>
<ol>
<li>数据库设计过程中的各级模式</li>
</ol>
<ul>
<li><p>数据库设计不同阶段形成的数据库各级模式</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302577583.png" alt="img"></p>
</li>
</ul>
<ol>
<li>结构化分析方法（Structured Analysis，简称SA方法）</li>
</ol>
<ul>
<li><p>从最上层的系统组织机构入手</p>
</li>
<li><p>自顶向下、逐层分解分析系统</p>
<ul>
<li>1．首先把任何一个系统都抽象为：</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230258648.png" alt="img"></p>
<ul>
<li><p>2．分解处理功能和数据</p>
<ul>
<li>(1)分解处理功能<ul>
<li>将处理功能的具体内容分解为若干子功能</li>
</ul>
</li>
<li>(2)分解数据<ul>
<li>处理功能逐步分解同时，逐级分解所用数据，形成若干层次的数据流图</li>
</ul>
</li>
<li>(3)表达方法<ul>
<li>处理逻辑：用判定表或判定树来描述</li>
<li>数据：用数据字典来描述</li>
</ul>
</li>
</ul>
</li>
<li><p>3．将分析结果再次提交给用户，征得用户的认可</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302588239.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>数据字典</li>
</ol>
<ul>
<li><p>数据字典的用途</p>
<ul>
<li>进行详细的数据收集和数据分析所获得的主要结果</li>
</ul>
</li>
<li><p>数据字典的内容</p>
<ul>
<li>数据项</li>
<li>数据结构</li>
<li>数据流</li>
<li>数据存储</li>
<li>处理过程</li>
</ul>
</li>
<li><p>⒈ 数据项</p>
<ul>
<li><p>数据项是不可再分的数据单位</p>
</li>
<li><p>对数据项的描述</p>
<p>数据项描述＝｛数据项名，数据项含义说明，别名，</p>
<p>数据类型，长度，取值范围，取值含义，</p>
<p>​      与其他数据项的逻辑关系，数据项之间的联系 ｝</p>
</li>
</ul>
</li>
<li><p>⒉ 数据结构</p>
<ul>
<li><p>数据结构反映了数据之间的组合关系。</p>
</li>
<li><p>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</p>
</li>
<li><p>对数据结构的描述</p>
<p>数据结构描述＝｛数据结构名，含义说明，</p>
<p>组成:｛数据项或数据结构｝｝</p>
</li>
</ul>
</li>
<li><p>⒊ 数据流</p>
<ul>
<li><p>数据流是数据结构在系统内传输的路径。</p>
</li>
<li><p>对数据流的描述</p>
<p>数据流描述＝｛ 数据流名，说明，数据流来源，</p>
<p>数据流去向，组成:｛数据结构｝，</p>
<p>平均流量，高峰期流量｝</p>
</li>
</ul>
</li>
<li><p>⒋ 数据存储</p>
<ul>
<li><p>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。</p>
</li>
<li><p>对数据存储的描述</p>
<p>数据存储描述＝｛数据存储名，说明，编号，</p>
<p>​       输入的数据流 ，输出的数据流 ，</p>
<p>​       组成:｛数据结构｝，数据量，存取频度，存取方式｝</p>
</li>
</ul>
</li>
<li><p>⒌ 处理过程</p>
<ul>
<li><p>具体处理逻辑一般用判定表或判定树来描述</p>
</li>
<li><p>处理过程说明性信息的描述</p>
<p>处理过程描述＝｛处理过程名，说明，输入:｛数据流｝，</p>
<p>输出:｛数据流｝，处理:｛简要说明｝｝</p>
</li>
</ul>
</li>
</ul>
<ol>
<li>概念结构设计</li>
</ol>
<ul>
<li>设计概念结构的四类方法<ul>
<li>自顶向下</li>
</ul>
</li>
</ul>
<ol>
<li>首先定义全局概念结构的框架，然后逐步细化</li>
</ol>
<ul>
<li>自底向上</li>
</ul>
<ol>
<li>首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构</li>
</ol>
<ul>
<li>逐步扩张</li>
</ul>
<ol>
<li>首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构</li>
</ol>
<ul>
<li>混合策略</li>
</ul>
<ol>
<li>将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。</li>
</ol>
<ul>
<li><p>常用策略</p>
<ul>
<li><p>自顶向下地进行需求分析</p>
</li>
<li><p>自底向上地设计概念结构</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302594127.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>自底向上设计概念结构的步骤</p>
<ul>
<li><p>  第1步：抽象数据并设计局部视图</p>
</li>
<li><p>第2步：集成局部视图，得到全局概念结构</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230259780.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>数据抽象与局部视图设计</p>
<ul>
<li><p>数据抽象</p>
<ul>
<li>三种常用抽象<ul>
<li>\1. 分类（Classification）<ul>
<li>定义某一类概念作为现实世界中一组对象的类型</li>
<li>抽象了对象值和型之间的”is member of”的语义</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302596668.png" alt="img"></p>
<ul>
<li>\2. 聚集（Aggregation）<ul>
<li>定义某一类型的组成成分</li>
<li>抽象了对象内部类型和成分之间”is part of”的语义</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212302596145.png" alt="img"></p>
<ul>
<li>复杂的聚集，某一类型的成分仍是一个聚集</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303001195.png" alt="img"></p>
<ul>
<li>\3. 概括（Generalization）<ul>
<li>定义类型之间的一种子集联系</li>
<li>抽象了类型之间的”is subset of”的语义</li>
<li>继承性</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303002307.png" alt="img"></p>
</li>
<li><p>局部视图设计</p>
<ul>
<li>设计分E-R图的步骤:<ul>
<li>⒈选择局部应用<ul>
<li>在多层的数据流图中选择一个适当层次的数据流图，作为设计分E-R图的出发点</li>
<li>通常以中层数据流图作为设计分E-R图的依据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303015438.png" alt="img"></p>
<ul>
<li>⒉逐一设计分E-R图<ul>
<li>任务<ul>
<li>将各局部应用涉及的数据分别从数据字典中抽取出来</li>
<li>参照数据流图，标定各局部应用中的实体、实体的属性、标识实体的码</li>
<li>确定实体之间的联系及其类型（1:1，1:n，m:n）</li>
</ul>
</li>
<li>两条准则：<ul>
<li>（1）属性不能再具有需要描述的性质。即属性必须是不可分的数据项，不能再由另一些属性组成</li>
<li>（2）属性不能与其他实体具有联系。联系只发生在实体之间</li>
</ul>
</li>
<li>举例</li>
</ul>
</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303024981.png" alt="img"></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303025570.png" alt="img"></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303028983.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>逻辑结构设计</li>
</ol>
<ul>
<li>E-R图向关系模型的转换</li>
<li>数据模型的优化<ul>
<li>优化数据模型的方法<ul>
<li>1确定数据依赖<ul>
<li>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖</li>
</ul>
</li>
<li>2消除 冗余的联系<ul>
<li>对于各个关系模式之间的数据依赖进行极小化处理，消除 冗余的联系。</li>
</ul>
</li>
<li>3确定所属范式<ul>
<li>按照数据依赖的理论对关系模式逐一进行分析</li>
<li>考查是否存在部分函数依赖、传递函数依赖、多值依赖等</li>
<li>确定各关系模式分别属于第几范式</li>
</ul>
</li>
<li>4按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</li>
<li>注意：并不是规范化程度越高的关系就越优，一般说来，第三范式就足够了</li>
<li>5按照需求分析阶段得到的各种应用对数据处理的要求，对关系模式进行必要的分解，以提高数据操作的效率和存储空间的利用率</li>
</ul>
</li>
</ul>
</li>
<li>设计用户子模式<ul>
<li>定义用户外模式时应该注重的问题<ul>
<li>包括三个方面：<ul>
<li>(1) 使用更符合用户习惯的别名</li>
<li>(2) 针对不同级别的用户定义不同的View ，以满足系统对安全性的要求。</li>
<li>(3) 简化用户对系统的使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>数据库的物理设计</li>
</ol>
<ul>
<li>数据库物理设计的内容和方法</li>
<li>关系模式存取方法选择<ul>
<li>DBMS常用存取方法<ul>
<li>索引方法<ul>
<li>目前主要是B+树索引方法</li>
<li>经典存取方法，使用最普遍</li>
</ul>
</li>
<li>聚簇（Cluster）方法<ul>
<li>HASH方法</li>
</ul>
</li>
</ul>
</li>
<li>选择索引存取方法的一般规则<ul>
<li>如果一个(或一组)属性经常在查询条件中出现，则考虑在这个(或这组)属性上建立索引(或组合索引)</li>
<li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li>
<li>如果一个(或一组)属性经常在连接操作的连接条件中出现，则考虑在这个(或这组)属性上建立索引</li>
</ul>
</li>
<li>聚簇<ul>
<li>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块称为聚簇</li>
</ul>
</li>
<li>聚簇的用途<ul>
<li>\1. 大大提高按聚簇码进行查询的效率</li>
<li>\2. 节省存储空间<ul>
<li>聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了</li>
</ul>
</li>
</ul>
</li>
<li>聚簇的局限性<ul>
<li>\1. 聚簇只能提高某些特定应用的性能</li>
<li>\2. 建立与维护聚簇的开销相当大<ul>
<li>对已有关系建立聚簇，将导致关系中元组移动其物理存储位置，并使此关系上原有的索引无效，必须重建</li>
<li>当一个元组的聚簇码改变时，该元组的存储位置也要做相应移动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>确定数据的存放位置<ul>
<li>根据应用情况将<ul>
<li>易变部分与稳定部分分开存放</li>
<li>存取频率较高部分与存取频率较低部分，分开存放</li>
</ul>
</li>
</ul>
</li>
<li>评价物理结构</li>
</ul>
<ol>
<li>小结（续）</li>
</ol>
<ul>
<li>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模型，形成数据库逻辑模式。然后根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图（VIEW）形成数据的外模式</li>
<li>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库内模式</li>
</ul>
<p><strong>数据库编程</strong></p>
<ul>
<li>嵌入式SQL</li>
</ul>
<ol>
<li>嵌入式SQL的处理过程</li>
</ol>
<ul>
<li>数据库工作单元与源程序工作单元之间的通信：<ul>
<li>\1. SQL通信区<ul>
<li>向主语言传递SQL语句的执行状态信息</li>
<li>使主语言能够据此控制程序流程</li>
</ul>
</li>
<li>\2. 主变量<ul>
<li>主语言向SQL语句提供参数</li>
<li>将SQL语句查询数据库的结果交主语言进一步处理</li>
</ul>
</li>
<li>\3. 游标<ul>
<li>解决集合性操作语言与过程性操作语言的不匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>嵌入式SQL与主语言的通信</li>
</ol>
<ul>
<li><p>在SQL语句中使用主变量和指示变量的方法</p>
<ul>
<li><ol>
<li>说明主变量和指示变量</li>
</ol>
<p><strong>BEGIN DECLARE SECTION</strong></p>
<p>  <strong>………</strong></p>
<p>  <strong>……… (说明主变量和指示变量)</strong></p>
<p>  <strong>………</strong></p>
<p><strong>END DECLARE SECTION</strong></p>
</li>
<li><ol start="2">
<li>使用主变量</li>
</ol>
<ul>
<li>说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现</li>
<li>为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志</li>
</ul>
</li>
<li><ol start="3">
<li>使用指示变量</li>
</ol>
<ul>
<li>指示变量前也必须加冒号标志</li>
<li>必须紧跟在所指主变量之后</li>
</ul>
</li>
</ul>
</li>
<li><p>在SQL语句之外(主语言语句中)使用主变量和指示变量的方法</p>
<ul>
<li>可以直接引用，不必加冒号</li>
</ul>
</li>
<li><p>游标（cursor）</p>
<ul>
<li>SQL语言与主语言具有不同数据处理方式</li>
<li>SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录</li>
<li>主语言是面向记录的，一组主变量一次只能存放一条记录</li>
<li>仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求</li>
<li>嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式</li>
<li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</li>
<li>每个游标区都有一个名字</li>
<li>用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理</li>
</ul>
</li>
<li><p>建立和关闭数据库连接</p>
<ul>
<li><p>建立数据库连接</p>
<p><strong>EXEC SQL CONNECT TO target [AS connection-name] [USER user-name];</strong></p>
<ul>
<li>target是要连接的数据库服务器：<ul>
<li>常见的服务器标识串，如<dbname>@<hostname>:<port></port></hostname></dbname></li>
<li>包含服务器标识的SQL串常量</li>
<li>DEFAULT</li>
</ul>
</li>
<li>connect-name是可选的连接名，连接必须是一个有效的标识符 在整个程序内只有一个连接时可以不指定连接名</li>
</ul>
</li>
<li><p>关闭数据库连接</p>
<p><strong>EXEC SQL DISCONNECT [connection];</strong></p>
</li>
<li><p>程序运行过程中可以修改当前连接 ：</p>
<p><strong>EXEC SQL SET CONNECTION connection-name | DEFAULT;</strong></p>
</li>
</ul>
</li>
<li><p>不用游标的SQL语句的种类</p>
<ul>
<li>说明性语句</li>
<li>数据定义语句</li>
<li>数据控制语句</li>
<li>查询结果为单记录的SELECT语句</li>
<li>非CURRENT形式的增删改语句</li>
</ul>
</li>
<li><p>使用游标的SQL语句</p>
<ul>
<li><p>查询结果为多条记录的SELECT语句</p>
<ul>
<li><p>使用游标的步骤</p>
<ul>
<li><p>\1. 说明游标</p>
<ul>
<li><p>使用DECLARE语句</p>
</li>
<li><p>语句格式</p>
<p><strong>EXEC SQL DECLARE &lt;游标名&gt; CURSOR</strong></p>
<p><strong>FOR ;</strong></p>
</li>
<li><p>功能</p>
<p>是一条说明性语句，这时DBMS并不执行SELECT指定的查询操作。</p>
</li>
</ul>
</li>
<li><p>\2. 打开游标</p>
<ul>
<li><p>使用OPEN语句</p>
</li>
<li><p>语句格式</p>
<p><strong>EXEC SQL OPEN &lt;游标名&gt;;</strong></p>
</li>
<li><p>功能</p>
<p>打开游标实际上是执行相应的SELECT语句，把所有满足查询条件的记录从指定表取到缓冲区中这时游标处于活动状态，指针指向查询结果集中第一条记录</p>
</li>
</ul>
</li>
<li><p>3.推进游标指针并取当前记录</p>
<ul>
<li><p>使用FETCH语句</p>
</li>
<li><p>语句格式</p>
<p><strong>EXEC SQL FETCH [[NEXT|PRIOR|</strong></p>
<p><strong>FIRST|LAST] FROM] &lt;游标名&gt;</strong></p>
<p><strong>INTO &lt;主变量&gt;[&lt;指示变量&gt;][,&lt;主变量&gt;[&lt;指示变量&gt;]]…;</strong></p>
</li>
<li><p>功能</p>
<p>指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理</p>
<p>NEXT|PRIOR|FIRST|LAST：指定推动游标指针的方式</p>
<p>NEXT：向前推进一条记录</p>
<p>PRIOR：向回退一条记录</p>
<p>FIRST：推向第一条记录</p>
<p>LAST：推向最后一条记录</p>
<p>缺省值为NEXT</p>
</li>
</ul>
</li>
<li><p>\4. 关闭游标</p>
<ul>
<li><p>使用CLOSE语句</p>
</li>
<li><p>语句格式</p>
<p><strong>EXEC SQL CLOSE &lt;游标名&gt;;</strong></p>
</li>
<li><p>功能</p>
<p>关闭游标，释放结果集占用的缓冲区及其他资源</p>
</li>
<li><p>说明</p>
<p>游标被关闭后，就不再和原来的查询结果集相联系</p>
<p>被关闭的游标可以再次被打开，与新的查询结果相联系</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CURRENT形式的UPDATE语句</p>
<ul>
<li><p>CURRENT形式的UPDATE语句和DELETE语句的用途</p>
<ul>
<li>面向集合的操作</li>
<li>一次修改或删除所有满足条件的记录</li>
</ul>
</li>
<li><p>如果只想修改或删除其中某个记录</p>
<ul>
<li><p>用带游标的SELECT语句查出所有满足条件的记录</p>
</li>
<li><p>从中进一步找出要修改或删除的记录</p>
</li>
<li><p>用CURRENT形式的UPDATE语句和DELETE语句修改或删除之</p>
</li>
<li><p>UPDATE语句和DELETE语句中的子句：</p>
<p><strong>WHERE CURRENT OF &lt;游标名&gt;</strong></p>
<p>表示修改或删除的是最近一次取出的记录，即游标指针指向的记录</p>
</li>
</ul>
</li>
<li><p>不能使用CURRENT形式的UPDATE语句和DELETE语句 :</p>
<ul>
<li>当游标定义中的SELECT语句带有UNION或ORDER BY子句</li>
<li>该SELECT语句相当于定义了一个不可更新的视图</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>动态SQL</li>
</ol>
<ul>
<li><p>静态嵌入式SQL</p>
<ul>
<li>静态嵌入式SQL语句能够满足一般要求</li>
<li>无法满足要到执行时才能够确定要提交的SQL语句</li>
</ul>
</li>
<li><p>动态嵌入式SQL</p>
<ul>
<li>允许在程序运行过程中临时”组装”SQL语句</li>
<li>支持动态组装SQL语句和动态参数两种形式</li>
</ul>
</li>
<li><p>SQL语句主变量：</p>
<ul>
<li>程序主变量包含的内容是SQL语句的内容，而不是原来保存数据的输入或输出变量</li>
<li>SQL语句主变量在程序执行期间可以设定不同的SQL语句，然后立即执行</li>
</ul>
</li>
<li><p>动态参数</p>
<ul>
<li>SQL语句中的可变元素</li>
<li>使用参数符号(?)表示该位置的数据在运行时设定</li>
</ul>
</li>
<li><p>和主变量的区别</p>
<ul>
<li>动态参数的输入不是编译时完成绑定</li>
<li>而是通过 (prepare)语句准备主变量和执行(execute)时绑定数据或主变量来完成</li>
</ul>
</li>
<li><p>使用动态参数的步骤：</p>
<ul>
<li><p>1.声明SQL语句主变量。</p>
</li>
<li><p>2.准备SQL语句(PREPARE)。</p>
<p><strong>EXEC SQL PREPARE &lt;语句名&gt; FROM ;</strong></p>
</li>
<li><p>3.执行准备好的语句(EXECUTE)</p>
<p><strong>EXEC SQL EXECUTE &lt;语句名&gt; [INTO &lt;主变量表&gt;] [USING &lt;  主变量或常量&gt;];</strong></p>
</li>
</ul>
</li>
<li><p>存储过程</p>
</li>
</ul>
<ol>
<li>PL/SQL的块结构</li>
</ol>
<ul>
<li><p>PL/SOL块的基本结构：</p>
<ul>
<li><p>1.定义部分</p>
<p><strong>DECLARE</strong>  </p>
<p><strong>——变量、常量、游标、异常等</strong></p>
<ul>
<li>定义的变量、常量等只能在该基本块中使用</li>
<li>当基本块执行结束时，定义就不再存在</li>
</ul>
</li>
<li><p>2.执行部分</p>
<p><strong>BEGIN</strong></p>
<p><strong>——SQL语句、PL/SQL的流程控制语句</strong></p>
<p><strong>EXCEPTION</strong></p>
<p><strong>——异常处理部分</strong>    </p>
<p><strong>END；</strong></p>
</li>
</ul>
</li>
<li><p>变量常量的定义</p>
<ul>
<li>\1. PL/SQL中定义变量的语法形式是:<ul>
<li>变量名 数据类型 ［ ［NOT NULL］:=初值表达式］或</li>
<li>变量名 数据类型 ［ ［NOT NULL］初值表达式］</li>
</ul>
</li>
<li>\2. 常量的定义类似于变量的定义:<ul>
<li>常量名 数据类型 CONSTANT :=常量表达式</li>
<li>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，PL/SQL将返回一个异常。</li>
</ul>
</li>
<li>\3. 赋值语句<ul>
<li>变量名称:=表达式</li>
</ul>
</li>
<li>控制结构</li>
</ul>
</li>
<li><p>一、条件控制语句</p>
<ul>
<li><p>IF-THEN， IF-THEN-ELSE和嵌套的IF语句</p>
<p>  <strong>1. IF condition THEN</strong></p>
<p>   <strong>Sequence_of_statements;</strong></p>
<p>   <strong>END IF</strong></p>
<p>  <strong>2. IF condition THEN</strong></p>
<p>   <strong>Sequence_of_statements1;</strong></p>
<p>   <strong>ELSE</strong></p>
<p>   <strong>Sequence_of_statements2;</strong></p>
<p>   <strong>END IF;</strong></p>
<p>  <strong>3. 在THEN和ELSE子句中还可以再包括IF语句，即IF语句可以嵌套</strong></p>
</li>
</ul>
</li>
<li><p>二、循环控制语句</p>
<ul>
<li><p>LOOP， WHILE-LOOP和FOR-LOOP</p>
<p><strong>1.最简单的循环语句LOOP</strong></p>
<p>   <strong>LOOP</strong></p>
<p>   <strong>Sequence_of_statements;</strong></p>
<p>   <strong>END LOOP;</strong></p>
<p>  <strong>多数数据库服务器的PL/SQL都提供EXIT、BREAK或LEAVE等循环结束语句，保证LOOP语句块能够结束。</strong></p>
<p><strong>2. WHILE-LOOP</strong></p>
<p><strong>WHILE condition LOOP</strong></p>
<p>   <strong>Sequence_of_statements;</strong></p>
<p>  <strong>END LOOP;</strong></p>
<p><strong>每次执行循环体语句之前，首先对条件进行求值</strong></p>
<p><strong>如果条件为真，则执行循环体内的语句序列。</strong></p>
<p><strong>如果条件为假，则跳过循环并把控制传递给下一个语句</strong></p>
<p><strong>3. FOR-LOOP</strong></p>
<p>  <strong>FOR count IN ［REVERSE］bound1 … bound2 LOOP</strong></p>
<p>   <strong>Sequence_of_statements;</strong></p>
<p>  <strong>END LOOP;</strong></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>存储过程的用户接口</li>
</ol>
<ul>
<li><p>\1. 创建存储过程：</p>
<p>  <strong>CREATE Procedure 过程名（［参数1，参数2，…］） AS</strong></p>
<p>  <strong>；</strong></p>
<ul>
<li><p>过程名：数据库服务器合法的对象标识</p>
</li>
<li><p>参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数。默认为输入参数。</p>
</li>
<li><p>过程体：是一个&lt;PL/SQL块&gt;。包括声明部分和可执行语句部分</p>
</li>
<li><p>重命名存储过程</p>
<p><strong>ALTER Procedure 过程名1 RENAME TO 过程名2;</strong></p>
</li>
</ul>
</li>
<li><p>\2. 执行存储过程：</p>
<p><strong>CALL/PERFORM Procedure 过程名(［参数1，参数2，…］)；</strong></p>
<ul>
<li>使用CALL或者PERFORM等方式激活存储过程的执行。</li>
<li>在PL/SQL中，数据库服务器支持在过程体中调用其他存储过程</li>
</ul>
</li>
<li><p>\3. 删除存储过程</p>
<p><strong>DROP PROCEDURE 过程名（）；</strong></p>
</li>
</ul>
<ol>
<li>ODBC编程</li>
</ol>
<p><strong>对象关系数据库系统</strong></p>
<ul>
<li>对象关系数据库系统(Object Relational Database System，ORDBS)是面向对象数据模型(Object Oriented Data Model，简称OO模型)和关系数据模型相结合的产物</li>
<li>面向对象数据模型</li>
</ul>
<ol>
<li>OO模型的核心概念</li>
</ol>
<ul>
<li>1.对象<ul>
<li>定义：对象是由一组数据结构和在这组数据结构上的操作的程序代码封装起来的基本单位。</li>
<li>组成部分<ul>
<li>属性(Attribute)集合<ul>
<li>属性描述对象的状态、组成和特性</li>
</ul>
</li>
<li>方法(Method)集合<ul>
<li>描述了对象的行为特性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>\2. 对象标识OID(Object IDentifier)<ul>
<li>概念：面向对象数据库中的每个对象都有一个唯一的不变的标识称为对象标识(OID)</li>
<li>特点：<ul>
<li>永久持久性</li>
<li>独立于值的、系统全局唯一的</li>
</ul>
</li>
</ul>
</li>
<li>\3. 封装(Encapsulation)<ul>
<li>每一个对象是其状态与行为的封装</li>
<li>封装是对象的外部界面与内部实现之间实行清晰隔离的一种抽象，外部与对象的通信只能通过消息</li>
<li>对象封装之后查询属性值必须通过调用方法</li>
</ul>
</li>
<li>\4. 类(Class)<ul>
<li>对象类(简称类)：共享同样属性和方法集的所有对象构成了一个对象类</li>
<li>实例：一个对象是某一类的一个实例(instance)</li>
<li>在OODB中，类是”型”，对象是某一类的一个”值”</li>
</ul>
</li>
</ul>
<ol>
<li><p>类层次(结构)</p>
</li>
<li><p>继承</p>
</li>
<li><p>对象的嵌套</p>
</li>
<li><p>关系数据模型与OO模型的比较</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/201110212303037065.png" alt="img"></p>
</li>
</ol>
<ul>
<li>对象-关系数据库</li>
</ul>
<ol>
<li>对象关系数据库系统中扩展的关系数据类型</li>
</ol>
<ul>
<li><p>1.大对象LOB(Large OBject )类型</p>
<ul>
<li>LOB可存储多达十亿字节的串。</li>
<li>LOB分类<ul>
<li>二进制大对象BLOB(Binary Large OBject)</li>
<li>BLOB用于存储音频、图像数据</li>
<li>字符串大对象CLOB(Character Large OBject)。</li>
<li>CLOB用于存储长字符串数据</li>
</ul>
</li>
</ul>
</li>
<li><p>2.BOOLEAN类型</p>
<ul>
<li>布尔类型，支持3个真值：true、false和unknown</li>
<li>操作符：NOT、AND、OR、EVERY、ANY<ul>
<li>例如 WHERE EVERY(QTY&gt;200)</li>
<li>   或WHERE ANY(QTY&gt;200)</li>
<li>QTY列为空值：返回unknown；</li>
<li>QTY列为非空：</li>
<li>当该列的每一个值都使(QTY&gt;200)为true时，EVERY返回true，否则为false；</li>
<li>当该列的每一个值都使(QTY&gt;200)为false时，ANY返回false，否则为true。</li>
</ul>
</li>
</ul>
</li>
<li><p>3.集合类型(Collection Type)ARRAY</p>
<ul>
<li><p>相同类型元素的有序集合称为数组ARRAY</p>
<ul>
<li>SQL3新增的集合类型</li>
<li>允许在数据库的一列中存储数组</li>
</ul>
</li>
<li><p>SQL3的数组只能是一维的</p>
<ul>
<li><p>数组中的元素不能再是数组</p>
</li>
<li><p>［例2］</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> SALES</p>
<p><strong>(</strong></p>
<p>ITEM_NO <strong>CHAR(**20</strong>)**， /<em>商品号</em>/</p>
<p>QTY <strong>INTEGER</strong> <strong>ARRAY</strong>［12］， /<em>整数数组，存放销售额</em>/</p>
<p><strong>PRIMARY</strong> <strong>KEY(**ITEM_NO</strong>)**</p>
<p>**)**；</p>
</li>
<li><p>向SALES表插入一个元组：</p>
</li>
</ul>
<p><strong>INSERT</strong> <strong>INTO</strong> SALES**(<strong>ITEM_NO，QTY</strong>)VALUES**</p>
<p><strong>(</strong>‘T**-<strong>shirt2000’，</strong>ARRAY**［200，150，200，100，50，70，</p>
<p>80，200，10，20，100，200］**)**；</p>
<ul>
<li><p>查找三月份销售额大于100的商品号：</p>
<p><strong>SELECT</strong> ITEM_NO</p>
<p><strong>FROM</strong> SALES</p>
<p><strong>WHERE</strong> QTY［3］**&gt;**100；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>\4. DISTINCT类型</p>
<ul>
<li><p>SQL3新加了一种DISTINCT类型</p>
</li>
<li><p>定义DISTINCT数据类型语法</p>
<p>CREAT <strong>TYPE</strong> ** name**&gt;**</p>
<p><strong>AS</strong> <strong>&lt;**built **in** scalar **type** name**&gt;</strong> FINAL</p>
<p><strong>[</strong> ** <strong>option&gt;]</strong></p>
<p><strong>[</strong> <strong>&lt;**method specification commalist**&gt;];</strong></p>
</li>
<li><p>没有使用DISTINCT类型</p>
<ul>
<li>例如，职工的智商字段(IQ)和鞋号字段(SHOE_SIZE)定义成INTEGER类型</li>
<li>WHERE SHOE_SIZE &gt; IQ</li>
</ul>
</li>
<li><p>使用DISTINCT类型</p>
<ul>
<li><p>重新定义这两字段类型</p>
<p>CREAT <strong>TYPE</strong> SHOE_SIZE_TYPE <strong>AS</strong> <strong>INTEGER</strong> FINAL**;**</p>
<p>CREAT <strong>TYPE</strong> IQ_TYPE <strong>AS</strong> <strong>INTEGER</strong> FINAL**;**</p>
</li>
<li><p>SHOE_SIZE_TYPE和IQ _TYPE成为两种不同的数据类型</p>
</li>
<li><p>表达式：WHERE SHOE_SIZE &gt; IQ 是非法的</p>
</li>
<li><p>如果在定义类型时设置了选项<cast option="">，下面用法也是合法的：WHERE MY_SHOE_SIZE &gt; CAST (MY_IQ AS SHOE_SIZE)</cast></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>对象关系数据库系统中扩展的对象类型及其定义</li>
</ol>
<ul>
<li><p>在ORDBMS中，类型(TYPE)具有类(CLASS)的特征，可以看成类</p>
<ul>
<li><p>1.行对象与行类型</p>
<ul>
<li><p>定义行类型(ROW TYPE) ：</p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> <strong>&lt;**row_type_name**&gt;</strong></p>
<p>**(&lt;**component declarations**&gt;)**；</p>
</li>
<li><p>创建行类型</p>
<ul>
<li><p>［例3］</p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Person_type</p>
<p><strong>(**pno **NUMBER</strong>，</p>
<p>name <strong>VARCHAR2(**100</strong>)**，</p>
<p>address <strong>VARCHAR2(**100</strong>)** <strong>);</strong></p>
</li>
</ul>
</li>
<li><p>创建基于行类型的表</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> <strong>&lt;**table_name**&gt;</strong> <strong>OF</strong> <strong>&lt;**row_type_name**&gt;;</strong></p>
<ul>
<li><p>［例4］</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> person_extent <strong>OF</strong> Person_type</p>
<p><strong>(**pno **PRIMARY</strong> <strong>KEY</strong> <strong>);</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.列对象与对象类型</p>
<ul>
<li><p>可以创建一个对象类型，表的属性可以是该对象类型。</p>
</li>
<li><p>创建列对象语句如下:</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> <strong>&lt;**type_name**&gt;</strong> <strong>AS</strong> <strong>OBJECT</strong></p>
<p><strong>(&lt;**component declarations**&gt;);</strong></p>
</li>
<li><p>［例5］</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> address_objtyp <strong>AS</strong> <strong>OBJECT</strong></p>
<p><strong>(**street **VARCHAR2(**50</strong>)**，</p>
<p>city <strong>VARCHAR2(**50</strong>)** <strong>);</strong></p>
<p></p>
<p><strong>CREATE</strong> <strong>TYPE</strong> name_objtyp <strong>AS</strong> <strong>OBJECT</strong></p>
<p><strong>(**first_name **VARCHAR2(**30</strong>)**，</p>
<p>last_name <strong>VARCHAR2(**30</strong>)** <strong>)</strong> <strong>;</strong></p>
</li>
<li><p>创建表，定义其中的属性是对象类型</p>
</li>
<li><p>［例6］</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> people_reltab <strong>(</strong></p>
<p>Id <strong>NUMBER(**10</strong>)**，</p>
<p>name_obj name_objtyp，</p>
<p>address_obj address_objtyp**);**</p>
</li>
</ul>
</li>
<li><p>\3. 抽象数据类型(Abastract Data Type，ADT)</p>
<ul>
<li><p>概念：SQL3允许用户创建指定的带有自身行为说明和内部结构的用户定义类型称为抽象数据类型</p>
</li>
<li><p>定义ADT的一般形式为</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> <strong>&lt;**type_name**&gt;</strong> <strong>(</strong></p>
<p>所有属性名及其类型说明，</p>
<p><strong>[**定义该类型的等于＝和小于</strong>&lt;<strong>函数，</strong>]**</p>
<p>定义该类型其他函数**(<strong>方法</strong>));**</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>参照类型(Reference Type)</li>
</ol>
<ul>
<li><p>REF类型（参照类型、引用类型）</p>
<ul>
<li><p>引入的原因：</p>
<ul>
<li>类型之间可能具有相互参照的联系</li>
</ul>
</li>
<li><p>形式</p>
<ul>
<li>REF &lt;类型名&gt;</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>REF类型总是和某个特定的类型相联系。</li>
<li>它的值是OID</li>
</ul>
</li>
<li><p>创建两个表：Employee和Company，两表之间存在相互参照关系，即某个职工在某个公司工作</p>
<ul>
<li><p>(1)创建行类型</p>
</li>
<li><p>［例7］</p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> employee_type**(**</p>
<p>name <strong>VARCHAR(**35</strong>)**，</p>
<p>age <strong>INTEGER</strong> <strong>);</strong></p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Comp_type**(**</p>
<p>compname <strong>VARCHAR(**20</strong>)**，</p>
<p>location <strong>VARCHAR(**20</strong>)** <strong>);</strong></p>
</li>
<li><p>(2)创建基于行类型的表：</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> Employee <strong>OF</strong> employee_type**;**</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> Company <strong>OF</strong> Comp_type</p>
</li>
<li><p>(3)描述参照关系</p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> Employment_type <strong>(</strong></p>
<p>employee <strong>REF</strong> <strong>(**employee_type</strong>)**，</p>
<p>company <strong>REF</strong> <strong>(**Comp_type</strong>)** <strong>);</strong></p>
<p><strong>CREATE</strong> <strong>TABLE</strong> Employment <strong>OF</strong> Employment _type</p>
</li>
<li><p>表Employment中某一个元组的employee属性值是某个职工的OID</p>
</li>
<li><p>company属性值是该职工所在公司的OID</p>
</li>
<li><p>［例8］</p>
<p><strong>CREATE</strong> <strong>ROW</strong> <strong>TYPE</strong> employee_type**(**</p>
<p>name <strong>VARCHAR(**35</strong>)**，</p>
<p>age <strong>INTEGER</strong>，</p>
<p>emp_id <strong>REF(**employee_type</strong>)** <strong>);</strong></p>
</li>
<li><p>［例9］</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> Employee <strong>OF</strong> employee_type</p>
<p><strong>VALUES</strong> <strong>FOR</strong> emp_id <strong>ARE</strong> SYSTEM GENERATED**;**</p>
</li>
</ul>
</li>
<li><p>建立参照属性：</p>
<p><strong>&lt;参照属性名&gt;［REF(&lt;类型名&gt;)］SCOPE IS &lt;关系名&gt;</strong></p>
<ul>
<li>［例10］</li>
</ul>
<p><strong>CREATE</strong> <strong>TABLE</strong> address_objtab <strong>OF</strong> address_objtyp <strong>;</strong></p>
<ul>
<li><p>［例11］</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> people_reltab2 <strong>(</strong></p>
<p>id <strong>NUMBER(**4</strong>)** <strong>PRIMARY</strong> <strong>KEY</strong>，</p>
<p>name_obj name_objtyp，</p>
<p>addresss_ref <strong>REF(**address_objtyp</strong>)** <strong>SCOPE</strong> <strong>IS</strong> address_objtab <strong>)</strong></p>
</li>
<li><p>［例12］</p>
</li>
</ul>
<p><strong>CREATE</strong> <strong>INDEX</strong> address_ref_idx <strong>ON</strong> people_reltab2**(<strong>address_ref</strong>)** <strong>;</strong></p>
<ul>
<li><p>［例13］</p>
<p><strong>SELECT</strong> id</p>
<p><strong>FROM</strong> people_reltab2 p</p>
<p><strong>WHERE</strong> p**.<strong>address_ref</strong>.<strong>city</strong>=<strong>‘北京’ **and</strong></p>
<p>p**.<strong>address_ref</strong>.<strong>street</strong>=<strong>‘牛街’</strong>;**</p>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<ol>
<li>继承性</li>
</ol>
<ul>
<li><p>ORDBMS应该支持继承性</p>
<ul>
<li><p>一般是单继承性</p>
<ul>
<li><p>［例14］</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> emp_type</p>
<p><strong>UNDER</strong> person_type <strong>AS(</strong></p>
<p>emp_id <strong>INTEGER</strong>，</p>
<p>salary <strong>REAL</strong> <strong>)</strong></p>
<p><strong>NOT</strong> FINAL**;**</p>
</li>
<li><p>NOT FINAL：表示不是类层次结构中最后的”叶结点”</p>
</li>
<li><p>FINAL：该类型是类层次结构的叶结点</p>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<ol>
<li>子表和超表</li>
</ol>
<ul>
<li><p>［例15］ 对于下面的类型层次，先定义这些类型TYPE，然后创建基于这些类型的表</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/luowei010101/201110/20111021230303162.png" alt="img"></p>
<p><strong>CREATE</strong> <strong>TYPE</strong> person /<em>创建person 类型，根类型</em>/</p>
<p><strong>(**id **INTEGER</strong>，</p>
<p>name <strong>VARCHAR(**20</strong>)**，</p>
<p>birthyear <strong>INTEGER</strong>，</p>
<p>address <strong>VARCHAR(**40</strong>))**</p>
<p><strong>NOT</strong> FINAL； /<em>NOT FINAL表示可以有子类型</em>/</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> employee /<em>创建person的子类型employee</em>/</p>
<p><strong>UNDER</strong> person /<em>类型employee继承person的属性</em>/</p>
<p><strong>(**salary **INTEGER)</strong> /* employee定义自己的属性*/</p>
<p><strong>NOT</strong> FINAL；</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> executive /<em>创建employee的子类型executive</em>/</p>
<p><strong>UNDER</strong> employee</p>
<p><strong>(**bonus **INTEGER)</strong></p>
<p>FINAL；</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> student /*创建person的子类型student */</p>
<p><strong>UNDER</strong> person</p>
<p><strong>(**major **VARCHAR(**10</strong>)<strong>，wage **DECIMAL)</strong></p>
<p>FINAL</p>
</li>
<li><p>例16］Department类型和employee具有相互参照的联系，使用REF来表示这种联系</p>
<p><strong>CREATE</strong> <strong>TYPE</strong> department</p>
<p><strong>(**ID **INTEGER</strong>，</p>
<p>manager <strong>REF(**employee</strong>)**，</p>
<p>Budget <strong>INTEGER);</strong></p>
<p><strong>ALTER</strong> <strong>TYPE</strong> employee</p>
<p><strong>ADD</strong> ATTRIBUTE dept <strong>REF(**department</strong>);**</p>
</li>
<li><p>定义基于这些类型的基本表和表层次：</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> person_table <strong>OF</strong> person</p>
<p><strong>(**name **WITH</strong> OPTIONS <strong>NOT</strong> <strong>NULL);</strong></p>
<p><strong>CREATE</strong> <strong>TABLE</strong> employee_table <strong>OF</strong> employee</p>
<p><strong>UNDER</strong> person_table**;**</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> exec_table <strong>of</strong> executive</p>
<p><strong>UNDER</strong> employee_table</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> student_table <strong>OF</strong> student</p>
<p><strong>UNDER</strong> person_table；</p>
<p><strong>CREATE</strong> <strong>TABLE</strong> dept_table <strong>OF</strong> department</p>
<p><strong>(**manager **SCOPE</strong> <strong>IS</strong> employee_table**);**</p>
<p><strong>ALTER</strong> <strong>TABLE</strong> employee_table</p>
<p><strong>ALTER</strong> <strong>COLUMN</strong> dept <strong>ADD</strong> <strong>SCOPE</strong> <strong>IS</strong> dept_table**;**</p>
</li>
<li><p>查询[例16]所创建的表</p>
<ul>
<li><p>［例17］</p>
<p><strong>SELECT</strong> name，address</p>
<p><strong>FROM</strong> person_table</p>
<p><strong>WHERE</strong> birthyear <strong>&lt;=**1970</strong>;**</p>
</li>
</ul>
</li>
<li><p>关闭子表的检索</p>
<ul>
<li><p>［例18］</p>
<p><strong>SELECT</strong> name，address</p>
<p><strong>FROM</strong> <strong>ONLY</strong> person_table</p>
<p><strong>WHERE</strong> birthyear <strong>&lt;=**1970</strong>;**</p>
</li>
<li><p>INSERT、DELETE、UPDATE对子表和超表的操作规则</p>
<ul>
<li>INSERT：向子表插入一行时一般会在该子表的超表上也插入一行。</li>
<li>DELETE：从表删除一行时一般会在该表的超表和子表上也删除相应的一行</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">rain-Sky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">https://rain-sky.github.io/2021/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/rain-sky.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</a></div><div class="post_share"><div class="social-share" data-image="/rain-sky.github.io/image/10016.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/rain-sky.github.io/2021/01/12/%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="/rain-sky.github.io/image/10016.jpg" onerror="onerror=null;src='/rain-sky.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">算法</div></div></a></div><div class="next-post pull-right"><a href="/rain-sky.github.io/2021/01/12/Java%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/rain-sky.github.io/image/10016.jpg" onerror="onerror=null;src='/rain-sky.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Java基础</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://gitee.com/rain-sky/images/raw/master/20210516135239.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">rain-Sky</div><div class="author-info__description">努力勇敢一点点</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/rain-sky.github.io/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/rain-sky.github.io/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/rain-sky.github.io/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rain-sky"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">正在施工ing...</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/rain-sky.github.io/2021/04/27/%E6%B5%85%E6%9E%90-equals-hashcode/" title="浅析==,equals,hashcode"><img src="/rain-sky.github.io/image/10016.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/404.jpg'" alt="浅析==,equals,hashcode"/></a><div class="content"><a class="title" href="/rain-sky.github.io/2021/04/27/%E6%B5%85%E6%9E%90-equals-hashcode/" title="浅析==,equals,hashcode">浅析==,equals,hashcode</a><time datetime="2021-04-27T00:52:45.000Z" title="Created 2021-04-27 08:52:45">2021-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/rain-sky.github.io/2021/04/24/ssm%E6%95%B4%E5%90%88/" title="ssm整合"><img src="/rain-sky.github.io/image/10016.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/404.jpg'" alt="ssm整合"/></a><div class="content"><a class="title" href="/rain-sky.github.io/2021/04/24/ssm%E6%95%B4%E5%90%88/" title="ssm整合">ssm整合</a><time datetime="2021-04-24T01:49:32.000Z" title="Created 2021-04-24 09:49:32">2021-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/rain-sky.github.io/2021/04/24/%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/" title="问题集锦"><img src="/rain-sky.github.io/image/10016.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/404.jpg'" alt="问题集锦"/></a><div class="content"><a class="title" href="/rain-sky.github.io/2021/04/24/%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/" title="问题集锦">问题集锦</a><time datetime="2021-04-24T00:48:41.000Z" title="Created 2021-04-24 08:48:41">2021-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/rain-sky.github.io/2021/04/12/springMvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="springMvc执行流程"><img src="/rain-sky.github.io/image/10016.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/404.jpg'" alt="springMvc执行流程"/></a><div class="content"><a class="title" href="/rain-sky.github.io/2021/04/12/springMvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="springMvc执行流程">springMvc执行流程</a><time datetime="2021-04-12T02:21:46.000Z" title="Created 2021-04-12 10:21:46">2021-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/rain-sky.github.io/2021/04/11/springMvc%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E6%9C%AA%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4404%E9%97%AE%E9%A2%98/" title="springMvc项目打包后未打包依赖导致404问题"><img src="/rain-sky.github.io/image/10016.jpg" onerror="this.onerror=null;this.src='/rain-sky.github.io/img/404.jpg'" alt="springMvc项目打包后未打包依赖导致404问题"/></a><div class="content"><a class="title" href="/rain-sky.github.io/2021/04/11/springMvc%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E6%9C%AA%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96%E5%AF%BC%E8%87%B4404%E9%97%AE%E9%A2%98/" title="springMvc项目打包后未打包依赖导致404问题">springMvc项目打包后未打包依赖导致404问题</a><time datetime="2021-04-11T02:52:47.000Z" title="Created 2021-04-11 10:52:47">2021-04-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/rain-sky.github.io/image/10016.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By rain-Sky</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/rain-sky.github.io/js/utils.js"></script><script src="/rain-sky.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/rain-sky.github.io/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TGj0zYjdRMW2f2kd8Jp7ehjN-gzGzoHsz',
      appKey: 'VTWVdzNGf2aAQR168F40vnOY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="雨天,蓝色,Aimer,Hiten,抒情,纯音乐,旷野,星空,微风,蓝海" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/rain-sky.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/rain-sky.github.io/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>